using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine.Experimental.GlobalIllumination;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Experimental.Rendering.RenderGraphModule;
using UnityEngine.Rendering.HighDefinition.Attributes;
using UnityEngine.Rendering.HighDefinition.Compositor;
using UnityEngine.Rendering.LookDev;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.VFX;

namespace UnityEngine.Rendering.HighDefinition
{
	public class HDRenderPipeline : RenderPipeline, ICloudBackground, IDataProvider, IVolumetricCloud
	{
		internal class LightLoopTextureCaches
		{
			public LightCookieManager lightCookieManager { get; private set; }

			public ReflectionProbeTextureCache reflectionProbeTextureCache { get; private set; }

			public void Initialize(HDRenderPipelineAsset hdrpAsset, HDRenderPipelineRuntimeResources defaultResources, IBLFilterBSDF[] iBLFilterBSDFArray)
			{
				GlobalLightLoopSettings lightLoopSettings = hdrpAsset.currentPlatformRenderPipelineSettings.lightLoopSettings;
				lightCookieManager = new LightCookieManager(hdrpAsset, 2000000000);
				GraphicsFormat format = ((lightLoopSettings.reflectionProbeFormat == ReflectionAndPlanarProbeFormat.R11G11B10) ? GraphicsFormat.B10G11R11_UFloatPack32 : GraphicsFormat.R16G16B16A16_SFloat);
				Vector2Int reflectionProbeTextureCacheDim = GlobalLightLoopSettings.GetReflectionProbeTextureCacheDim(lightLoopSettings.reflectionProbeTexCacheSize);
				reflectionProbeTextureCache = new ReflectionProbeTextureCache(defaultResources, iBLFilterBSDFArray, reflectionProbeTextureCacheDim.x, reflectionProbeTextureCacheDim.y, format, lightLoopSettings.reflectionProbeDecreaseResToFit, lightLoopSettings.reflectionProbeTexLastValidCubeMip, lightLoopSettings.reflectionProbeTexLastValidPlanarMip);
			}

			public void Cleanup()
			{
				reflectionProbeTextureCache.Release();
				lightCookieManager.Release();
			}

			public void NewFrame()
			{
				lightCookieManager.NewFrame();
				reflectionProbeTextureCache.NewFrame();
			}

			public void NewRender()
			{
				reflectionProbeTextureCache.NewRender();
			}
		}

		internal class LightLoopLightData
		{
			public ComputeBuffer directionalLightData { get; private set; }

			public ComputeBuffer lightData { get; private set; }

			public ComputeBuffer envLightData { get; private set; }

			public ComputeBuffer decalData { get; private set; }

			public void Initialize(int directionalCount, int punctualCount, int areaLightCount, int envLightCount, int decalCount)
			{
				directionalLightData = new ComputeBuffer(directionalCount, Marshal.SizeOf(typeof(DirectionalLightData)));
				lightData = new ComputeBuffer(punctualCount + areaLightCount, Marshal.SizeOf(typeof(LightData)));
				envLightData = new ComputeBuffer(envLightCount, Marshal.SizeOf(typeof(EnvLightData)));
				decalData = new ComputeBuffer(decalCount, Marshal.SizeOf(typeof(DecalData)));
			}

			public void Cleanup()
			{
				CoreUtils.SafeRelease(directionalLightData);
				CoreUtils.SafeRelease(lightData);
				CoreUtils.SafeRelease(envLightData);
				CoreUtils.SafeRelease(decalData);
			}
		}

		private class TileAndClusterData
		{
			public bool listsAreClear;

			public ComputeBuffer lightVolumeDataBuffer { get; private set; }

			public ComputeBuffer convexBoundsBuffer { get; private set; }

			public bool clusterNeedsDepth { get; private set; }

			public bool hasTileBuffers { get; private set; }

			public int maxLightCount { get; private set; }

			public void Initialize(bool allocateTileBuffers, bool clusterNeedsDepth, int maxLightCount)
			{
				hasTileBuffers = allocateTileBuffers;
				this.clusterNeedsDepth = clusterNeedsDepth;
				this.maxLightCount = maxLightCount;
			}

			public void AllocateResolutionDependentBuffers(HDCamera hdCamera, int width, int height, int viewCount, int maxLightOnScreen)
			{
				convexBoundsBuffer = new ComputeBuffer(viewCount * maxLightOnScreen, Marshal.SizeOf(typeof(SFiniteLightBound)));
				lightVolumeDataBuffer = new ComputeBuffer(viewCount * maxLightOnScreen, Marshal.SizeOf(typeof(LightVolumeData)));
				listsAreClear = false;
			}

			public void ReleaseResolutionDependentBuffers()
			{
				CoreUtils.SafeRelease(convexBoundsBuffer);
				CoreUtils.SafeRelease(lightVolumeDataBuffer);
				convexBoundsBuffer = null;
				lightVolumeDataBuffer = null;
			}

			public void Cleanup()
			{
				ReleaseResolutionDependentBuffers();
			}
		}

		internal class LightList
		{
			public List<EnvLightData> envLights;

			public void Clear()
			{
				envLights.Clear();
			}

			public void Allocate()
			{
				envLights = new List<EnvLightData>();
			}
		}

		private enum ClusterPrepassSource
		{
			None = 0,
			BigTile = 1,
			Count = 2
		}

		private enum ClusterDepthSource
		{
			NoDepth = 0,
			Depth = 1,
			MSAA_Depth = 2,
			Count = 3
		}

		internal struct ScreenSpaceShadowData
		{
			public HDAdditionalLightData additionalLightData;

			public int lightDataIndex;

			public bool valid;
		}

		private struct LightLoopGlobalParameters
		{
			public HDCamera hdCamera;

			public TileAndClusterData tileAndClusterData;
		}

		private struct RenderAOParameters
		{
			public Vector2 runningRes;

			public int viewCount;

			public bool fullResolution;

			public bool runAsync;

			public bool temporalAccumulation;

			public bool bilateralUpsample;

			public ShaderVariablesAmbientOcclusion cb;
		}

		private class RenderAOPassData
		{
			public RenderAOParameters parameters;

			public ComputeShader gtaoCS;

			public int gtaoKernel;

			public TextureHandle packedData;

			public TextureHandle depthPyramid;

			public TextureHandle normalBuffer;
		}

		private class SpatialDenoiseAOPassData
		{
			public RenderAOParameters parameters;

			public ComputeShader spatialDenoiseAOCS;

			public int denoiseKernelSpatial;

			public TextureHandle packedData;

			public TextureHandle denoiseOutput;
		}

		private class TemporalDenoiseAOPassData
		{
			public RenderAOParameters parameters;

			public ComputeShader temporalDenoiseAOCS;

			public int denoiseKernelTemporal;

			public ComputeShader copyHistoryAOCS;

			public int denoiseKernelCopyHistory;

			public bool historyReady;

			public TextureHandle packedDataBlurred;

			public TextureHandle currentHistory;

			public TextureHandle outputHistory;

			public TextureHandle denoiseOutput;

			public TextureHandle motionVectors;
		}

		private class UpsampleAOPassData
		{
			public RenderAOParameters parameters;

			public ComputeShader upsampleAndBlurAOCS;

			public int upsampleAOKernel;

			public TextureHandle depthTexture;

			public TextureHandle input;

			public TextureHandle output;
		}

		private class TraceSSGIPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public Vector4 halfScreenSize;

			public float nearClipPlane;

			public float farClipPlane;

			public bool fullResolutionSS;

			public float thickness;

			public int raySteps;

			public int frameIndex;

			public Vector4 colorPyramidUvScaleAndLimitPrevFrame;

			public int rayMiss;

			public ComputeShader ssGICS;

			public int traceKernel;

			public int projectKernel;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public ComputeBuffer offsetBuffer;

			public ComputeBufferHandle lightList;

			public TextureHandle depthTexture;

			public TextureHandle stencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle motionVectorsBuffer;

			public TextureHandle colorPyramid;

			public TextureHandle historyDepth;

			public TextureHandle hitPointBuffer;

			public TextureHandle outputBuffer;
		}

		private class UpscaleSSGIPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public Vector4 halfScreenSize;

			public ShaderVariablesBilateralUpsample shaderVariablesBilateralUpsampleCB;

			public ComputeShader bilateralUpsampleCS;

			public int upscaleKernel;

			public TextureHandle depthTexture;

			public TextureHandle inputBuffer;

			public TextureHandle outputBuffer;
		}

		private enum ScreenSpaceShadowType
		{
			GrayScale = 0,
			Area = 1,
			Color = 2
		}

		private class ScreenSpaceShadowDebugPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public int targetShadow;

			public int debugKernel;

			public ComputeShader shadowFilter;

			public TextureHandle screenSpaceShadowArray;

			public TextureHandle outputBuffer;
		}

		private class WriteScreenSpaceShadowPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public Vector4 shadowChannelMask;

			public Vector4 shadowChannelMask0;

			public Vector4 shadowChannelMask1;

			public int shadowSlot;

			public int shadowKernel;

			public ComputeShader screenSpaceShadowCS;

			public TextureHandle inputShadowBuffer;

			public TextureHandle outputShadowArrayBuffer;
		}

		private class RTShadowAreaPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public int numSamples;

			public int lightIndex;

			public Matrix4x4 worldToLocalMatrix;

			public float historyValidity;

			public bool filterTracedShadow;

			public int areaShadowSlot;

			public int filterSize;

			public int areaRaytracingShadowPrepassKernel;

			public int areaRaytracingShadowNewSampleKernel;

			public int areaShadowApplyTAAKernel;

			public int areaUpdateAnalyticHistoryKernel;

			public int areaUpdateShadowHistoryKernel;

			public int areaEstimateNoiseKernel;

			public int areaFirstDenoiseKernel;

			public int areaSecondDenoiseKernel;

			public int areaShadowNoDenoiseKernel;

			public RayTracingAccelerationStructure accelerationStructure;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public ComputeShader screenSpaceShadowsCS;

			public ComputeShader screenSpaceShadowsFilterCS;

			public RayTracingShader screenSpaceShadowsRT;

			public Texture2D scramblingTex;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle motionVectorsBuffer;

			public TextureHandle gbuffer0;

			public TextureHandle gbuffer1;

			public TextureHandle gbuffer2;

			public TextureHandle gbuffer3;

			public TextureHandle shadowHistoryArray;

			public TextureHandle analyticHistoryArray;

			public TextureHandle directionBuffer;

			public TextureHandle rayLengthBuffer;

			public TextureHandle intermediateBufferRGBA1;

			public TextureHandle intermediateBufferRG0;

			public TextureHandle rayCountTexture;

			public TextureHandle outputShadowTexture;
		}

		private class RTSDirectionalTracePassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public bool softShadow;

			public int numShadowSamples;

			public bool colorShadow;

			public float maxShadowLength;

			public int clearShadowKernel;

			public int directionalShadowSample;

			public RayTracingShader screenSpaceShadowRT;

			public ComputeShader screenSpaceShadowCS;

			public RayTracingAccelerationStructure accelerationStructure;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle directionBuffer;

			public TextureHandle rayCountTexture;

			public TextureHandle velocityBuffer;

			public TextureHandle distanceBuffer;

			public TextureHandle outputShadowBuffer;
		}

		private class SSSDirectionalTracePassData
		{
			public int depthSlice;

			public TextureHandle normalBuffer;

			public TextureHandle screenSpaceShadowArray;
		}

		private class RTSPunctualTracePassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public bool distanceBasedFiltering;

			public int numShadowSamples;

			public bool semiTransparentShadow;

			public GPULightType lightType;

			public PunctualShadowProperties properties;

			public int clearShadowKernel;

			public int shadowKernel;

			public RayTracingShader screenSpaceShadowRT;

			public ComputeShader screenSpaceShadowCS;

			public RayTracingAccelerationStructure accelerationStructure;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle directionBuffer;

			public TextureHandle rayLengthBuffer;

			public TextureHandle rayCountTexture;

			public TextureHandle velocityBuffer;

			public TextureHandle distanceBuffer;

			public TextureHandle outputShadowBuffer;
		}

		private struct VolumetricCloudsCameraData
		{
			public TVolumetricCloudsCameraType cameraType;

			public int traceWidth;

			public int traceHeight;

			public int intermediateWidth;

			public int intermediateHeight;

			public int finalWidth;

			public int finalHeight;

			public int viewCount;

			public bool enableExposureControl;

			public bool lowResolution;

			public bool enableIntegration;
		}

		internal struct VolumetricCloudsAnimationData
		{
			public float lastTime;

			public Vector2 cloudOffset;

			public float verticalShapeOffset;

			public float verticalErosionOffset;
		}

		internal struct CloudModelData
		{
			public float densityMultiplier;

			public float shapeFactor;

			public float shapeScale;

			public float erosionFactor;

			public float erosionScale;

			public VolumetricClouds.CloudErosionNoise erosionNoise;
		}

		internal enum TVolumetricCloudsCameraType
		{
			Default = 0,
			RealtimeReflection = 1,
			BakedReflection = 2,
			PlanarReflection = 3,
			Sky = 4
		}

		private struct VolumetricCloudCommonData
		{
			public TVolumetricCloudsCameraType cameraType;

			public bool enableExposureControl;

			public bool localClouds;

			public Texture3D worley128RGBA;

			public Texture3D erosionNoise;

			public Texture cloudMapTexture;

			public Texture cloudLutTexture;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public Light sunLight;

			public ComputeShader volumetricCloudsCS;

			public ShaderVariablesClouds cloudsCB;
		}

		private struct VolumetricCloudsParameters_Accumulation
		{
			public int traceWidth;

			public int traceHeight;

			public int intermediateWidth;

			public int intermediateHeight;

			public int finalWidth;

			public int finalHeight;

			public int viewCount;

			public bool historyValidity;

			public bool needExtraColorBufferCopy;

			public Vector2Int previousViewportSize;

			public int convertObliqueDepthKernel;

			public int depthDownscaleKernel;

			public int renderKernel;

			public int reprojectKernel;

			public int upscaleAndCombineKernel;

			public VolumetricCloudCommonData commonData;

			public bool needsTemporaryBuffer;

			public Material cloudCombinePass;
		}

		private class VolumetricCloudsAccumulationData
		{
			public VolumetricCloudsParameters_Accumulation parameters;

			public TextureHandle colorBuffer;

			public TextureHandle depthPyramid;

			public TextureHandle motionVectors;

			public TextureHandle maxZMask;

			public ComputeBufferHandle ambientProbeBuffer;

			public TextureHandle volumetricLighting;

			public TextureHandle scatteringFallbackTexture;

			public TextureHandle previousHistoryBuffer0;

			public TextureHandle currentHistoryBuffer0;

			public TextureHandle previousHistoryBuffer1;

			public TextureHandle currentHistoryBuffer1;

			public TextureHandle intermediateBuffer0;

			public TextureHandle intermediateBuffer1;

			public TextureHandle intermediateBufferDepth0;

			public TextureHandle intermediateBufferDepth1;

			public TextureHandle intermediateBufferDepth2;

			public TextureHandle intermediateBufferUpscale;

			public TextureHandle intermediateColorBufferCopy;
		}

		private struct VolumetricCloudsParameters_FullResolution
		{
			public int finalWidth;

			public int finalHeight;

			public int viewCount;

			public int renderKernel;

			public int combineKernel;

			public VolumetricCloudCommonData commonData;

			public bool needsTemporaryBuffer;

			public bool needExtraColorBufferCopy;

			public Matrix4x4 pixelCoordToViewDirMatrix;

			public Material cloudCombinePass;
		}

		private class VolumetricCloudsFullResolutionData
		{
			public VolumetricCloudsParameters_FullResolution parameters;

			public TextureHandle colorBuffer;

			public TextureHandle depthPyramid;

			public TextureHandle maxZMask;

			public ComputeBufferHandle ambientProbeBuffer;

			public TextureHandle volumetricLighting;

			public TextureHandle scatteringFallbackTexture;

			public TextureHandle intermediateLightingBuffer;

			public TextureHandle intermediateBufferDepth;

			public TextureHandle intermediateBufferUpscale;

			public TextureHandle intermediateColorBufferCopy;
		}

		private struct VolumetricCloudsParameters_LowResolution
		{
			public int traceWidth;

			public int traceHeight;

			public int intermediateWidth;

			public int intermediateHeight;

			public int finalWidth;

			public int finalHeight;

			public int viewCount;

			public bool needExtraColorBufferCopy;

			public int depthDownscaleKernel;

			public int renderKernel;

			public int preUpscaleKernel;

			public int upscaleAndCombineKernel;

			public VolumetricCloudCommonData commonData;

			public bool needsTemporaryBuffer;

			public Material cloudCombinePass;
		}

		private class VolumetricCloudsLowResolutionData
		{
			public VolumetricCloudsParameters_LowResolution parameters;

			public TextureHandle colorBuffer;

			public TextureHandle depthPyramid;

			public TextureHandle maxZMask;

			public ComputeBufferHandle ambientProbeBuffer;

			public TextureHandle volumetricLighting;

			public TextureHandle scatteringFallbackTexture;

			public TextureHandle intermediateLightingBuffer0;

			public TextureHandle intermediateLightingBuffer1;

			public TextureHandle intermediateLightingBuffer2;

			public TextureHandle intermediateBufferDepth0;

			public TextureHandle intermediateBufferDepth1;

			public TextureHandle intermediateBufferUpscale;

			public TextureHandle intermediateColorBufferCopy;
		}

		private struct CloudMapGenerationParameters
		{
			public int cloudMapResolution;

			public ComputeShader generationCS;

			public int generationKernel;

			public Texture cumulusMap;

			public float cumulusMapMultiplier;

			public Texture altostratusMap;

			public float altoStratusMapMultiplier;

			public Texture cumulonimbusMap;

			public float cumulonimbusMapMultiplier;

			public Texture rainMap;
		}

		private class VolumetricCloudsMapData
		{
			public CloudMapGenerationParameters parameters;

			public TextureHandle cloudMapTexture;
		}

		private struct VolumetricCloudsShadowsParameters
		{
			public VolumetricCloudCommonData commonData;

			public int shadowsKernel;

			public int filterShadowsKernel;
		}

		private class VolumetricCloudsShadowData
		{
			public VolumetricCloudsShadowsParameters parameters;

			public TextureHandle shadowTexture;
		}

		private class VolumetricCloudsSkyLowPassData
		{
			public int traceWidth;

			public int traceHeight;

			public int intermediateWidth;

			public int intermediateHeight;

			public int finalWidth;

			public int finalHeight;

			public int renderKernel;

			public int preUpscaleKernel;

			public int finalUpscaleKernel;

			public VolumetricCloudCommonData commonData;

			public Material cloudCombinePass;

			public CubemapFace cubemapFace;

			public Matrix4x4[] pixelCoordToViewDir;

			public TextureHandle intermediateLightingBuffer;

			public TextureHandle intermediateDepthBuffer;

			public TextureHandle output;

			public TextureHandle maxZMask;

			public ComputeBufferHandle ambientProbeBuffer;
		}

		private class VolumetricCloudsSkyHighPassData
		{
			public int finalWidth;

			public int finalHeight;

			public int renderKernel;

			public int combineKernel;

			public VolumetricCloudCommonData commonData;

			public bool renderForCubeMap;

			public CubemapFace cubemapFace;

			public Material cloudCombinePass;

			public Matrix4x4[] pixelCoordToViewDir;

			public TextureHandle intermediateLightingBuffer0;

			public TextureHandle intermediateLightingBuffer1;

			public TextureHandle intermediateDepthBuffer;

			public TextureHandle output;

			public TextureHandle maxZMask;

			public ComputeBufferHandle ambientProbeBuffer;
		}

		private class VolumetricCloudsPreUpscalePassData
		{
			public Material cloudCombinePass;

			public TextureHandle input;

			public TextureHandle output;

			public Matrix4x4[] pixelCoordToViewDir;
		}

		private class VolumetricCloudsUpscalePassData
		{
			public Material cloudCombinePass;

			public TextureHandle input;

			public TextureHandle intermediateBuffer;

			public TextureHandle output;

			public Matrix4x4[] pixelCoordToViewDir;
		}

		private class GenerateMaxZMaskPassData
		{
			public ComputeShader generateMaxZCS;

			public int maxZKernel;

			public int maxZDownsampleKernel;

			public int dilateMaxZKernel;

			public Vector2Int intermediateMaskSize;

			public Vector2Int finalMaskSize;

			public Vector2Int minDepthMipOffset;

			public float dilationWidth;

			public int viewCount;

			public TextureHandle depthTexture;

			public TextureHandle maxZ8xBuffer;

			public TextureHandle maxZBuffer;

			public TextureHandle dilatedMaxZBuffer;
		}

		private class HeightFogVoxelizationPassData
		{
			public ComputeShader voxelizationCS;

			public int voxelizationKernel;

			public Vector4 resolution;

			public int viewCount;

			public ShaderVariablesVolumetric volumetricCB;

			public ShaderVariablesLightList lightListCB;

			public TextureHandle densityBuffer;

			public ComputeBuffer volumetricAmbientProbeBuffer;
		}

		private class LocalVolumetricFogMaterialVoxelizationPassData
		{
			public HDCamera hdCamera;

			public Fog fog;

			public int maxSliceCount;

			public Vector3Int viewportSize;

			public List<LocalVolumetricFog> volumetricFogs;

			public TextureHandle densityBuffer;

			public Material defaultVolumetricMaterial;

			public List<LocalVolumetricFogEngineData> visibleVolumeData;

			public List<OrientedBBox> visibleVolumeBounds;

			public int computeRenderingParametersKernel;

			public ComputeShader volumetricMaterialCS;

			public ComputeBufferHandle indirectArgumentBuffer;

			public ComputeBuffer visibleVolumeBoundsBuffer;

			public GraphicsBuffer materialDataBuffer;

			public GraphicsBuffer triangleFanIndexBuffer;

			public NativeArray<uint> fogVolumeSortKeys;

			public bool fogOverdrawDebugEnabled;

			public TextureHandle fogOverdrawOutput;
		}

		private class VolumetricLightingPassData
		{
			public ComputeShader volumetricLightingCS;

			public ComputeShader volumetricLightingFilteringCS;

			public int volumetricLightingKernel;

			public int volumetricFilteringKernel;

			public bool tiledLighting;

			public Vector4 resolution;

			public bool enableReprojection;

			public int viewCount;

			public int sliceCount;

			public bool filterVolume;

			public bool filteringNeedsExtraBuffer;

			public ShaderVariablesVolumetric volumetricCB;

			public ShaderVariablesLightList lightListCB;

			public TextureHandle densityBuffer;

			public TextureHandle depthTexture;

			public TextureHandle lightingBuffer;

			public TextureHandle filteringOutputBuffer;

			public TextureHandle maxZBuffer;

			public TextureHandle historyBuffer;

			public TextureHandle feedbackBuffer;

			public ComputeBufferHandle bigTileLightListBuffer;

			public ComputeBuffer volumetricAmbientProbeBuffer;
		}

		private class RenderDenoisePassData
		{
			public ComputeShader blitAndExposeCS;

			public int blitAndExposeKernel;

			public TextureHandle color;

			public TextureHandle normalAOV;

			public TextureHandle albedoAOV;

			public TextureHandle motionVectorAOV;

			public TextureHandle outputTexture;

			public TextureHandle denoiseHistory;

			public SubFrameManager subFrameManager;

			public int camID;

			public bool useAOV;

			public bool temporal;

			public bool async;

			public int width;

			public int height;

			public int slices;
		}

		private class RenderAccumulationPassData
		{
			public ComputeShader accumulationCS;

			public int accumulationKernel;

			public SubFrameManager subFrameManager;

			public bool needExposure;

			public HDCamera hdCamera;

			public Vector4 frameWeights;

			public TextureHandle input;

			public TextureHandle output;

			public TextureHandle history;

			public bool useInputTexture;

			public bool useOutputTexture;

			public LocalKeyword inputKeyword;

			public LocalKeyword outputKeyword;
		}

		private struct RenderRequest
		{
			public struct Target
			{
				public RenderTargetIdentifier id;

				public CubemapFace face;

				public RTHandle targetDepth;
			}

			public HDCamera hdCamera;

			public bool clearCameraSettings;

			public Target target;

			public HDCullingResults cullingResults;

			public int index;

			public List<int> dependsOnRenderRequestIndices;

			public CameraSettings cameraSettings;

			public List<(HDProbe.RenderData, HDProbe)> viewDependentProbesData;

			public bool cullingResultIsShared;
		}

		private class HDCullingResults
		{
			public CullingResults cullingResults;

			public CullingResults uiCullingResults;

			public CullingResults? customPassCullingResults;

			public HDProbeCullingResults hdProbeCullingResults = new HDProbeCullingResults();

			public DecalSystem.CullResult decalCullResults;

			internal void Reset()
			{
				hdProbeCullingResults.Reset();
				if (decalCullResults != null)
				{
					decalCullResults.Clear();
				}
				else
				{
					decalCullResults = GenericPool<DecalSystem.CullResult>.Get();
				}
			}
		}

		private class MonitorsPassData
		{
			public float sizeRatio;

			public Material blitMaterial;

			public TextureHandle colorTexture;

			public TextureHandle downsampledInput;

			public Vector2Int downsampledSize;

			public Vector2Int inputSize;

			public MonitorsDebugSettings settings;

			public int runtimeDebugPannelWidth;

			public ComputeShader waveformCS;

			public ComputeBufferHandle waveformBuffer;

			public TextureHandle waveformTexture;

			public Material waveformMaterial;

			public int waveformClearKernel;

			public int waveformGatherKernel;

			public ComputeShader vectorscopeCS;

			public ComputeBufferHandle vectorscopeBuffer;

			public TextureHandle vectorscopeTexture;

			public Material vectorscopeMaterial;

			public Vector2Int vectorscopeSize;

			public int vectorscopeBufferSize;

			public int vectorscopeGatherKernel;

			public int vectorscopeClearKernel;
		}

		private class TransparencyOverdrawPassData
		{
			public FrameSettings frameSettings;

			public ShaderVariablesDebugDisplay constantBuffer;

			public RendererListHandle transparencyRL;

			public RendererListHandle transparencyAfterPostRL;

			public RendererListHandle transparencyLowResRL;
		}

		private class FullScreenDebugPassData
		{
			public FrameSettings frameSettings;

			public ComputeBufferHandle debugBuffer;

			public RendererListHandle rendererList;

			public ComputeShader clearBufferCS;

			public int clearBufferCSKernel;

			public int width;

			public int height;

			public int viewCount;
		}

		private class ResolveFullScreenDebugPassData
		{
			public DebugDisplaySettings debugDisplaySettings;

			public Material debugFullScreenMaterial;

			public HDCamera hdCamera;

			public int depthPyramidMip;

			public ComputeBuffer depthPyramidOffsets;

			public TextureHandle output;

			public TextureHandle input;

			public TextureHandle depthPyramid;

			public ComputeBufferHandle fullscreenBuffer;
		}

		private class ResolveColorPickerDebugPassData
		{
			public HDCamera hdCamera;

			public DebugDisplaySettings debugDisplaySettings;

			public Material colorPickerMaterial;

			public TextureHandle output;

			public TextureHandle input;
		}

		private class DebugOverlayPassData
		{
			public DebugOverlay debugOverlay;

			public TextureHandle colorBuffer;

			public TextureHandle depthBuffer;
		}

		private class SkyReflectionOverlayPassData : DebugOverlayPassData
		{
			public LightingDebugSettings lightingDebugSettings;

			public Material debugLatlongMaterial;

			public Texture skyReflectionTexture;
		}

		private class RenderAtlasDebugOverlayPassData : DebugOverlayPassData
		{
			public Texture atlasTexture;

			public int mipLevel;

			public Material debugBlitMaterial;
		}

		private class RenderTileClusterDebugOverlayPassData : DebugOverlayPassData
		{
			public HDCamera hdCamera;

			public TextureHandle depthPyramidTexture;

			public ComputeBufferHandle tileList;

			public ComputeBufferHandle lightList;

			public ComputeBufferHandle perVoxelLightList;

			public ComputeBufferHandle dispatchIndirect;

			public Material debugViewTilesMaterial;

			public LightingDebugSettings lightingDebugSettings;

			public Vector4 lightingViewportSize;
		}

		private class RenderShadowsDebugOverlayPassData : DebugOverlayPassData
		{
			public LightingDebugSettings lightingDebugSettings;

			public ShadowResult shadowTextures;

			public HDShadowManager shadowManager;

			public int debugSelectedLightShadowIndex;

			public int debugSelectedLightShadowCount;

			public Material debugShadowMapMaterial;
		}

		private class RenderDecalOverlayPassData : DebugOverlayPassData
		{
			public int mipLevel;

			public HDCamera hdCamera;
		}

		private class DebugImageHistogramData
		{
			public ComputeShader debugImageHistogramCS;

			public ComputeBuffer imageHistogram;

			public int debugImageHistogramKernel;

			public int cameraWidth;

			public int cameraHeight;

			public TextureHandle source;
		}

		private class GenerateHDRDebugData
		{
			public ComputeShader generateXYMappingCS;

			public TextureHandle xyBuffer;

			public int debugXYGenKernel;

			public int cameraWidth;

			public int cameraHeight;

			public Vector4 debugParameters;

			public TextureHandle source;
		}

		private class DebugHDRData
		{
			public LightingDebugSettings lightingDebugSettings;

			public Material debugHDRMaterial;

			public Vector4 hdrOutputParams;

			public Vector4 hdrOutputParams2;

			public Vector4 hdrDebugParams;

			public int debugPass;

			public ComputeBufferHandle xyMappingBuffer;

			public TextureHandle colorBuffer;

			public TextureHandle xyTexture;

			public TextureHandle debugFullScreenTexture;

			public TextureHandle output;
		}

		private class DebugExposureData
		{
			public LightingDebugSettings lightingDebugSettings;

			public HDCamera hdCamera;

			public Material debugExposureMaterial;

			public Vector4 proceduralMeteringParams1;

			public Vector4 proceduralMeteringParams2;

			public TextureHandle colorBuffer;

			public TextureHandle debugFullScreenTexture;

			public TextureHandle output;

			public TextureHandle currentExposure;

			public TextureHandle previousExposure;

			public TextureHandle debugExposureData;

			public HableCurve customToneMapCurve;

			public int lutSize;

			public ComputeBuffer histogramBuffer;
		}

		private class DebugViewMaterialData
		{
			public TextureHandle outputColor;

			public TextureHandle outputDepth;

			public RendererListHandle opaqueRendererList;

			public RendererListHandle transparentRendererList;

			public Material debugGBufferMaterial;

			public FrameSettings frameSettings;

			public bool decalsEnabled;

			public ComputeBufferHandle perVoxelOffset;

			public DBufferOutput dbuffer;

			public GBufferOutput gbuffer;

			public TextureHandle depthBuffer;

			public Texture clearColorTexture;

			public RenderTexture clearDepthTexture;

			public bool clearDepth;
		}

		private class PushFullScreenDebugPassData
		{
			public TextureHandle input;

			public TextureHandle output;

			public int mipIndex;

			public bool xrTexture;

			public bool useCustomScaleBias;

			public Vector4 customScaleBias;
		}

		private struct LightingBuffers
		{
			public TextureHandle sssBuffer;

			public TextureHandle diffuseLightingBuffer;

			public TextureHandle ambientOcclusionBuffer;

			public TextureHandle ssrLightingBuffer;

			public TextureHandle ssgiLightingBuffer;

			public TextureHandle contactShadowsBuffer;

			public TextureHandle screenspaceShadowBuffer;
		}

		private class BuildGPULightListPassData
		{
			public int totalLightCount;

			public int viewCount;

			public bool runLightList;

			public bool clearLightLists;

			public bool enableFeatureVariants;

			public bool computeMaterialVariants;

			public bool computeLightVariants;

			public bool skyEnabled;

			public LightList lightList;

			public bool canClearLightList;

			public int directionalLightCount;

			public ComputeShader clearLightListCS;

			public int clearLightListKernel;

			public ComputeShader screenSpaceAABBShader;

			public int screenSpaceAABBKernel;

			public ComputeShader bigTilePrepassShader;

			public int bigTilePrepassKernel;

			public bool runBigTilePrepass;

			public int numBigTilesX;

			public int numBigTilesY;

			public ComputeShader buildPerTileLightListShader;

			public int buildPerTileLightListKernel;

			public bool runFPTL;

			public int numTilesFPTLX;

			public int numTilesFPTLY;

			public int numTilesFPTL;

			public ComputeShader buildPerVoxelLightListShader;

			public ComputeShader clearClusterAtomicIndexShader;

			public int buildPerVoxelLightListKernel;

			public int numTilesClusterX;

			public int numTilesClusterY;

			public bool clusterNeedsDepth;

			public ComputeShader buildMaterialFlagsShader;

			public ComputeShader clearDispatchIndirectShader;

			public ComputeShader buildDispatchIndirectShader;

			public bool useComputeAsPixel;

			public ShaderVariablesLightList lightListCB;

			public TextureHandle depthBuffer;

			public TextureHandle stencilTexture;

			public TextureHandle[] gBuffer = new TextureHandle[RenderGraph.kMaxMRTCount];

			public int gBufferCount;

			public ComputeBufferHandle convexBoundsBuffer;

			public ComputeBufferHandle AABBBoundsBuffer;

			public ComputeBufferHandle globalLightListAtomic;

			public ComputeBufferHandle lightVolumeDataBuffer;

			public BuildGPULightListOutput output;
		}

		private struct BuildGPULightListOutput
		{
			public ComputeBufferHandle lightList;

			public ComputeBufferHandle tileList;

			public ComputeBufferHandle tileFeatureFlags;

			public ComputeBufferHandle dispatchIndirectBuffer;

			public ComputeBufferHandle bigTileLightList;

			public ComputeBufferHandle perVoxelOffset;

			public ComputeBufferHandle perVoxelLightLists;

			public ComputeBufferHandle perTileLogBaseTweak;
		}

		private class PushGlobalCameraParamPassData
		{
			public HDCamera hdCamera;

			public ShaderVariablesGlobal globalCB;

			public ShaderVariablesXR xrCB;
		}

		private class DeferredLightingPassData
		{
			public int numTilesX;

			public int numTilesY;

			public int numTiles;

			public bool enableTile;

			public bool outputSplitLighting;

			public bool useComputeLightingEvaluation;

			public bool enableFeatureVariants;

			public bool enableShadowMasks;

			public int numVariants;

			public DebugDisplaySettings debugDisplaySettings;

			public ComputeShader deferredComputeShader;

			public int viewCount;

			public Material splitLightingMat;

			public Material regularLightingMat;

			public TextureHandle colorBuffer;

			public TextureHandle sssDiffuseLightingBuffer;

			public TextureHandle depthBuffer;

			public TextureHandle depthTexture;

			public int gbufferCount;

			public int lightLayersTextureIndex;

			public int shadowMaskTextureIndex;

			public TextureHandle[] gbuffer = new TextureHandle[8];

			public ComputeBufferHandle lightListBuffer;

			public ComputeBufferHandle tileFeatureFlagsBuffer;

			public ComputeBufferHandle tileListBuffer;

			public ComputeBufferHandle dispatchIndirectBuffer;

			public LightingBuffers lightingBuffers;
		}

		private struct LightingOutput
		{
			public TextureHandle colorBuffer;
		}

		private class RenderSSRPassData
		{
			public ComputeShader ssrCS;

			public int tracingKernel;

			public int reprojectionKernel;

			public int accumulateNoWorldSpeedRejectionBothKernel;

			public int accumulateNoWorldSpeedRejectionSurfaceKernel;

			public int accumulateNoWorldSpeedRejectionHitKernel;

			public int accumulateHardThresholdSpeedRejectionBothKernel;

			public int accumulateHardThresholdSpeedRejectionSurfaceKernel;

			public int accumulateHardThresholdSpeedRejectionHitKernel;

			public int accumulateSmoothSpeedRejectionBothKernel;

			public int accumulateSmoothSpeedRejectionSurfaceKernel;

			public int accumulateSmoothSpeedRejectionHitKernel;

			public int accumulateNoWorldSpeedRejectionBothDebugKernel;

			public int accumulateNoWorldSpeedRejectionSurfaceDebugKernel;

			public int accumulateNoWorldSpeedRejectionHitDebugKernel;

			public int accumulateHardThresholdSpeedRejectionBothDebugKernel;

			public int accumulateHardThresholdSpeedRejectionSurfaceDebugKernel;

			public int accumulateHardThresholdSpeedRejectionHitDebugKernel;

			public int accumulateSmoothSpeedRejectionBothDebugKernel;

			public int accumulateSmoothSpeedRejectionSurfaceDebugKernel;

			public int accumulateSmoothSpeedRejectionHitDebugKernel;

			public bool transparentSSR;

			public bool usePBRAlgo;

			public bool accumNeedClear;

			public bool previousAccumNeedClear;

			public bool validColorPyramid;

			public int width;

			public int height;

			public int viewCount;

			public ComputeBuffer offsetBufferData;

			public ShaderVariablesScreenSpaceReflection cb;

			public TextureHandle depthBuffer;

			public TextureHandle depthPyramid;

			public TextureHandle normalBuffer;

			public TextureHandle motionVectorsBuffer;

			public TextureHandle colorPyramid;

			public TextureHandle stencilBuffer;

			public TextureHandle hitPointsTexture;

			public TextureHandle ssrAccum;

			public TextureHandle lightingTexture;

			public TextureHandle ssrAccumPrev;

			public TextureHandle clearCoatMask;

			public ComputeBufferHandle coarseStencilBuffer;

			public BlueNoise blueNoise;

			public HDCamera hdCamera;

			public ComputeShader clearBuffer2DCS;

			public int clearBuffer2DKernel;

			public bool useAsync;

			public float frameIndex;

			public float roughnessBiasFactor;

			public float speedRejection;

			public float speedRejectionFactor;

			public bool debugDisplaySpeed;

			public bool enableWorldSmoothRejection;

			public bool smoothSpeedRejection;

			public bool motionVectorFromSurface;

			public bool motionVectorFromHit;
		}

		private class RenderContactShadowPassData
		{
			public ComputeShader contactShadowsCS;

			public int kernel;

			public Vector4 params1;

			public Vector4 params2;

			public Vector4 params3;

			public int numTilesX;

			public int numTilesY;

			public int viewCount;

			public bool rayTracingEnabled;

			public RayTracingShader contactShadowsRTS;

			public RayTracingAccelerationStructure accelerationStructure;

			public int actualWidth;

			public int actualHeight;

			public int depthTextureParameterName;

			public LightLoopLightData lightLoopLightData;

			public TextureHandle depthTexture;

			public TextureHandle contactShadowsTexture;

			public ComputeBufferHandle lightList;
		}

		private struct LookDevDataForHDRP
		{
			public HDAdditionalCameraData additionalCameraData;

			public HDAdditionalLightData additionalLightData;

			public VisualEnvironment visualEnvironment;

			public HDRISky sky;

			public Volume volume;
		}

		private enum SMAAStage
		{
			EdgeDetection = 0,
			BlendWeights = 1,
			NeighborhoodBlending = 2
		}

		private enum ResolutionGroup
		{
			BeforeDynamicResUpscale = 0,
			AfterDynamicResUpscale = 1
		}

		private struct PostProcessHistoryTextureAllocator
		{
			private string m_Name;

			private Vector2Int m_Size;

			private bool m_EnableMips;

			private bool m_UseDynamicScale;

			private GraphicsFormat m_Format;

			public PostProcessHistoryTextureAllocator(string newName, Vector2Int newSize, GraphicsFormat format = GraphicsFormat.R16_SFloat, bool enableMips = false, bool useDynamicScale = false)
			{
				m_Name = newName;
				m_Size = newSize;
				m_EnableMips = enableMips;
				m_UseDynamicScale = useDynamicScale;
				m_Format = format;
			}

			public RTHandle Allocator(string id, int frameIndex, RTHandleSystem rtHandleSystem)
			{
				return rtHandleSystem.Alloc(m_Size.x, m_Size.y, TextureXR.slices, DepthBits.None, m_Format, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, m_EnableMips, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, m_UseDynamicScale, RenderTextureMemoryless.None, VRTextureUsage.None, $"{id} {m_Name} {frameIndex}");
			}
		}

		private class RestoreNonJitteredPassData
		{
			public ShaderVariablesGlobal globalCB;

			public HDCamera hdCamera;
		}

		private class DLSSColorMaskPassData
		{
			public Material colorMaskMaterial;

			public int destWidth;

			public int destHeight;
		}

		private class DLSSData
		{
			public DLSSPass.Parameters parameters;

			public DLSSPass.CameraResourcesHandles resourceHandles;

			public DLSSPass pass;
		}

		private class AlphaCopyPassData
		{
			public ComputeShader copyAlphaCS;

			public int copyAlphaKernel;

			public HDCamera hdCamera;

			public TextureHandle source;

			public TextureHandle outputAlpha;
		}

		private class StopNaNPassData
		{
			public ComputeShader nanKillerCS;

			public int nanKillerKernel;

			public int width;

			public int height;

			public int viewCount;

			public TextureHandle source;

			public TextureHandle destination;
		}

		private class DynamicExposureData
		{
			public ComputeShader exposureCS;

			public ComputeShader histogramExposureCS;

			public int exposurePreparationKernel;

			public int exposureReductionKernel;

			public Texture textureMeteringMask;

			public Texture exposureCurve;

			public HDCamera camera;

			public Vector2Int viewportSize;

			public ComputeBuffer histogramBuffer;

			public ExposureMode exposureMode;

			public bool histogramUsesCurve;

			public bool histogramOutputDebugData;

			public int[] exposureVariants;

			public Vector4 exposureParams;

			public Vector4 exposureParams2;

			public Vector4 proceduralMaskParams;

			public Vector4 proceduralMaskParams2;

			public Vector4 histogramExposureParams;

			public Vector4 adaptationParams;

			public TextureHandle source;

			public TextureHandle prevExposure;

			public TextureHandle nextExposure;

			public TextureHandle exposureDebugData;

			public TextureHandle tmpTarget1024;

			public TextureHandle tmpTarget32;
		}

		private class ApplyExposureData
		{
			public ComputeShader applyExposureCS;

			public int applyExposureKernel;

			public int width;

			public int height;

			public int viewCount;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle prevExposure;
		}

		private class CustomPostProcessData
		{
			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle depthBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle motionVecTexture;

			public HDCamera hdCamera;

			public CustomPostProcessVolumeComponent customPostProcess;

			public Vector4 postProcessScales;

			public Vector2Int postProcessViewportSize;
		}

		private class TemporalAntiAliasingData
		{
			public Material temporalAAMaterial;

			public bool resetPostProcessingHistory;

			public Vector4 previousScreenSize;

			public Vector4 taaParameters;

			public Vector4 taaParameters1;

			public float[] taaFilterWeights;

			public bool motionVectorRejection;

			public Vector4 taauParams;

			public Rect finalViewport;

			public Rect prevFinalViewport;

			public Vector4 taaScales;

			public bool runsTAAU;

			public bool runsAfterUpscale;

			public bool msaaIsEnabled;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle motionVecTexture;

			public TextureHandle depthBuffer;

			public TextureHandle stencilBuffer;

			public TextureHandle depthMipChain;

			public TextureHandle prevHistory;

			public TextureHandle nextHistory;

			public TextureHandle prevMVLen;

			public TextureHandle nextMVLen;
		}

		private class SMAAData
		{
			public Material smaaMaterial;

			public Texture smaaAreaTex;

			public Texture smaaSearchTex;

			public Vector4 smaaRTMetrics;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle depthBuffer;

			public TextureHandle smaaEdgeTex;

			public TextureHandle smaaBlendTex;
		}

		private struct DepthOfFieldParameters
		{
			public ComputeShader dofKernelCS;

			public int dofKernelKernel;

			public ComputeShader dofCoCCS;

			public int dofCoCKernel;

			public ComputeShader dofCoCReprojectCS;

			public int dofCoCReprojectKernel;

			public ComputeShader dofDilateCS;

			public int dofDilateKernel;

			public ComputeShader dofMipCS;

			public int dofMipColorKernel;

			public int dofMipCoCKernel;

			public ComputeShader dofMipSafeCS;

			public int dofMipSafeKernel;

			public ComputeShader dofPrefilterCS;

			public int dofPrefilterKernel;

			public ComputeShader dofTileMaxCS;

			public int dofTileMaxKernel;

			public ComputeShader dofGatherCS;

			public int dofGatherNearKernel;

			public int dofGatherFarKernel;

			public ComputeShader dofCombineCS;

			public int dofCombineKernel;

			public ComputeShader dofPrecombineFarCS;

			public int dofPrecombineFarKernel;

			public ComputeShader dofClearIndirectArgsCS;

			public int dofClearIndirectArgsKernel;

			public ComputeShader dofCircleOfConfusionCS;

			public int dofCircleOfConfusionKernel;

			public ComputeShader pbDoFCoCMinMaxCS;

			public int pbDoFMinMaxKernel;

			public ComputeShader pbDoFGatherCS;

			public int pbDoFGatherKernel;

			public ComputeShader pbDoFDilateCS;

			public int pbDoFDilateKernel;

			public ComputeShader pbDoFCombineCS;

			public int pbDoFCombineKernel;

			public int minMaxCoCTileSize;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public HDCamera camera;

			public Vector2Int viewportSize;

			public bool nearLayerActive;

			public bool farLayerActive;

			public bool highQualityFiltering;

			public bool useTiles;

			public bool resetPostProcessingHistory;

			public DepthOfFieldResolution resolution;

			public DepthOfFieldMode focusMode;

			public Vector2 adaptiveSamplingWeights;

			public Vector2 physicalCameraCurvature;

			public float physicalCameraAperture;

			public float physicalCameraAnamorphism;

			public float physicalCameraBarrelClipping;

			public int physicalCameraBladeCount;

			public int farSampleCount;

			public int nearSampleCount;

			public float farMaxBlur;

			public float nearMaxBlur;

			public float nearFocusStart;

			public float nearFocusEnd;

			public float farFocusStart;

			public float farFocusEnd;

			public float focusDistance;

			public Vector2Int threadGroup8;

			public bool useMipSafePath;
		}

		private class DepthofFieldData
		{
			public DepthOfFieldParameters parameters;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle depthBuffer;

			public TextureHandle motionVecTexture;

			public TextureHandle pingNearRGB;

			public TextureHandle pongNearRGB;

			public TextureHandle nearCoC;

			public TextureHandle nearAlpha;

			public TextureHandle dilatedNearCoC;

			public TextureHandle pingFarRGB;

			public TextureHandle pongFarRGB;

			public TextureHandle farCoC;

			public TextureHandle fullresCoC;

			public TextureHandle[] mips = new TextureHandle[4];

			public TextureHandle dilationPingPongRT;

			public TextureHandle prevCoC;

			public TextureHandle nextCoC;

			public TextureHandle depthMinMaxAvgMSAA;

			public ComputeBufferHandle bokehNearKernel;

			public ComputeBufferHandle bokehFarKernel;

			public ComputeBufferHandle bokehIndirectCmd;

			public ComputeBufferHandle nearBokehTileList;

			public ComputeBufferHandle farBokehTileList;

			public bool taaEnabled;
		}

		private class LensFlareData
		{
			public LensFlareParameters parameters;

			public TextureHandle source;

			public TextureHandle depthBuffer;

			public TextureHandle occlusion;

			public TextureHandle cloudOpacityTexture;

			public TextureHandle sunOcclusion;

			public HDCamera hdCamera;

			public Vector2Int viewport;

			public bool taaEnabled;

			public bool hasCloudLayer;
		}

		private struct LensFlareParameters
		{
			public Material lensFlareShader;

			public ComputeShader lensFlareMergeOcclusion;

			public int mergeOcclusionKernel;

			public LensFlareCommonSRP lensFlares;

			public float paniniDistance;

			public float paniniCropToFit;

			public bool skipCopy;

			public bool usePanini;
		}

		private class MotionBlurData
		{
			public ComputeShader motionVecPrepCS;

			public ComputeShader tileGenCS;

			public ComputeShader tileNeighbourhoodCS;

			public ComputeShader tileMergeCS;

			public ComputeShader motionBlurCS;

			public int motionVecPrepKernel;

			public int tileGenKernel;

			public int tileNeighbourhoodKernel;

			public int tileMergeKernel;

			public int motionBlurKernel;

			public HDCamera camera;

			public Vector2Int viewportSize;

			public Vector4 tileTargetSize;

			public Vector4 motionBlurParams0;

			public Vector4 motionBlurParams1;

			public Vector4 motionBlurParams2;

			public Vector4 motionBlurParams3;

			public bool motionblurSupportScattering;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle depthBuffer;

			public TextureHandle motionVecTexture;

			public TextureHandle preppedMotionVec;

			public TextureHandle minMaxTileVel;

			public TextureHandle maxTileNeigbourhood;

			public TextureHandle tileToScatterMax;

			public TextureHandle tileToScatterMin;
		}

		private class PaniniProjectionData
		{
			public ComputeShader paniniProjectionCS;

			public int paniniProjectionKernel;

			public Vector4 paniniParams;

			public int width;

			public int height;

			public int viewCount;

			public TextureHandle source;

			public TextureHandle destination;
		}

		private class BloomData
		{
			public ComputeShader bloomPrefilterCS;

			public ComputeShader bloomBlurCS;

			public ComputeShader bloomUpsampleCS;

			public int bloomPrefilterKernel;

			public int bloomBlurKernel;

			public int bloomDownsampleKernel;

			public int bloomUpsampleKernel;

			public int viewCount;

			public int bloomMipCount;

			public Vector4[] bloomMipInfo = new Vector4[17];

			public float bloomScatterParam;

			public Vector4 thresholdParams;

			public TextureHandle source;

			public TextureHandle[] mipsDown = new TextureHandle[17];

			public TextureHandle[] mipsUp = new TextureHandle[17];
		}

		internal class ColorGradingPassData
		{
			public ComputeShader builderCS;

			public int builderKernel;

			public int lutSize;

			public Vector4 colorFilter;

			public Vector3 lmsColorBalance;

			public Vector4 hueSatCon;

			public Vector4 channelMixerR;

			public Vector4 channelMixerG;

			public Vector4 channelMixerB;

			public Vector4 shadows;

			public Vector4 midtones;

			public Vector4 highlights;

			public Vector4 shadowsHighlightsLimits;

			public Vector4 lift;

			public Vector4 gamma;

			public Vector4 gain;

			public Vector4 splitShadows;

			public Vector4 splitHighlights;

			public Vector4 hdroutParameters;

			public Vector4 hdroutParameters2;

			public ColorCurves curves;

			public HableCurve hableCurve;

			public Vector4 miscParams;

			public Texture externalLuT;

			public float lutContribution;

			public TonemappingMode tonemappingMode;

			public TextureHandle logLut;
		}

		private class UberPostPassData
		{
			public ComputeShader uberPostCS;

			public int uberPostKernel;

			public bool outputColorLog;

			public bool isSearchingInHierarchy;

			public int width;

			public int height;

			public int viewCount;

			public Vector4 logLutSettings;

			public Vector4 lensDistortionParams1;

			public Vector4 lensDistortionParams2;

			public Texture spectralLut;

			public Vector4 chromaticAberrationParameters;

			public Vector4 vignetteParams1;

			public Vector4 vignetteParams2;

			public Vector4 vignetteColor;

			public Texture vignetteMask;

			public Texture bloomDirtTexture;

			public Vector4 bloomParams;

			public Vector4 bloomTint;

			public Vector4 bloomBicubicParams;

			public Vector4 bloomDirtTileOffset;

			public Vector4 bloomThreshold;

			public Vector4 alphaScaleBias;

			public TextureHandle source;

			public TextureHandle destination;

			public TextureHandle logLut;

			public TextureHandle bloomTexture;
		}

		private class FXAAData
		{
			public ComputeShader fxaaCS;

			public int fxaaKernel;

			public int width;

			public int height;

			public int viewCount;

			public Vector4 hdroutParameters;

			public TextureHandle source;

			public TextureHandle destination;
		}

		private class CASData
		{
			public ComputeShader casCS;

			public int initKernel;

			public int mainKernel;

			public int viewCount;

			public int inputWidth;

			public int inputHeight;

			public int outputWidth;

			public int outputHeight;

			public Vector4 hdroutParams;

			public TextureHandle source;

			public TextureHandle destination;

			public ComputeBufferHandle casParametersBuffer;
		}

		private class EASUData
		{
			public ComputeShader easuCS;

			public int mainKernel;

			public int viewCount;

			public int inputWidth;

			public int inputHeight;

			public int outputWidth;

			public int outputHeight;

			public Vector4 hdroutParams;

			public TextureHandle source;

			public TextureHandle destination;
		}

		private class FinalPassData
		{
			public bool postProcessEnabled;

			public bool performUpsampling;

			public Material finalPassMaterial;

			public HDCamera hdCamera;

			public BlueNoise blueNoise;

			public bool flipY;

			public System.Random random;

			public bool useFXAA;

			public bool enableAlpha;

			public bool keepAlpha;

			public bool dynamicResIsOn;

			public DynamicResUpscaleFilter dynamicResFilter;

			public GlobalDynamicResolutionSettings drsSettings;

			public bool filmGrainEnabled;

			public Texture filmGrainTexture;

			public float filmGrainIntensity;

			public float filmGrainResponse;

			public bool ditheringEnabled;

			public bool hdrOutputIsActive;

			public Vector4 hdroutParameters;

			public Vector4 hdroutParameters2;

			public TextureHandle inputTest;

			public TextureHandle source;

			public TextureHandle afterPostProcessTexture;

			public TextureHandle alphaTexture;

			public TextureHandle uiBuffer;

			public TextureHandle destination;

			public CubemapFace cubemapFace;

			public bool postProcessIsFinalPass;
		}

		private struct PrepassOutput
		{
			public TextureHandle depthBuffer;

			public TextureHandle depthAsColor;

			public TextureHandle normalBuffer;

			public TextureHandle motionVectorsBuffer;

			public TextureHandle renderingLayersBuffer;

			public GBufferOutput gbuffer;

			public DBufferOutput dbuffer;

			public TextureHandle depthValuesMSAA;

			public TextureHandle resolvedDepthBuffer;

			public TextureHandle resolvedNormalBuffer;

			public TextureHandle resolvedMotionVectorsBuffer;

			public TextureHandle depthPyramidTexture;

			public TextureHandle downsampledDepthBuffer;

			public TextureHandle stencilBuffer;

			public ComputeBufferHandle coarseStencilBuffer;
		}

		private class RayTracingDepthPrepassData
		{
			public FrameSettings frameSettings;

			public TextureHandle depthBuffer;

			public RendererListHandle opaqueRenderList;

			public RendererListHandle transparentRenderList;
		}

		private class DrawRendererListPassData
		{
			public FrameSettings frameSettings;

			public RendererListHandle rendererList;
		}

		private class GBufferPassData
		{
			public FrameSettings frameSettings;

			public RendererListHandle rendererList;

			public DBufferOutput dBuffer;
		}

		private struct GBufferOutput
		{
			public TextureHandle[] mrt;

			public int gBufferCount;

			public int lightLayersTextureIndex;

			public int shadowMaskTextureIndex;
		}

		private class ResolvePrepassData
		{
			public TextureHandle depthAsColorBufferMSAA;

			public TextureHandle normalBufferMSAA;

			public TextureHandle motionVectorBufferMSAA;

			public Material depthResolveMaterial;

			public int depthResolvePassIndex;

			public bool needMotionVectors;
		}

		private class CopyDepthPassData
		{
			public TextureHandle inputDepth;

			public TextureHandle outputDepth;

			public GPUCopy GPUCopy;

			public int width;

			public int height;
		}

		private class ResolveStencilPassData
		{
			public HDCamera hdCamera;

			public ComputeShader resolveStencilCS;

			public int resolveKernel;

			public bool resolveIsNecessary;

			public bool resolveOnly;

			public TextureHandle inputDepth;

			public TextureHandle resolvedStencil;

			public ComputeBufferHandle coarseStencilBuffer;
		}

		private class RenderDBufferPassData
		{
			public RendererListHandle meshDecalsRendererList;

			public RendererListHandle vfxDecalsRendererList;

			public TextureHandle depthTexture;

			public TextureHandle decalBuffer;
		}

		private struct DBufferOutput
		{
			public TextureHandle[] mrt;

			public int dBufferCount;
		}

		private class DBufferNormalPatchData
		{
			public Material decalNormalBufferMaterial;

			public int dBufferCount;

			public int stencilRef;

			public int stencilMask;

			public DBufferOutput dBuffer;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;
		}

		private class DownsampleDepthForLowResPassData
		{
			public bool useGatherDownsample;

			public float sourceWidth;

			public float sourceHeight;

			public float downsampleScale;

			public Material downsampleDepthMaterial;

			public TextureHandle depthTexture;

			public TextureHandle downsampledDepthBuffer;

			public Vector2Int mip0Offset;

			public bool computesMip1OfAtlas;
		}

		private class GenerateDepthPyramidPassData
		{
			public TextureHandle depthTexture;

			public HDUtils.PackedMipChainInfo mipInfo;

			public MipGenerator mipGenerator;

			public bool mip0AlreadyComputed;
		}

		private class CameraMotionVectorsPassData
		{
			public Material cameraMotionVectorsMaterial;

			public TextureHandle motionVectorsBuffer;

			public TextureHandle depthBuffer;
		}

		private class FinalBlitPassData
		{
			public bool flip;

			public int srcTexArraySlice;

			public int dstTexArraySlice;

			public Rect viewport;

			public Material blitMaterial;

			public Vector4 hdrOutputParmeters;

			public bool applyAfterPP;

			public CubemapFace cubemapFace;

			public TextureHandle uiTexture;

			public TextureHandle afterPostProcessTexture;

			public TextureHandle source;

			public TextureHandle destination;
		}

		private class UpdateParentExposureData
		{
			public HDCamera.ExposureTextures textures;
		}

		private class PushCameraGlobalMipBiasData
		{
			public HDCamera hdCamera;

			public float mipBias;

			public ShaderVariablesGlobal globalCB;

			public ShaderVariablesXR xrCB;
		}

		private class SetFinalTargetPassData
		{
			public bool copyDepth;

			public Material copyDepthMaterial;

			public TextureHandle finalTarget;

			public CubemapFace finalTargetFace;

			public Rect finalViewport;

			public TextureHandle depthBuffer;

			public bool flipY;
		}

		private class CopyXRDepthPassData
		{
			public Material copyDepth;

			public Rect viewport;

			public TextureHandle depthBuffer;

			public TextureHandle output;

			public float dynamicResolutionScale;
		}

		private class ForwardPassData
		{
			public RendererListHandle rendererList;

			public ComputeBufferHandle lightListTile;

			public ComputeBufferHandle lightListCluster;

			public ComputeBufferHandle perVoxelOffset;

			public ComputeBufferHandle perTileLogBaseTweak;

			public FrameSettings frameSettings;
		}

		private class ForwardOpaquePassData : ForwardPassData
		{
			public DBufferOutput dbuffer;

			public LightingBuffers lightingBuffers;

			public bool enableDecals;
		}

		private class ForwardTransparentPassData : ForwardPassData
		{
			public bool decalsEnabled;

			public bool renderMotionVecForTransparent;

			public int colorMaskTransparentVel;

			public TextureHandle transparentSSRLighting;

			public TextureHandle volumetricLighting;

			public TextureHandle depthPyramidTexture;

			public TextureHandle normalBuffer;
		}

		private class RenderOffscreenUIData
		{
			public Camera camera;

			public FrameSettings frameSettings;
		}

		private class AfterPostProcessPassData
		{
			public ShaderVariablesGlobal globalCB;

			public HDCamera hdCamera;

			public RendererListHandle opaqueAfterPostprocessRL;

			public RendererListHandle transparentAfterPostprocessRL;
		}

		private class RenderLowResTransparentPassData
		{
			public float lowResScale;

			public ShaderVariablesGlobal globalCB;

			public FrameSettings frameSettings;

			public RendererListHandle rendererList;
		}

		private class UpsampleTransparentPassData
		{
			public Vector4 shaderParams;

			public Material upsampleMaterial;

			public TextureHandle lowResTransparentBuffer;

			public TextureHandle downsampledDepthBuffer;
		}

		private class SetGlobalColorPassData
		{
			public TextureHandle colorBuffer;
		}

		private class RayTracingFlagMaskPassData
		{
			public FrameSettings frameSettings;

			public TextureHandle depthBuffer;

			public TextureHandle flagMask;

			public RendererListHandle opaqueRenderList;

			public RendererListHandle transparentRenderList;

			public bool clear;
		}

		private struct SendGeometryGraphcisBuffersParameters
		{
			public HDCamera hdCamera;

			public bool needNormalBuffer;

			public bool needDepthBuffer;

			public VFXCameraBufferTypes neededVFXBuffers;

			public HDUtils.PackedMipChainInfo packedMipChainInfo;

			public bool NeedSendBuffers()
			{
				if (!needNormalBuffer && !needDepthBuffer)
				{
					return neededVFXBuffers != VFXCameraBufferTypes.None;
				}
				return true;
			}
		}

		private class SendGeometryBuffersPassData
		{
			public SendGeometryGraphcisBuffersParameters parameters;

			public TextureHandle normalBuffer;

			public TextureHandle depthBuffer;
		}

		private class SendColorGraphicsBufferPassData
		{
			public HDCamera hdCamera;
		}

		private class ClearStencilPassData
		{
			public Material clearStencilMaterial;

			public TextureHandle colorBuffer;

			public TextureHandle depthBuffer;
		}

		private class GenerateColorPyramidData
		{
			public TextureHandle colorPyramid;

			public TextureHandle inputColor;

			public MipGenerator mipGenerator;

			public HDCamera hdCamera;
		}

		private class AccumulateDistortionPassData
		{
			public TextureHandle distortionBuffer;

			public TextureHandle depthStencilBuffer;

			public RendererListHandle distortionRendererList;

			public FrameSettings frameSettings;
		}

		private class RenderDistortionPassData
		{
			public Material applyDistortionMaterial;

			public TextureHandle sourceColorBuffer;

			public TextureHandle distortionBuffer;

			public TextureHandle colorBuffer;

			public TextureHandle depthStencilBuffer;

			public Vector4 size;

			public bool roughDistortion;
		}

		private class ResolveColorData
		{
			public TextureHandle input;

			public TextureHandle output;

			public Material resolveMaterial;

			public int passIndex;
		}

		private class ResolveMotionVectorData
		{
			public TextureHandle input;

			public TextureHandle output;

			public Material resolveMaterial;

			public int passIndex;
		}

		private class UpdatePostProcessScreenSizePassData
		{
			public int postProcessWidth;

			public int postProcessHeight;

			public HDCamera hdCamera;

			public ShaderVariablesGlobal shaderVariablesGlobal;
		}

		private class ResetCameraSizeForAfterPostProcessPassData
		{
			public HDCamera hdCamera;

			public ShaderVariablesGlobal shaderVariablesGlobal;
		}

		private class RenderScreenSpaceOverlayData
		{
			public Camera camera;
		}

		private class GenerateMipmapsPassData
		{
			public TextureHandle texture;
		}

		private class SetGlobalTexturePassData
		{
			public int shaderID;

			public Texture texture;
		}

		private class SetGlobalBufferPassData
		{
			public int shaderID;

			public ComputeBuffer buffer;
		}

		private class XRRenderingPassData
		{
			public XRPass xr;
		}

		private class RenderOcclusionMeshesPassData
		{
			public HDCamera hdCamera;

			public TextureHandle colorBuffer;

			public TextureHandle depthBuffer;

			public Color clearColor;
		}

		private class BlitCameraTextureData
		{
			public TextureHandle source;

			public TextureHandle destination;

			public float mipLevel;

			public bool bilinear;
		}

		private class SubsurfaceScaterringPassData
		{
			public ComputeShader subsurfaceScatteringCS;

			public int subsurfaceScatteringCSKernel;

			public int sampleBudget;

			public bool needTemporaryBuffer;

			public Material copyStencilForSplitLighting;

			public Material combineLighting;

			public int numTilesX;

			public int numTilesY;

			public int numTilesZ;

			public TextureHandle colorBuffer;

			public TextureHandle diffuseBuffer;

			public TextureHandle depthStencilBuffer;

			public TextureHandle depthTexture;

			public TextureHandle cameraFilteringBuffer;

			public TextureHandle sssBuffer;

			public ComputeBufferHandle coarseStencilBuffer;
		}

		private class RenderPathTracingData
		{
			public RayTracingShader shader;

			public CameraData cameraData;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public ShaderVariablesRaytracing shaderVariablesRaytracingCB;

			public Color backgroundColor;

			public Matrix4x4 pixelCoordToViewDirWS;

			public Vector4 dofParameters;

			public Vector4 tilingParameters;

			public int width;

			public int height;

			public int skySize;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public Texture skyReflection;

			public TextureHandle skyBG;

			public TextureHandle skyCDF;

			public TextureHandle skyMarginal;

			public TextureHandle output;

			public bool enableAOVs;

			public TextureHandle albedoAOV;

			public TextureHandle normalAOV;

			public TextureHandle motionVectorAOV;
		}

		private class RenderSkySamplingPassData
		{
			public ComputeShader shader;

			public int k0;

			public int k1;

			public int size;

			public TextureHandle outputCDF;

			public TextureHandle outputMarginal;
		}

		private class RTASDebugPassData
		{
			public int actualWidth;

			public int actualHeight;

			public int viewCount;

			public int debugMode;

			public uint layerMask;

			public Matrix4x4 pixelCoordToViewDirWS;

			public RayTracingShader debugRTASRT;

			public RayTracingAccelerationStructure rayTracingAccelerationStructure;

			public TextureHandle outputTexture;
		}

		private struct TraceAmbientOcclusionResult
		{
			public TextureHandle signalBuffer;

			public TextureHandle velocityBuffer;
		}

		private class TraceRTAOPassData
		{
			public int actualWidth;

			public int actualHeight;

			public int viewCount;

			public float rayLength;

			public int sampleCount;

			public bool denoise;

			public bool occluderMotionRejection;

			public bool receiverMotionRejection;

			public RayTracingShader aoShaderRT;

			public ShaderVariablesRaytracing raytracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public RayTracingAccelerationStructure rayTracingAccelerationStructure;

			public TextureHandle depthBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle rayCountTexture;

			public TextureHandle outputTexture;

			public TextureHandle velocityBuffer;
		}

		private class ComposeRTAOPassData
		{
			public float intensity;

			public int actualWidth;

			public int actualHeight;

			public int viewCount;

			public int intensityKernel;

			public ComputeShader aoShaderCS;

			public TextureHandle outputTexture;
		}

		private class ClearRTAOHistoryData
		{
			public TextureHandle aoTexture;
		}

		private struct DeferredLightingRTParameters
		{
			public bool rayBinning;

			public LayerMask layerMask;

			public bool diffuseLightingOnly;

			public bool halfResolution;

			public int rayCountType;

			public float lodBias;

			public int rayMiss;

			public int lastBounceFallbackHierarchy;

			public bool mixedTracing;

			public int raySteps;

			public float nearClipPlane;

			public float farClipPlane;

			public int width;

			public int height;

			public int viewCount;

			public ComputeBuffer rayBinResult;

			public ComputeBuffer rayBinSizeResult;

			public ComputeBuffer mipChainBuffer;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public ComputeShader rayMarchingCS;

			public RayTracingShader gBufferRaytracingRT;

			public ComputeShader deferredRaytracingCS;

			public ComputeShader rayBinningCS;

			public ShaderVariablesRaytracing raytracingCB;
		}

		private class DeferredLightingRTRPassData
		{
			public DeferredLightingRTParameters parameters;

			public TextureHandle depthPyramid;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle ssgbuffer0;

			public TextureHandle ssgbuffer1;

			public TextureHandle ssgbuffer2;

			public TextureHandle ssgbuffer3;

			public TextureHandle directionBuffer;

			public TextureHandle gbuffer0;

			public TextureHandle gbuffer1;

			public TextureHandle gbuffer2;

			public TextureHandle gbuffer3;

			public TextureHandle distanceBuffer;

			public TextureHandle litBuffer;

			public TextureHandle rayCountTexture;

			public Texture skyTexture;
		}

		private class DirGenRTGIPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public bool fullResolution;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public int dirGenKernel;

			public ComputeShader directionGenCS;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle outputBuffer;
		}

		private class UpscaleRTGIPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public Texture2DArray blueNoiseTexture;

			public Texture2D scramblingTexture;

			public int upscaleKernel;

			public ComputeShader upscaleCS;

			public TextureHandle depthBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle indirectDiffuseBuffer;

			public TextureHandle directionBuffer;

			public TextureHandle outputBuffer;
		}

		private class TraceQualityRTGIPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public float rayLength;

			public int sampleCount;

			public float clampValue;

			public int bounceCount;

			public int lodBias;

			public int rayMiss;

			public int lastBounceFallbackHierarchy;

			public float ambientProbeDimmer;

			public RayTracingShader indirectDiffuseRT;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public Texture skyTexture;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle rayCountTexture;

			public TextureHandle outputBuffer;
		}

		private class RecursiveRenderingPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public float rayLength;

			public int maxDepth;

			public float minSmoothness;

			public int rayMissFallbackHiearchy;

			public int lastBounceFallbackHiearchy;

			public float ambientProbeDimmer;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public RayTracingShader recursiveRenderingRT;

			public Texture skyTexture;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle flagMask;

			public TextureHandle debugBuffer;

			public TextureHandle rayCountTexture;

			public TextureHandle outputBuffer;
		}

		private class DirGenRTRPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public float minSmoothness;

			public ComputeShader directionGenCS;

			public int dirGenKernel;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public TextureHandle depthBuffer;

			public TextureHandle stencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle clearCoatMaskTexture;

			public TextureHandle outputBuffer;
		}

		private class AdjustWeightRTRPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public float minSmoothness;

			public float smoothnessFadeStart;

			public ComputeShader reflectionFilterCS;

			public int adjustWeightKernel;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle clearCoatMaskTexture;

			public TextureHandle lightingTexture;

			public TextureHandle directionTexture;

			public TextureHandle outputTexture;
		}

		private class UpscaleRTRPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public ComputeShader reflectionFilterCS;

			public int upscaleKernel;

			public TextureHandle depthStencilBuffer;

			public TextureHandle lightingTexture;

			public TextureHandle outputTexture;
		}

		private class TraceQualityRTRPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public float clampValue;

			public int reflectSky;

			public float rayLength;

			public int sampleCount;

			public int bounceCount;

			public bool transparent;

			public float minSmoothness;

			public float smoothnessFadeStart;

			public float lodBias;

			public int rayMissfallbackHierarchy;

			public int lastBouncefallbackHierarchy;

			public float ambientProbeDimmer;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public Texture skyTexture;

			public RayTracingShader reflectionShader;

			public TextureHandle depthBuffer;

			public TextureHandle stencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle clearCoatMaskTexture;

			public TextureHandle rayCountTexture;

			public TextureHandle outputTexture;
		}

		private class TraceRTSSSPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public int sampleCount;

			public int clearTextureKernel;

			public int rtDeferredLightingKernel;

			public RayTracingShader rayTracingSubSurfaceRT;

			public ComputeShader rayTracingSubSurfaceCS;

			public ComputeShader deferredRayTracingCS;

			public RayTracingAccelerationStructure accelerationStructure;

			public HDRaytracingLightCluster lightCluster;

			public ShaderVariablesRaytracing shaderVariablesRayTracingCB;

			public BlueNoise.DitheredTextureSet ditheredTextureSet;

			public TextureHandle depthStencilBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle sssColor;

			public TextureHandle intermediateBuffer0;

			public TextureHandle intermediateBuffer1;

			public TextureHandle intermediateBuffer2;

			public TextureHandle intermediateBuffer3;

			public TextureHandle directionBuffer;

			public TextureHandle outputBuffer;
		}

		private class ComposeRTSSSPassData
		{
			public int texWidth;

			public int texHeight;

			public int viewCount;

			public bool validSSGI;

			public int combineSSSKernel;

			public ComputeShader rayTracingSubSurfaceCS;

			public Material combineLightingMat;

			public TextureHandle depthStencilBuffer;

			public TextureHandle sssColor;

			public TextureHandle ssgiBuffer;

			public TextureHandle diffuseLightingBuffer;

			public TextureHandle subsurfaceBuffer;

			public TextureHandle colorBuffer;
		}

		private struct WaterRenderingParameters
		{
			public Vector3 cameraPosition;

			public Frustum cameraFrustum;

			public float cameraFarPlane;

			public uint numLODs;

			public int numActiveBands;

			public Vector3 center;

			public Vector2 extent;

			public float rotation;

			public Vector2 foamMaskOffset;

			public Vector2 waterMaskOffset;

			public bool infinite;

			public bool customMesh;

			public Mesh targetMesh;

			public bool evaluateCameraPosition;

			public bool simulationCaustics;

			public ComputeShader waterSimulation;

			public int patchEvaluation;

			public Texture2D waterMask;

			public Texture2D foamMask;

			public Texture2D surfaceFoam;

			public Material waterMaterial;

			public MaterialPropertyBlock mbp;

			public ShaderVariablesWater waterCB;

			public ShaderVariablesWaterRendering waterRenderingCB;

			public ComputeShader simulationCS;

			public int findVerticalDisplKernel;
		}

		private struct WaterRenderingDeferredParameters
		{
			public int width;

			public int height;

			public int viewCount;

			public bool pbsActive;

			public ComputeShader waterLighting;

			public int waterLightingKernel;
		}

		private class WaterRenderingGBufferData
		{
			public WaterRenderingParameters parameters;

			public TextureHandle displacementTexture;

			public TextureHandle additionalData;

			public TextureHandle causticsData;

			public ComputeBufferHandle indirectBuffer;

			public ComputeBufferHandle patchDataBuffer;

			public ComputeBufferHandle frustumBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle depthPyramid;

			public TextureHandle colorPyramid;

			public ComputeBufferHandle layeredOffsetsBuffer;

			public ComputeBufferHandle logBaseBuffer;

			public bool decalsEnabled;

			public ComputeBufferHandle heightBuffer;
		}

		private class WaterRenderingSSRData
		{
			public int width;

			public int height;

			public int viewCount;

			public ComputeShader waterLighting;

			public int prepareSSRKernel;

			public TextureHandle depthBuffer;

			public TextureHandle gbuffer1;

			public TextureHandle gbuffer3;

			public ComputeBufferHandle heightBuffer;

			public ComputeBufferHandle waterSurfaceProfiles;

			public TextureHandle normalBuffer;
		}

		private struct WaterGBuffer
		{
			public bool valid;

			public TextureHandle waterGBuffer0;

			public TextureHandle waterGBuffer1;

			public TextureHandle waterGBuffer2;

			public TextureHandle waterGBuffer3;
		}

		private class WaterRenderingDeferredData
		{
			public WaterRenderingDeferredParameters parameters;

			public TextureHandle gbuffer0;

			public TextureHandle gbuffer1;

			public TextureHandle gbuffer2;

			public TextureHandle gbuffer3;

			public TextureHandle depthBuffer;

			public TextureHandle depthPyramid;

			public ComputeBufferHandle waterSurfaceProfiles;

			public TextureHandle scatteringFallbackTexture;

			public TextureHandle volumetricLightingTexture;

			public ComputeBufferHandle heightBuffer;

			public TextureHandle transparentSSRLighting;

			public ComputeBufferHandle perVoxelOffset;

			public ComputeBufferHandle perTileLogBaseTweak;

			public TextureHandle colorBuffer;
		}

		internal struct WaterSimulationTapData
		{
			public float3 currentDisplacement;

			public float3 displacedPoint;

			public float2 offset;

			public float distance;

			public float height;
		}

		private class UnderWaterRenderingData
		{
			public int width;

			public int height;

			public int viewCount;

			public ComputeShader simulationCS;

			public int findVerticalDisplKernel;

			public ComputeShader waterLightingCS;

			public int underWaterKernel;

			public ShaderVariablesWaterRendering waterRenderingCB;

			public ShaderVariablesUnderWater underWaterCB;

			public ShaderVariablesWater waterCB;

			public TextureHandle colorBuffer;

			public TextureHandle normalBuffer;

			public TextureHandle depthBuffer;

			public TextureHandle causticsData;

			public ComputeBufferHandle cameraHeightBuffer;

			public TextureHandle outputColorBuffer;
		}

		private Vector4[] m_PackedCoeffsProbe = new Vector4[7];

		internal const int k_MaxCacheSize = 2000000000;

		internal const int k_MaxDirectionalLightsOnScreen = 512;

		internal const int k_MaxPunctualLightsOnScreen = 2048;

		internal const int k_MaxAreaLightsOnScreen = 1024;

		internal const int k_MaxDecalsOnScreen = 2048;

		internal const int k_MaxPlanarReflectionsOnScreen = 16;

		internal const int k_MaxCubeReflectionsOnScreen = 64;

		internal const int k_MaxLightsPerClusterCell = 24;

		internal static readonly Vector3 k_BoxCullingExtentThreshold = Vector3.one * 0.01f;

		private static bool k_PreferFragment = false;

		private const bool k_HasNativeQuadSupport = false;

		private const int k_ThreadGroupOptimalSize = 64;

		private int m_MaxDirectionalLightsOnScreen;

		private int m_MaxPunctualLightsOnScreen;

		private int m_MaxAreaLightsOnScreen;

		private int m_MaxDecalsOnScreen;

		private int m_MaxLightsOnScreen;

		private int m_MaxPlanarReflectionsOnScreen;

		private int m_MaxCubeReflectionsOnScreen;

		private int m_MaxEnvLightsOnScreen;

		internal LightLoopTextureCaches m_TextureCaches = new LightLoopTextureCaches();

		internal LightLoopLightData m_LightLoopLightData = new LightLoopLightData();

		private TileAndClusterData m_TileAndClusterData = new TileAndClusterData();

		private EnvLightReflectionData m_EnvLightReflectionData;

		internal static readonly bool s_UseCascadeBorders = true;

		private uint[] m_SortKeys;

		private DynamicArray<ProcessedProbeData> m_ProcessedReflectionProbeData = new DynamicArray<ProcessedProbeData>();

		private DynamicArray<ProcessedProbeData> m_ProcessedPlanarProbeData = new DynamicArray<ProcessedProbeData>();

		private static readonly Matrix4x4 s_FlipMatrixLHSRHS = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

		private Matrix4x4[] m_LightListProjMatrices = new Matrix4x4[ShaderConfig.s_XrMaxViews];

		internal LightList m_lightList;

		internal HDProcessedVisibleLightsBuilder m_ProcessedLightsBuilder;

		internal HDGpuLightsBuilder m_GpuLightsBuilder;

		private int m_TotalLightCount;

		private bool m_EnableBakeShadowMask;

		private ShaderVariablesLightList m_ShaderVariablesLightListCB;

		private static string[,] s_ClusterKernelNames = new string[2, 3]
		{
			{ "TileLightListGen_NoDepthRT", "TileLightListGen_DepthRT", "TileLightListGen_DepthRT_MSAA" },
			{ "TileLightListGen_NoDepthRT_SrcBigTile", "TileLightListGen_DepthRT_SrcBigTile", "TileLightListGen_DepthRT_MSAA_SrcBigTile" }
		};

		private static string[,] s_ClusterObliqueKernelNames = new string[2, 3]
		{
			{ "TileLightListGen_NoDepthRT", "TileLightListGen_DepthRT_Oblique", "TileLightListGen_DepthRT_MSAA_Oblique" },
			{ "TileLightListGen_NoDepthRT_SrcBigTile", "TileLightListGen_DepthRT_SrcBigTile_Oblique", "TileLightListGen_DepthRT_MSAA_SrcBigTile_Oblique" }
		};

		private static int s_GenListPerTileKernel;

		private static int[,] s_ClusterKernels = new int[2, 3];

		private static int[,] s_ClusterObliqueKernels = new int[2, 3];

		private static int s_ClearVoxelAtomicKernel;

		private static int s_ClearDispatchIndirectKernel;

		private static int s_BuildIndirectKernel;

		private static int s_ClearDrawProceduralIndirectKernel;

		private static int s_BuildMaterialFlagsWriteKernel;

		private static int s_BuildMaterialFlagsOrKernel;

		private static int s_shadeOpaqueDirectFptlKernel;

		private static int s_shadeOpaqueDirectFptlDebugDisplayKernel;

		private static int s_shadeOpaqueDirectShadowMaskFptlKernel;

		private static int s_shadeOpaqueDirectShadowMaskFptlDebugDisplayKernel;

		private static int[] s_shadeOpaqueIndirectFptlKernels = new int[LightDefinitions.s_NumFeatureVariants];

		private static int s_deferredContactShadowKernel;

		private static int s_GenListPerBigTileKernel;

		private const bool k_UseDepthBuffer = true;

		private const int k_Log2NumClusters = 6;

		private const float k_ClustLogBase = 1.02f;

		private float m_ClusterScale;

		private static DebugLightVolumes s_lightVolumes = null;

		private static Material s_DeferredTileRegularLightingMat;

		private static Material s_DeferredTileSplitLightingMat;

		private static Material s_DeferredTileMat;

		private static string[] s_variantNames = new string[LightDefinitions.s_NumFeatureVariants];

		private ContactShadows m_ContactShadows;

		private bool m_EnableContactShadow;

		private IndirectLightingController m_indirectLightingController;

		private Material[] m_deferredLightingMaterial;

		private HashSet<HDAdditionalLightData> m_ScreenSpaceShadowsUnion = new HashSet<HDAdditionalLightData>();

		private Light m_CurrentSunLight;

		private int m_CurrentSunLightDataIndex = -1;

		private int m_CurrentShadowSortedSunLightIndex = -1;

		private HDAdditionalLightData m_CurrentSunLightAdditionalLightData;

		private HDProcessedVisibleLightsBuilder.ShadowMapFlags m_CurrentSunShadowMapFlags;

		private DirectionalLightData m_CurrentSunLightDirectionalLightData;

		private int m_ScreenSpaceShadowIndex;

		private int m_ScreenSpaceShadowChannelSlot;

		private ScreenSpaceShadowData[] m_CurrentScreenSpaceShadowData;

		private int m_ContactShadowIndex;

		private HDShadowManager m_ShadowManager;

		private HDShadowInitParameters m_ShadowInitParameters;

		private int m_DebugSelectedLightShadowIndex;

		private int m_DebugSelectedLightShadowCount;

		private List<Matrix4x4> m_WorldToViewMatrices = new List<Matrix4x4>(ShaderConfig.s_XrMaxViews);

		private ComputeBuffer m_EmptyIndexBuffer;

		private bool m_AOHistoryReady;

		private int m_TraceGlobalIlluminationKernel;

		private int m_TraceGlobalIlluminationHalfKernel;

		private int m_ReprojectGlobalIlluminationKernel;

		private int m_ReprojectGlobalIlluminationHalfKernel;

		private int m_BilateralUpSampleColorKernel;

		private const string m_RayGenAreaShadowSingleName = "RayGenAreaShadowSingle";

		private const string m_RayGenDirectionalShadowSingleName = "RayGenDirectionalShadowSingle";

		private const string m_RayGenDirectionalColorShadowSingleName = "RayGenDirectionalColorShadowSingle";

		private const string m_RayGenShadowSegmentSingleName = "RayGenShadowSegmentSingle";

		private const string m_RayGenSemiTransparentShadowSegmentSingleName = "RayGenSemiTransparentShadowSegmentSingle";

		private RayTracingShader m_ScreenSpaceShadowsRT;

		private ComputeShader m_ScreenSpaceShadowsCS;

		private ComputeShader m_ScreenSpaceShadowsFilterCS;

		private int m_ClearShadowTexture;

		private int m_OutputShadowTextureKernel;

		private int m_OutputColorShadowTextureKernel;

		private int m_OutputSpecularShadowTextureKernel;

		private int m_RaytracingDirectionalShadowSample;

		private int m_RaytracingPointShadowSample;

		private int m_RaytracingSpotShadowSample;

		private int m_AreaRaytracingShadowPrepassKernel;

		private int m_AreaRaytracingShadowNewSampleKernel;

		private int m_AreaShadowApplyTAAKernel;

		private int m_AreaUpdateAnalyticHistoryKernel;

		private int m_AreaUpdateShadowHistoryKernel;

		private int m_AreaEstimateNoiseKernel;

		private int m_AreaFirstDenoiseKernel;

		private int m_AreaSecondDenoiseKernel;

		private int m_AreaShadowNoDenoiseKernel;

		private int m_WriteShadowTextureDebugKernel;

		private Vector4 m_ShadowChannelMask0 = new Vector4(1f, 1f, 1f, 1f);

		private Vector4 m_ShadowChannelMask1 = new Vector4(1f, 1f, 1f, 1f);

		private Vector4 m_ShadowChannelMask2 = new Vector4(1f, 1f, 1f, 1f);

		private static Material s_ScreenSpaceShadowsMat;

		private ZonalHarmonicsL2 m_PhaseZHClouds;

		private Texture2D m_CustomPresetMap;

		private Texture2D m_CustomLutPresetMap;

		private const int k_CustomLutMapResolution = 32;

		private readonly Color[] m_CustomLutColorArray = new Color[32];

		private int m_ConvertObliqueDepthKernel;

		private int m_CloudDownscaleDepthKernel;

		private int m_CloudRenderKernel;

		private int m_ReprojectCloudsKernel;

		private int m_ReprojectCloudsRejectionKernel;

		private int m_PreUpscaleCloudsKernel;

		private int m_PreUpscaleCloudsSkyKernel;

		private int m_UpscaleAndCombineCloudsKernelColorCopy;

		private int m_UpscaleAndCombineCloudsKernelColorRW;

		private int m_UpscaleAndCombineCloudsSkyKernel;

		private int m_CombineCloudsKernelColorCopy;

		private int m_CombineCloudsKernelColorRW;

		private int m_CombineCloudsSkyKernel;

		private bool m_ActiveVolumetricClouds;

		private Material m_CloudCombinePass;

		internal VolumetricCloudsAnimationData volumetricCloudsAnimationData;

		private const float k_EarthRadius = 6378100f;

		private const float m_VolumetricCloudsAnisotropy = 0.7f;

		internal ComputeBuffer m_CloudsDynamicProbeBuffer;

		internal ComputeBuffer m_CloudsStaticProbeBuffer;

		private RTHandle m_AdvancedCloudMap;

		private int m_CloudMapHash;

		private int m_EvaluateCloudMapKernel;

		private RTHandle[] m_VolumetricCloudsShadowTexture = new RTHandle[5];

		private RTHandle m_VolumetricCloudsIntermediateShadowTexture;

		private int m_ComputeShadowCloudsKernel;

		private int m_FilterShadowCloudsKernel;

		private ComputeShader m_VolumeVoxelizationCS;

		private ComputeShader m_VolumetricLightingCS;

		private ComputeShader m_VolumetricLightingFilteringCS;

		private List<OrientedBBox> m_VisibleVolumeBounds;

		private List<LocalVolumetricFogEngineData> m_VisibleVolumeData;

		private List<LocalVolumetricFog> m_VisibleLocalVolumetricFogVolumes;

		private NativeArray<uint> m_VolumetricFogSortKeys;

		private NativeArray<uint> m_VolumetricFogSortKeysTemp;

		internal const int k_MaxVisibleLocalVolumetricFogCount = 1024;

		private const int k_VolumetricMaterialIndirectArgumentCount = 5;

		private const int k_VolumetricMaterialIndirectArgumentByteSize = 20;

		private const int k_VolumetricFogPriorityMaxValue = 1048576;

		private ComputeBuffer m_VisibleVolumeBoundsBuffer;

		private GraphicsBuffer m_VolumetricMaterialDataBuffer;

		private GraphicsBuffer m_VolumetricMaterialIndexBuffer;

		private Material m_DefaultVolumetricFogMaterial;

		private ShaderVariablesVolumetric m_ShaderVariablesVolumetricCB;

		private static Vector3Int s_CurrentVolumetricBufferSize;

		private bool m_SupportVolumetrics;

		private Vector4[] m_PackedCoeffs;

		private ZonalHarmonicsL2 m_PhaseZH;

		private Vector2[] m_xySeq;

		private float[] m_zSeq = new float[7]
		{
			0.5f,
			3f / 14f,
			11f / 14f,
			5f / 14f,
			9f / 14f,
			1f / 14f,
			13f / 14f
		};

		private Matrix4x4[] m_PixelCoordToViewDirWS;

		private static readonly string[] volumetricHistoryBufferNames = new string[2] { "VBufferHistory0", "VBufferHistory1" };

		private SubFrameManager m_SubFrameManager = new SubFrameManager();

		private HDRenderPipelineGlobalSettings m_GlobalSettings;

		public const string k_ShaderTagName = "HDRenderPipeline";

		private readonly HDRenderPipelineAsset m_Asset;

		private readonly List<RenderPipelineMaterial> m_MaterialList = new List<RenderPipelineMaterial>();

		private bool m_PreviousLightsUseLinearIntensity;

		private bool m_PreviousLightsUseColorTemperature;

		private bool m_PreviousSRPBatcher;

		private uint m_PreviousDefaultRenderingLayerMask;

		private ShadowmaskMode m_PreviousShadowMaskMode;

		private bool m_FrameSettingsHistoryEnabled;

		private PerObjectData m_CurrentRendererConfigurationBakedLighting;

		private MaterialPropertyBlock m_CopyDepthPropertyBlock = new MaterialPropertyBlock();

		private Material m_CopyDepth;

		private Material m_UpsampleTransparency;

		private MipGenerator m_MipGenerator;

		private BlueNoise m_BlueNoise;

		private IBLFilterBSDF[] m_IBLFilterArray;

		private int m_SsrTracingKernel = -1;

		private int m_SsrReprojectionKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionBothKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionSurfaceKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionHitKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionBothKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionSurfaceKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionHitKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionBothKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionSurfaceKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionHitKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionBothDebugKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionSurfaceDebugKernel = -1;

		private int m_SsrAccumulateNoWorldSpeedRejectionHitDebugKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionBothDebugKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionSurfaceDebugKernel = -1;

		private int m_SsrAccumulateHardThresholdSpeedRejectionHitDebugKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionBothDebugKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionSurfaceDebugKernel = -1;

		private int m_SsrAccumulateSmoothSpeedRejectionHitDebugKernel = -1;

		private int m_ClearBuffer2DKernel = -1;

		private Material m_ApplyDistortionMaterial;

		private Material m_FinalBlitWithOETF;

		private Material m_ClearStencilBufferMaterial;

		private Material m_ErrorMaterial;

		private Lazy<RTHandle> m_CustomPassColorBuffer;

		private Lazy<RTHandle> m_CustomPassDepthBuffer;

		private ShaderVariablesGlobal m_ShaderVariablesGlobalCB;

		private ShaderVariablesXR m_ShaderVariablesXRCB;

		private ShaderVariablesRaytracing m_ShaderVariablesRayTracingCB;

		private ShaderTagId[] m_ForwardAndForwardOnlyPassNames = new ShaderTagId[4]
		{
			HDShaderPassNames.s_ForwardOnlyName,
			HDShaderPassNames.s_ForwardName,
			HDShaderPassNames.s_SRPDefaultUnlitName,
			HDShaderPassNames.s_DecalMeshForwardEmissiveName
		};

		private ShaderTagId[] m_ForwardOnlyPassNames = new ShaderTagId[3]
		{
			HDShaderPassNames.s_ForwardOnlyName,
			HDShaderPassNames.s_SRPDefaultUnlitName,
			HDShaderPassNames.s_DecalMeshForwardEmissiveName
		};

		private ShaderTagId[] m_AllTransparentPassNames = new ShaderTagId[4]
		{
			HDShaderPassNames.s_TransparentBackfaceName,
			HDShaderPassNames.s_ForwardOnlyName,
			HDShaderPassNames.s_ForwardName,
			HDShaderPassNames.s_SRPDefaultUnlitName
		};

		private ShaderTagId[] m_TransparentNoBackfaceNames = new ShaderTagId[3]
		{
			HDShaderPassNames.s_ForwardOnlyName,
			HDShaderPassNames.s_ForwardName,
			HDShaderPassNames.s_SRPDefaultUnlitName
		};

		private ShaderTagId[] m_AllForwardOpaquePassNames = new ShaderTagId[3]
		{
			HDShaderPassNames.s_ForwardOnlyName,
			HDShaderPassNames.s_ForwardName,
			HDShaderPassNames.s_SRPDefaultUnlitName
		};

		private ShaderTagId[] m_DepthOnlyAndDepthForwardOnlyPassNames = new ShaderTagId[2]
		{
			HDShaderPassNames.s_DepthForwardOnlyName,
			HDShaderPassNames.s_DepthOnlyName
		};

		private ShaderTagId[] m_DepthForwardOnlyPassNames = new ShaderTagId[1] { HDShaderPassNames.s_DepthForwardOnlyName };

		private ShaderTagId[] m_DepthOnlyPassNames = new ShaderTagId[1] { HDShaderPassNames.s_DepthOnlyName };

		private ShaderTagId[] m_TransparentDepthPrepassNames = new ShaderTagId[1] { HDShaderPassNames.s_TransparentDepthPrepassName };

		private ShaderTagId[] m_TransparentDepthPostpassNames = new ShaderTagId[1] { HDShaderPassNames.s_TransparentDepthPostpassName };

		private ShaderTagId[] m_RayTracingPrepassNames = new ShaderTagId[1] { HDShaderPassNames.s_RayTracingPrepassName };

		private ShaderTagId[] m_FullScreenDebugPassNames = new ShaderTagId[1] { HDShaderPassNames.s_FullScreenDebugName };

		private ShaderTagId[] m_ForwardErrorPassNames = new ShaderTagId[7]
		{
			HDShaderPassNames.s_AlwaysName,
			HDShaderPassNames.s_ForwardBaseName,
			HDShaderPassNames.s_DeferredName,
			HDShaderPassNames.s_PrepassBaseName,
			HDShaderPassNames.s_VertexName,
			HDShaderPassNames.s_VertexLMRGBMName,
			HDShaderPassNames.s_VertexLMName
		};

		private ShaderTagId[] m_SinglePassName = new ShaderTagId[1];

		private ShaderTagId[] m_MeshDecalsPassNames = new ShaderTagId[1] { HDShaderPassNames.s_DBufferMeshName };

		private ShaderTagId[] m_VfxDecalsPassNames = new ShaderTagId[1] { HDShaderPassNames.s_DBufferVFXDecalName };

		private RenderStateBlock m_DepthStateOpaque;

		private RenderStateBlock m_DepthStateNoWrite;

		private RenderStateBlock m_AlphaToMaskBlock;

		private readonly List<CustomPassVolume> m_ActivePassVolumes = new List<CustomPassVolume>(6);

		private readonly List<Terrain> m_ActiveTerrains = new List<Terrain>();

		private int m_MaxCameraWidth;

		private int m_MaxCameraHeight;

		private int m_MaxViewCount = 1;

		private int m_FrameCount;

		private readonly SkyManager m_SkyManager = new SkyManager();

		private bool m_ValidAPI;

		private bool m_IsDepthBufferCopyValid;

		private ProbeCameraCache<(Transform viewer, HDProbe probe, CubemapFace face)> m_ProbeCameraCache = new ProbeCameraCache<(Transform, HDProbe, CubemapFace)>();

		private ComputeBuffer m_DepthPyramidMipLevelOffsetsBuffer;

		private ScriptableCullingParameters frozenCullingParams;

		private bool frozenCullingParamAvailable;

		private ObjectPool<HDCullingResults> m_CullingResultsPool = new ObjectPool<HDCullingResults>(delegate(HDCullingResults cullResult)
		{
			cullResult.Reset();
		}, null, collectionCheck: false);

		private RenderGraph m_RenderGraph = new RenderGraph("HDRP");

		private Material m_ColorResolveMaterial;

		private Material m_MotionVectorResolve;

		private bool m_AssetSupportsRayTracing;

		private bool m_RayTracingSupported;

		private static List<(int index, float weight)> s_TempGenerateProbeRenderRequestsList = new List<(int, float)>();

		private bool m_FullScreenDebugPushed;

		private DebugOverlay m_DebugOverlay = new DebugOverlay();

		private TextureHandle m_DebugFullScreenTexture;

		private ComputeBufferHandle m_DebugFullScreenComputeBuffer;

		private ShaderVariablesDebugDisplay m_ShaderVariablesDebugDisplayCB;

		private ComputeShader m_ClearFullScreenBufferCS;

		private int m_ClearFullScreenBufferKernel;

		private Material m_DebugViewMaterialGBuffer;

		private Material m_DebugViewMaterialGBufferShadowMask;

		private Material m_currentDebugViewMaterialGBuffer;

		private Material m_DebugDisplayLatlong;

		private Material m_DebugFullScreen;

		private Material m_DebugColorPicker;

		private Material m_DebugExposure;

		private Material m_DebugHDROutput;

		private Material m_DebugViewTilesMaterial;

		private Material m_DebugHDShadowMapMaterial;

		private Material m_DebugLocalVolumetricFogMaterial;

		private Material m_DebugBlitMaterial;

		private Material m_DebugVectorscope;

		private Material m_DebugWaveform;

		private readonly DebugDisplaySettingsUI m_DebugDisplaySettingsUI = new DebugDisplaySettingsUI();

		private DebugDisplaySettings m_DebugDisplaySettings = new DebugDisplaySettings();

		private static DebugDisplaySettings s_NeutralDebugDisplaySettings = new DebugDisplaySettings();

		internal DebugDisplaySettings m_CurrentDebugDisplaySettings;

		private GraphicsFormat m_PostProcessColorFormat = GraphicsFormat.B10G11R11_UFloatPack32;

		private const GraphicsFormat k_CoCFormat = GraphicsFormat.R16_SFloat;

		internal const GraphicsFormat k_ExposureFormat = GraphicsFormat.R32G32_SFloat;

		private Material m_FinalPassMaterial;

		private Material m_ClearBlackMaterial;

		private Material m_SMAAMaterial;

		private Material m_TemporalAAMaterial;

		private Material m_LensFlareDataDrivenShader;

		private const int k_ExposureCurvePrecision = 128;

		private const int k_HistogramBins = 128;

		private const int k_DebugImageHistogramBins = 256;

		private const int k_SizeOfHDRXYMapping = 512;

		private readonly Color[] m_ExposureCurveColorArray = new Color[128];

		private readonly int[] m_ExposureVariants = new int[4];

		private Texture2D m_ExposureCurveTexture;

		private RTHandle m_EmptyExposureTexture;

		private RTHandle m_DebugExposureData;

		private ComputeBuffer m_HistogramBuffer;

		private ComputeBuffer m_DebugImageHistogramBuffer;

		private readonly int[] m_EmptyHistogram = new int[128];

		private readonly int[] m_EmptyDebugImageHistogram = new int[1024];

		private ComputeBuffer m_BokehNearKernel;

		private ComputeBuffer m_BokehFarKernel;

		private ComputeBuffer m_BokehIndirectCmd;

		private ComputeBuffer m_NearBokehTileList;

		private ComputeBuffer m_FarBokehTileList;

		private ComputeBuffer m_ContrastAdaptiveSharpen;

		private const int k_MaxBloomMipCount = 16;

		private Vector4 m_BloomBicubicParams;

		private Texture2D m_InternalSpectralLut;

		private int m_LutSize;

		private GraphicsFormat m_LutFormat;

		private HableCurve m_HableCurve;

		private RTHandle m_GradingAndTonemappingLUT;

		private int m_LutHash = -1;

		private Vector2Int m_AfterDynamicResUpscaleRes = new Vector2Int(1, 1);

		private Vector2Int m_BeforeDynamicResUpscaleRes = new Vector2Int(1, 1);

		internal const float TAABaseBlendFactorMin = 0.6f;

		internal const float TAABaseBlendFactorMax = 0.95f;

		private float[] taaSampleWeights = new float[9];

		private Exposure m_Exposure;

		private DepthOfField m_DepthOfField;

		private MotionBlur m_MotionBlur;

		private PaniniProjection m_PaniniProjection;

		private Bloom m_Bloom;

		private ChromaticAberration m_ChromaticAberration;

		private LensDistortion m_LensDistortion;

		private Vignette m_Vignette;

		private Tonemapping m_Tonemapping;

		private WhiteBalance m_WhiteBalance;

		internal ColorAdjustments m_ColorAdjustments;

		private ChannelMixer m_ChannelMixer;

		private SplitToning m_SplitToning;

		private LiftGammaGain m_LiftGammaGain;

		private ShadowsMidtonesHighlights m_ShadowsMidtonesHighlights;

		private ColorCurves m_Curves;

		private FilmGrain m_FilmGrain;

		private bool m_StopNaNFS;

		private bool m_DepthOfFieldFS;

		private bool m_MotionBlurFS;

		private bool m_PaniniProjectionFS;

		private bool m_BloomFS;

		private bool m_LensFlareDataDataDrivenFS;

		private bool m_ChromaticAberrationFS;

		private bool m_LensDistortionFS;

		private bool m_VignetteFS;

		private bool m_ColorGradingFS;

		private bool m_TonemappingFS;

		private bool m_FilmGrainFS;

		private bool m_DitheringFS;

		private bool m_AntialiasingFS;

		private bool m_ScreenCoordOverride;

		private float m_DebugExposureCompensation;

		private bool m_EnableAlpha;

		private bool m_KeepAlpha;

		private bool m_UseSafePath;

		private bool m_PostProcessEnabled;

		private bool m_AnimatedMaterialsEnabled;

		private bool m_MotionBlurSupportsScattering;

		private bool m_NonRenderGraphResourcesAvailable;

		private CameraType m_CurrCameraType;

		private const int k_RTGuardBandSize = 4;

		private System.Random m_Random;

		private bool m_DLSSPassEnabled;

		private Material m_DLSSBiasColorMaskMaterial;

		private DLSSPass m_DLSSPass;

		private static readonly Vector2Int[] TAASampleOffsets = new Vector2Int[9]
		{
			new Vector2Int(0, 0),
			new Vector2Int(0, 1),
			new Vector2Int(1, 0),
			new Vector2Int(-1, 0),
			new Vector2Int(0, -1),
			new Vector2Int(-1, 1),
			new Vector2Int(1, -1),
			new Vector2Int(1, 1),
			new Vector2Int(-1, -1)
		};

		private Material m_DepthResolveMaterial;

		private Material m_CameraMotionVectorsMaterial;

		private Material m_DecalNormalBufferMaterial;

		private Material m_DownsampleDepthMaterialHalfresCheckerboard;

		private Material m_DownsampleDepthMaterialGather;

		private GBufferOutput m_GBufferOutput;

		private DBufferOutput m_DBufferOutput;

		private GPUCopy m_GPUCopy;

		private static string[] s_DBufferNames = new string[4] { "DBuffer0", "DBuffer1", "DBuffer2", "DBuffer3" };

		private static Color s_DBufferClearColor = new Color(0f, 0f, 0f, 1f);

		private static Color s_DBufferClearColorNormal = new Color(0.5f, 0.5f, 0.5f, 1f);

		private static Color s_DBufferClearColorAOSBlend = new Color(1f, 1f, 1f, 1f);

		private static Color[] s_DBufferClearColors = new Color[4] { s_DBufferClearColor, s_DBufferClearColorNormal, s_DBufferClearColor, s_DBufferClearColorAOSBlend };

		private TextureHandle m_NonMSAAColorBuffer;

		internal bool m_ShouldOverrideColorBufferFormat;

		private GraphicsFormat m_AOVGraphicsFormat;

		private int colorMaskTransparentVel;

		private int colorMaskAdditionalTarget;

		private ComputeShader m_SubsurfaceScatteringCS;

		private int m_SubsurfaceScatteringKernel;

		private int m_SubsurfaceScatteringKernelMSAA;

		private Material m_CombineLightingPass;

		private Material m_SSSCopyStencilForSplitLighting;

		private Vector4[] m_SSSShapeParamsAndMaxScatterDists;

		private Vector4[] m_SSSTransmissionTintsAndFresnel0;

		private Vector4[] m_SSSDisabledTransmissionTintsAndFresnel0;

		private Vector4[] m_SSSWorldScalesAndFilterRadiiAndThicknessRemaps;

		private uint[] m_SSSDiffusionProfileHashes;

		private int[] m_SSSDiffusionProfileUpdate;

		private DiffusionProfileSettings[] m_SSSSetDiffusionProfiles;

		private DiffusionProfileSettings m_SSSDefaultDiffusionProfile;

		private int m_SSSActiveDiffusionProfileCount;

		private uint m_SSSTexturingModeFlags;

		private uint m_SSSTransmissionFlags;

		private PathTracing m_PathTracingSettings;

		private uint m_CacheLightCount;

		private int m_CameraID;

		private int m_SkyHash = -1;

		private bool m_RenderSky = true;

		private TextureHandle m_FrameTexture;

		private TextureHandle m_SkyBGTexture;

		private TextureHandle m_SkyCDFTexture;

		private TextureHandle m_SkyMarginalTexture;

		private int m_skySamplingSize;

		private List<Tuple<TextureHandle, HDCameraFrameHistoryType>> pathTracedAOVs;

		private static readonly string m_RTASDebugRTKernel = "RTASDebug";

		private HDRTASManager m_RTASManager;

		private HDRaytracingLightCluster m_RayTracingLightCluster;

		private HDRayTracingLights m_RayTracingLights = new HDRayTracingLights();

		private bool m_ValidRayTracingState;

		private bool m_ValidRayTracingCluster;

		private bool m_ValidRayTracingClusterCulling;

		private bool m_RayTracedShadowsRequired;

		private bool m_RayTracedContactShadowsRequired;

		private HDTemporalFilter m_TemporalFilter;

		private HDDiffuseDenoiser m_DiffuseDenoiser;

		private HDReflectionDenoiser m_ReflectionDenoiser;

		private HDDiffuseShadowDenoiser m_DiffuseShadowDenoiser;

		private RayCountManager m_RayCountManager;

		private const int maxNumSubMeshes = 32;

		private static RayTracingSubMeshFlags[] subMeshFlagArray = new RayTracingSubMeshFlags[32];

		private static List<Material> materialArray = new List<Material>(32);

		private static Dictionary<int, int> m_MaterialCRCs = new Dictionary<int, int>();

		private ShaderVariablesRaytracingLightLoop m_ShaderVariablesRaytracingLightLoopCB;

		private int m_RTAOApplyIntensityKernel;

		private const string m_AORayGenShaderName = "RayGenAmbientOcclusion";

		private ComputeBuffer m_RayBinResult;

		private ComputeBuffer m_RayBinSizeResult;

		private const string m_RayGenGBuffer = "RayGenGBuffer";

		private const string m_RayGenGBufferHalfRes = "RayGenGBufferHalfRes";

		private const string m_RayGenGBufferBinned = "RayGenGBufferBinned";

		private const string m_RayGenGBufferHalfResBinned = "RayGenGBufferHalfResBinned";

		private const string m_MissShaderNameGBuffer = "MissShaderGBuffer";

		private const int binningTileSize = 16;

		private const string m_RayGenIndirectDiffuseIntegrationName = "RayGenIntegration";

		private int m_RaytracingIndirectDiffuseFullResKernel;

		private int m_RaytracingIndirectDiffuseHalfResKernel;

		private int m_IndirectDiffuseUpscaleFullResKernel;

		private int m_IndirectDiffuseUpscaleHalfResKernel;

		private const string m_RayGenShaderName = "RayGenRenderer";

		private ShaderTagId raytracingPassID = new ShaderTagId("Forward");

		private RenderStateBlock m_RaytracingFlagStateBlock;

		private const int rtReflectionsComputeTileSize = 8;

		private const string m_RayGenIntegrationName = "RayGenIntegration";

		private const string m_RayGenIntegrationTransparentName = "RayGenIntegrationTransparent";

		private int m_RaytracingReflectionsFullResKernel;

		private int m_RaytracingReflectionsHalfResKernel;

		private int m_RaytracingReflectionsTransparentFullResKernel;

		private int m_RaytracingReflectionsTransparentHalfResKernel;

		private int m_ReflectionAdjustWeightKernel;

		private int m_ReflectionRescaleAndAdjustWeightKernel;

		private int m_ReflectionUpscaleKernel;

		private int m_SSSClearTextureKernel;

		private int m_RaytracingDiffuseDeferredKernel;

		private int m_CombineSubSurfaceKernel;

		private int m_CombineSubSurfaceWithGIKernel;

		private const int s_sssTileSize = 8;

		private const string m_RayGenSubSurfaceShaderName = "RayGenSubSurface";

		private ComputeShader m_WaterSimulationCS;

		private int m_InitializePhillipsSpectrumKernel;

		private int m_EvaluateDispersionKernel;

		private int m_EvaluateNormalsFoamKernel;

		private int m_CopyAdditionalDataKernel;

		private int m_FindVerticalDisplacementsKernel;

		private int m_PrepareCausticsGeometryKernel;

		private int m_EvaluateInstanceDataKernel;

		private ComputeShader m_FourierTransformCS;

		private int m_RowPassTi_Kernel;

		private int m_ColPassTi_Kernel;

		private ComputeShader m_WaterLightingCS;

		private int m_WaterPrepareSSRKernel;

		private int m_WaterDeferredLightingKernel;

		private int m_UnderWaterKernel;

		private RTHandle m_HtRs;

		private RTHandle m_HtIs;

		private RTHandle m_FFTRowPassRs;

		private RTHandle m_FFTRowPassIs;

		private RTHandle m_AdditionalData;

		private Material m_InternalWaterMaterial;

		private const int k_WaterGBuffer = 0;

		private Mesh m_TessellableMesh;

		private ComputeBuffer m_WaterIndirectDispatchBuffer;

		private ComputeBuffer m_WaterPatchDataBuffer;

		private ComputeBuffer m_WaterCameraFrustrumBuffer;

		private FrustumGPU[] m_WaterCameraFrustumCPU = new FrustumGPU[1];

		private bool m_ActiveWaterSimulation;

		private MaterialPropertyBlock m_WaterMaterialPropertyBlock;

		private ShaderVariablesWater m_ShaderVariablesWater;

		private WaterSimulationResolution m_WaterBandResolution = WaterSimulationResolution.Medium128;

		private const int k_MaxNumWaterSurfaceProfiles = 16;

		private WaterSurfaceProfile[] m_WaterSurfaceProfileArray = new WaterSurfaceProfile[16];

		private ComputeBuffer m_WaterProfileArrayGPU;

		private GraphicsBuffer m_CausticsGeometry;

		private bool m_CausticsBufferGeometryInitialized;

		private Material m_CausticsMaterial;

		private ComputeBuffer m_WaterCameraHeightBuffer;

		private bool m_ActiveWaterSimulationCPU;

		internal NativeArray<float4> htR0;

		internal NativeArray<float4> htI0;

		internal NativeArray<float4> htR1;

		internal NativeArray<float4> htI1;

		internal NativeArray<float3> pingPong;

		internal NativeArray<uint4> indices;

		internal int m_UnderWaterSurfaceIndex;

		internal static readonly float[] sizeMultiplier = new float[4] { 1f, 4f, 32f, 128f };

		internal static readonly float[] offsets = new float[4] { 0f, 0.5f, 4.5f, 36.5f };

		internal HDGpuLightsBuilder gpuLightList => m_GpuLightsBuilder;

		private ComputeShader buildScreenAABBShader => defaultResources.shaders.buildScreenAABBCS;

		private ComputeShader buildPerTileLightListShader => defaultResources.shaders.buildPerTileLightListCS;

		private ComputeShader buildPerBigTileLightListShader => defaultResources.shaders.buildPerBigTileLightListCS;

		private ComputeShader buildPerVoxelLightListShader => defaultResources.shaders.buildPerVoxelLightListCS;

		private ComputeShader clearClusterAtomicIndexShader => defaultResources.shaders.lightListClusterClearAtomicIndexCS;

		private ComputeShader buildMaterialFlagsShader => defaultResources.shaders.buildMaterialFlagsCS;

		private ComputeShader buildDispatchIndirectShader => defaultResources.shaders.buildDispatchIndirectCS;

		private ComputeShader clearDispatchIndirectShader => defaultResources.shaders.clearDispatchIndirectCS;

		private ComputeShader deferredComputeShader => defaultResources.shaders.deferredCS;

		private ComputeShader contactShadowComputeShader => defaultResources.shaders.contactShadowCS;

		private Shader screenSpaceShadowsShader => defaultResources.shaders.screenSpaceShadowPS;

		private Shader deferredTilePixelShader => defaultResources.shaders.deferredTilePS;

		public override RenderPipelineGlobalSettings defaultSettings => m_GlobalSettings;

		internal static HDRenderPipelineAsset currentAsset
		{
			get
			{
				if (!(GraphicsSettings.currentRenderPipeline is HDRenderPipelineAsset result))
				{
					return null;
				}
				return result;
			}
		}

		internal static HDRenderPipeline currentPipeline
		{
			get
			{
				if (!(RenderPipelineManager.currentPipeline is HDRenderPipeline result))
				{
					return null;
				}
				return result;
			}
		}

		internal static bool isReady
		{
			get
			{
				if (currentAsset != null)
				{
					return HDRenderPipelineGlobalSettings.instance != null;
				}
				return false;
			}
		}

		internal static bool pipelineSupportsRayTracing
		{
			get
			{
				if (currentPipeline != null)
				{
					return currentPipeline.rayTracingSupported;
				}
				return false;
			}
		}

		internal static bool pipelineSupportsScreenSpaceShadows
		{
			get
			{
				if (!(GraphicsSettings.currentRenderPipeline is HDRenderPipelineAsset hDRenderPipelineAsset))
				{
					return false;
				}
				return hDRenderPipelineAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.supportScreenSpaceShadows;
			}
		}

		internal HDRenderPipelineAsset asset => m_Asset;

		internal HDRenderPipelineRuntimeResources defaultResources => m_GlobalSettings.renderPipelineResources;

		internal RenderPipelineSettings currentPlatformRenderPipelineSettings => m_Asset.currentPlatformRenderPipelineSettings;

		private ComputeShader m_ScreenSpaceReflectionsCS => defaultResources.shaders.screenSpaceReflectionsCS;

		private ComputeShader m_ClearBuffer2DCS => defaultResources.shaders.clearBuffer2D;

		internal SkyManager skyManager => m_SkyManager;

		public bool rayTracingSupported => m_RayTracingSupported;

		internal bool reflectionProbeBaking { get; set; }

		public DebugDisplaySettings debugDisplaySettings => m_DebugDisplaySettings;

		internal bool showCascade
		{
			get
			{
				return m_DebugDisplaySettings.GetDebugLightingMode() == DebugLightingMode.VisualizeCascade;
			}
			set
			{
				if (value)
				{
					m_DebugDisplaySettings.SetDebugLightingMode(DebugLightingMode.VisualizeCascade);
				}
				else
				{
					m_DebugDisplaySettings.SetDebugLightingMode(DebugLightingMode.None);
				}
			}
		}

		IEnumerable<string> IDataProvider.supportedDebugModes => new string[7] { "Albedo", "Normal", "Smoothness", "AmbientOcclusion", "Metal", "Specular", "Alpha" };

		private ComputeShader m_LensFlareMergeOcclusionDataDrivenCS => defaultResources.shaders.lensFlareMergeOcclusionCS;

		private ResolutionGroup resGroup { get; set; }

		private Vector2Int postProcessViewportSize
		{
			get
			{
				if (resGroup != ResolutionGroup.AfterDynamicResUpscale)
				{
					return m_BeforeDynamicResUpscaleRes;
				}
				return m_AfterDynamicResUpscaleRes;
			}
		}

		internal DiffusionProfileSettings defaultDiffusionProfile => m_SSSDefaultDiffusionProfile;

		internal static bool currentSystemSupportsRayTracing => SystemInfo.supportsRayTracing;

		private static Vector3 SHEvalLinearL0L1(Vector3 N, Vector4 shAr, Vector4 shAg, Vector4 shAb)
		{
			Vector4 b = new Vector4(N.x, N.y, N.z, 1f);
			Vector3 result = default(Vector3);
			result.x = Vector4.Dot(shAr, b);
			result.y = Vector4.Dot(shAg, b);
			result.z = Vector4.Dot(shAb, b);
			return result;
		}

		private static Vector3 SHEvalLinearL2(Vector3 N, Vector4 shBr, Vector4 shBg, Vector4 shBb, Vector4 shC)
		{
			Vector4 b = new Vector4(N.x * N.y, N.y * N.z, N.z * N.z, N.z * N.x);
			Vector3 vector = default(Vector3);
			vector.x = Vector4.Dot(shBr, b);
			vector.y = Vector4.Dot(shBg, b);
			vector.z = Vector4.Dot(shBb, b);
			float num = N.x * N.x - N.y * N.y;
			Vector3 vector2 = new Vector3(0f, 0f, 0f);
			vector2.x = shC.x * num;
			vector2.y = shC.y * num;
			vector2.z = shC.z * num;
			return vector + vector2;
		}

		private static Vector3 EvaluateAmbientProbe(in Vector4[] packedCoeffs, Vector3 direction)
		{
			Vector4 shAr = packedCoeffs[0];
			Vector4 shAg = packedCoeffs[1];
			Vector4 shAb = packedCoeffs[2];
			Vector4 shBr = packedCoeffs[3];
			Vector4 shBg = packedCoeffs[4];
			Vector4 shBb = packedCoeffs[5];
			Vector4 shC = packedCoeffs[6];
			return SHEvalLinearL0L1(direction, shAr, shAg, shAb) + SHEvalLinearL2(direction, shBr, shBg, shBb, shC);
		}

		private void UpdateSortKeysArray(int count)
		{
			if (m_SortKeys == null || count > m_SortKeys.Length)
			{
				m_SortKeys = new uint[count];
			}
		}

		internal static Matrix4x4 GetWorldToViewMatrix(HDCamera hdCamera, int viewIndex)
		{
			Matrix4x4 result = (hdCamera.xr.enabled ? hdCamera.xr.GetViewMatrix(viewIndex) : hdCamera.camera.worldToCameraMatrix);
			result.m20 *= -1f;
			result.m21 *= -1f;
			result.m22 *= -1f;
			result.m23 *= -1f;
			return result;
		}

		public Light GetMainLight()
		{
			return m_CurrentSunLight;
		}

		private bool HasLightToCull()
		{
			return m_TotalLightCount > 0;
		}

		private static int GetNumTileBigTileX(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.x, LightDefinitions.s_TileSizeBigTile);
		}

		private static int GetNumTileBigTileY(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.y, LightDefinitions.s_TileSizeBigTile);
		}

		private static int GetNumTileFtplX(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.x, LightDefinitions.s_TileSizeFptl);
		}

		private static int GetNumTileFtplY(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.y, LightDefinitions.s_TileSizeFptl);
		}

		private static int GetNumTileClusteredX(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.x, LightDefinitions.s_TileSizeClustered);
		}

		private static int GetNumTileClusteredY(HDCamera hdCamera)
		{
			return HDUtils.DivRoundUp((int)hdCamera.screenSize.y, LightDefinitions.s_TileSizeClustered);
		}

		private void InitShadowSystem(HDRenderPipelineAsset hdAsset, HDRenderPipelineRuntimeResources defaultResources)
		{
			m_ShadowInitParameters = hdAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams;
			m_ShadowManager = new HDShadowManager();
			m_ShadowManager.InitShadowManager(defaultResources, m_ShadowInitParameters, m_RenderGraph, defaultResources.shaders.shadowClearPS);
		}

		private void DeinitShadowSystem()
		{
			if (m_ShadowManager != null)
			{
				m_ShadowManager.Cleanup(m_RenderGraph);
				m_ShadowManager = null;
			}
		}

		private static bool GetFeatureVariantsEnabled(FrameSettings frameSettings)
		{
			if (frameSettings.litShaderMode == LitShaderMode.Deferred && frameSettings.IsEnabled(FrameSettingsField.DeferredTile))
			{
				if (!frameSettings.IsEnabled(FrameSettingsField.ComputeLightVariants))
				{
					return frameSettings.IsEnabled(FrameSettingsField.ComputeMaterialVariants);
				}
				return true;
			}
			return false;
		}

		private int GetDeferredLightingMaterialIndex(int outputSplitLighting, int shadowMask, int debugDisplay)
		{
			return outputSplitLighting | (shadowMask << 1) | (debugDisplay << 2);
		}

		private Material GetDeferredLightingMaterial(bool outputSplitLighting, bool shadowMask, bool debugDisplayEnabled)
		{
			int deferredLightingMaterialIndex = GetDeferredLightingMaterialIndex(outputSplitLighting ? 1 : 0, shadowMask ? 1 : 0, debugDisplayEnabled ? 1 : 0);
			return m_deferredLightingMaterial[deferredLightingMaterialIndex];
		}

		private void InitializeLightLoop(IBLFilterBSDF[] iBLFilterBSDFArray)
		{
			GlobalLightLoopSettings lightLoopSettings = asset.currentPlatformRenderPipelineSettings.lightLoopSettings;
			m_lightList = new LightList();
			m_lightList.Allocate();
			m_ProcessedLightsBuilder = new HDProcessedVisibleLightsBuilder();
			m_GpuLightsBuilder = new HDGpuLightsBuilder();
			m_MaxDirectionalLightsOnScreen = lightLoopSettings.maxDirectionalLightsOnScreen;
			m_MaxPunctualLightsOnScreen = lightLoopSettings.maxPunctualLightsOnScreen;
			m_MaxAreaLightsOnScreen = lightLoopSettings.maxAreaLightsOnScreen;
			m_MaxDecalsOnScreen = lightLoopSettings.maxDecalsOnScreen;
			m_MaxPlanarReflectionsOnScreen = Math.Min(lightLoopSettings.maxPlanarReflectionOnScreen, 16);
			m_MaxCubeReflectionsOnScreen = Math.Min(lightLoopSettings.maxCubeReflectionOnScreen, 64);
			m_MaxEnvLightsOnScreen = m_MaxPlanarReflectionsOnScreen + m_MaxCubeReflectionsOnScreen;
			m_MaxLightsOnScreen = m_MaxDirectionalLightsOnScreen + m_MaxPunctualLightsOnScreen + m_MaxAreaLightsOnScreen + m_MaxEnvLightsOnScreen;
			s_ClearVoxelAtomicKernel = clearClusterAtomicIndexShader.FindKernel("ClearAtomic");
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					s_ClusterKernels[i, j] = buildPerVoxelLightListShader.FindKernel(s_ClusterKernelNames[i, j]);
					s_ClusterObliqueKernels[i, j] = buildPerVoxelLightListShader.FindKernel(s_ClusterObliqueKernelNames[i, j]);
				}
			}
			s_GenListPerTileKernel = buildPerTileLightListShader.FindKernel("TileLightListGen");
			s_GenListPerBigTileKernel = buildPerBigTileLightListShader.FindKernel("BigTileLightListGen");
			s_BuildIndirectKernel = buildDispatchIndirectShader.FindKernel("BuildIndirect");
			s_ClearDispatchIndirectKernel = clearDispatchIndirectShader.FindKernel("ClearDispatchIndirect");
			s_ClearDrawProceduralIndirectKernel = clearDispatchIndirectShader.FindKernel("ClearDrawProceduralIndirect");
			s_BuildMaterialFlagsWriteKernel = buildMaterialFlagsShader.FindKernel("MaterialFlagsGen");
			s_shadeOpaqueDirectFptlKernel = deferredComputeShader.FindKernel("Deferred_Direct_Fptl");
			s_shadeOpaqueDirectFptlDebugDisplayKernel = deferredComputeShader.FindKernel("Deferred_Direct_Fptl_DebugDisplay");
			s_deferredContactShadowKernel = contactShadowComputeShader.FindKernel("DeferredContactShadow");
			for (int k = 0; k < LightDefinitions.s_NumFeatureVariants; k++)
			{
				s_shadeOpaqueIndirectFptlKernels[k] = deferredComputeShader.FindKernel("Deferred_Indirect_Fptl_Variant" + k);
			}
			m_TextureCaches.Initialize(asset, defaultResources, iBLFilterBSDFArray);
			m_LightLoopLightData.Initialize(m_MaxDirectionalLightsOnScreen, m_MaxPunctualLightsOnScreen, m_MaxAreaLightsOnScreen, m_MaxEnvLightsOnScreen, m_MaxDecalsOnScreen);
			m_TileAndClusterData.Initialize(allocateTileBuffers: true, clusterNeedsDepth: true, m_MaxLightsOnScreen);
			m_deferredLightingMaterial = new Material[8];
			int value = 6;
			for (int l = 0; l < 2; l++)
			{
				for (int m = 0; m < 2; m++)
				{
					for (int n = 0; n < 2; n++)
					{
						int deferredLightingMaterialIndex = GetDeferredLightingMaterialIndex(l, m, n);
						m_deferredLightingMaterial[deferredLightingMaterialIndex] = CoreUtils.CreateEngineMaterial(defaultResources.shaders.deferredPS);
						m_deferredLightingMaterial[deferredLightingMaterialIndex].name = $"{defaultResources.shaders.deferredPS.name}_{deferredLightingMaterialIndex}";
						CoreUtils.SetKeyword(m_deferredLightingMaterial[deferredLightingMaterialIndex], "OUTPUT_SPLIT_LIGHTING", l == 1);
						CoreUtils.SetKeyword(m_deferredLightingMaterial[deferredLightingMaterialIndex], "SHADOWS_SHADOWMASK", m == 1);
						CoreUtils.SetKeyword(m_deferredLightingMaterial[deferredLightingMaterialIndex], "DEBUG_DISPLAY", n == 1);
						int num = 2;
						if (l == 1)
						{
							num |= 4;
						}
						m_deferredLightingMaterial[deferredLightingMaterialIndex].SetInt(HDShaderIDs._StencilMask, value);
						m_deferredLightingMaterial[deferredLightingMaterialIndex].SetInt(HDShaderIDs._StencilRef, num);
						m_deferredLightingMaterial[deferredLightingMaterialIndex].SetInt(HDShaderIDs._StencilCmp, 3);
					}
				}
			}
			s_DeferredTileRegularLightingMat = CoreUtils.CreateEngineMaterial(deferredTilePixelShader);
			s_DeferredTileRegularLightingMat.SetInt(HDShaderIDs._StencilMask, 6);
			s_DeferredTileRegularLightingMat.SetInt(HDShaderIDs._StencilRef, 2);
			s_DeferredTileRegularLightingMat.SetInt(HDShaderIDs._StencilCmp, 3);
			s_DeferredTileSplitLightingMat = CoreUtils.CreateEngineMaterial(deferredTilePixelShader);
			s_DeferredTileSplitLightingMat.SetInt(HDShaderIDs._StencilMask, 4);
			s_DeferredTileSplitLightingMat.SetInt(HDShaderIDs._StencilRef, 4);
			s_DeferredTileSplitLightingMat.SetInt(HDShaderIDs._StencilCmp, 3);
			s_DeferredTileMat = CoreUtils.CreateEngineMaterial(deferredTilePixelShader);
			s_DeferredTileMat.SetInt(HDShaderIDs._StencilMask, 2);
			s_DeferredTileMat.SetInt(HDShaderIDs._StencilRef, 0);
			s_DeferredTileMat.SetInt(HDShaderIDs._StencilCmp, 6);
			for (int num2 = 0; num2 < LightDefinitions.s_NumFeatureVariants; num2++)
			{
				s_variantNames[num2] = "VARIANT" + num2;
			}
			HDShadowInitParameters hdShadowInitParams = asset.currentPlatformRenderPipelineSettings.hdShadowInitParams;
			string[] array = new string[3] { "SHADOW_LOW", "SHADOW_MEDIUM", "SHADOW_HIGH" };
			string[] array2 = array;
			for (int num3 = 0; num3 < array2.Length; num3++)
			{
				Shader.DisableKeyword(array2[num3]);
			}
			Shader.EnableKeyword(array[(int)hdShadowInitParams.shadowFilteringQuality]);
			string[] array3 = new string[2] { "AREA_SHADOW_MEDIUM", "AREA_SHADOW_HIGH" };
			array2 = array3;
			for (int num3 = 0; num3 < array2.Length; num3++)
			{
				Shader.DisableKeyword(array2[num3]);
			}
			Shader.EnableKeyword(array3[(int)hdShadowInitParams.areaShadowFilteringQuality]);
			if (hdShadowInitParams.supportScreenSpaceShadows)
			{
				Shader.EnableKeyword("SCREEN_SPACE_SHADOWS_ON");
				Shader.DisableKeyword("SCREEN_SPACE_SHADOWS_OFF");
			}
			else
			{
				Shader.DisableKeyword("SCREEN_SPACE_SHADOWS_ON");
				Shader.EnableKeyword("SCREEN_SPACE_SHADOWS_OFF");
			}
			InitShadowSystem(asset, defaultResources);
			m_GpuLightsBuilder.Initialize(m_Asset, m_ShadowManager, m_TextureCaches);
			s_lightVolumes = new DebugLightVolumes();
			s_lightVolumes.InitData(defaultResources);
			int num4 = Math.Max(m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots, 1);
			m_CurrentScreenSpaceShadowData = new ScreenSpaceShadowData[num4];
			if (asset.currentPlatformRenderPipelineSettings.supportDecals && asset.currentPlatformRenderPipelineSettings.supportSurfaceGradient)
			{
				Shader.EnableKeyword("DECAL_SURFACE_GRADIENT");
			}
			else
			{
				Shader.DisableKeyword("DECAL_SURFACE_GRADIENT");
			}
		}

		private void CleanupLightLoop()
		{
			s_lightVolumes.ReleaseData();
			DeinitShadowSystem();
			m_TextureCaches.Cleanup();
			m_LightLoopLightData.Cleanup();
			m_TileAndClusterData.Cleanup();
			LightLoopReleaseResolutionDependentBuffers();
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < 2; j++)
				{
					for (int k = 0; k < 2; k++)
					{
						int deferredLightingMaterialIndex = GetDeferredLightingMaterialIndex(i, j, k);
						CoreUtils.Destroy(m_deferredLightingMaterial[deferredLightingMaterialIndex]);
					}
				}
			}
			CoreUtils.Destroy(s_DeferredTileRegularLightingMat);
			CoreUtils.Destroy(s_DeferredTileSplitLightingMat);
			CoreUtils.Destroy(s_DeferredTileMat);
			m_ProcessedLightsBuilder.Cleanup();
			m_GpuLightsBuilder.Cleanup();
		}

		private void LightLoopNewRender()
		{
			m_ScreenSpaceShadowsUnion.Clear();
			m_TextureCaches.NewRender();
		}

		private void LightLoopNewFrame(CommandBuffer cmd, HDCamera hdCamera)
		{
			FrameSettings frameSettings = hdCamera.frameSettings;
			m_ContactShadows = hdCamera.volumeStack.GetComponent<ContactShadows>();
			m_EnableContactShadow = frameSettings.IsEnabled(FrameSettingsField.ContactShadows) && m_ContactShadows.enable.value && m_ContactShadows.length.value > 0f;
			m_indirectLightingController = hdCamera.volumeStack.GetComponent<IndirectLightingController>();
			m_ContactShadowIndex = 0;
			m_TextureCaches.NewFrame();
			m_WorldToViewMatrices.Clear();
			int viewCount = hdCamera.viewCount;
			for (int i = 0; i < viewCount; i++)
			{
				m_WorldToViewMatrices.Add(GetWorldToViewMatrix(hdCamera, i));
			}
			if (m_DebugDisplaySettings.data.lightingDebugSettings.clearCookieAtlas)
			{
				m_TextureCaches.lightCookieManager.ResetAllocator();
				m_TextureCaches.lightCookieManager.ClearAtlasTexture(cmd);
			}
			if (m_DebugDisplaySettings.data.lightingDebugSettings.clearReflectionProbeAtlas)
			{
				m_TextureCaches.reflectionProbeTextureCache.Clear(cmd);
			}
			bool flag = IsAPVEnabled();
			ProbeReferenceVolume.instance.SetEnableStateFromSRP(flag);
			if (flag && ProbeReferenceVolume.instance.isInitialized && hdCamera.frameSettings.IsEnabled(FrameSettingsField.ProbeVolume))
			{
				ProbeReferenceVolume.instance.PerformPendingOperations();
				if (hdCamera.camera.cameraType != CameraType.Reflection && hdCamera.camera.cameraType != CameraType.Preview)
				{
					ProbeReferenceVolume.instance.UpdateCellStreaming(cmd, hdCamera.camera);
				}
			}
		}

		private static int NumLightIndicesPerClusteredTile()
		{
			return ShaderConfig.FPTLMaxLightCount * 64;
		}

		private void LightLoopAllocResolutionDependentBuffers(HDCamera hdCamera, int width, int height)
		{
			m_TileAndClusterData.AllocateResolutionDependentBuffers(hdCamera, width, height, m_MaxViewCount, m_MaxLightsOnScreen);
		}

		private void LightLoopReleaseResolutionDependentBuffers()
		{
			m_TileAndClusterData.ReleaseResolutionDependentBuffers();
		}

		internal static Matrix4x4 WorldToCamera(Camera camera)
		{
			return s_FlipMatrixLHSRHS * camera.worldToCameraMatrix;
		}

		private static Matrix4x4 CameraProjectionNonObliqueLHS(HDCamera camera)
		{
			return camera.nonObliqueProjMatrix * s_FlipMatrixLHSRHS;
		}

		internal static Vector3 GetLightColor(VisibleLight light)
		{
			return new Vector3(light.finalColor.r, light.finalColor.g, light.finalColor.b);
		}

		private bool EnoughScreenSpaceShadowSlots(GPULightType gpuLightType, int screenSpaceChannelSlot)
		{
			if (gpuLightType == GPULightType.Rectangle)
			{
				return screenSpaceChannelSlot + 1 < m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots;
			}
			return screenSpaceChannelSlot < m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots;
		}

		internal bool GetEnvLightData(CommandBuffer cmd, HDCamera hdCamera, in ProcessedProbeData processedProbe, ref EnvLightData envLightData, out int fetchIndex, out Vector4 scaleOffset, out Matrix4x4 vp)
		{
			fetchIndex = -1;
			scaleOffset = Vector4.zero;
			vp = Matrix4x4.identity;
			envLightData.roughReflections = 1f;
			envLightData.distanceBasedRoughness = 0f;
			Camera camera = hdCamera.camera;
			HDProbe hdProbe = processedProbe.hdProbe;
			if (!hdProbe.HasValidRenderedData())
			{
				return false;
			}
			Vector3 capturePositionRWS = Vector3.zero;
			Matrix4x4 influenceToWorld = hdProbe.influenceToWorld;
			int num = int.MinValue;
			if (!(hdProbe is PlanarReflectionProbe planarReflectionProbe))
			{
				if (hdProbe is HDAdditionalReflectionData)
				{
					scaleOffset = m_TextureCaches.reflectionProbeTextureCache.FetchCubeReflectionProbe(cmd, hdProbe, out fetchIndex);
					num = ((scaleOffset == Vector4.zero) ? int.MinValue : (fetchIndex + 1));
					if (fetchIndex >= m_MaxCubeReflectionsOnScreen)
					{
						Debug.LogWarning("Maximum reflection probes on screen reached. To fix this error, increase the 'Maximum Cube Reflection Probes on Screen' property in the HDRP asset.");
					}
					else
					{
						ProbeCapturePositionSettings position = ProbeCapturePositionSettings.ComputeFrom(hdProbe, camera.transform);
						HDRenderUtilities.ComputeCameraSettingsFromProbeSettings(hdProbe.settings, position, out var _, out var cameraPositionSettings, 0uL);
						capturePositionRWS = cameraPositionSettings.position;
						envLightData.rangeCompressionFactorCompensation = Mathf.Max(hdProbe.rangeCompressionFactor, 1E-06f);
						envLightData.distanceBasedRoughness = ((hdProbe.settings.distanceBasedRoughness && !hdProbe.isProjectionInfinite) ? 1f : 0f);
					}
				}
			}
			else if (hdProbe.mode != ProbeSettings.Mode.Realtime || hdCamera.frameSettings.IsEnabled(FrameSettingsField.PlanarProbe))
			{
				HDProbe.RenderData renderData = planarReflectionProbe.renderData;
				Matrix4x4 worldToCameraRHS = renderData.worldToCameraRHS;
				Matrix4x4 projectionMatrix = renderData.projectionMatrix;
				Matrix4x4 proj = Matrix4x4.Perspective(renderData.fieldOfView, hdProbe.texture.width / hdProbe.texture.height, hdProbe.settings.cameraSettings.frustum.nearClipPlaneRaw, hdProbe.settings.cameraSettings.frustum.farClipPlane);
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(projectionMatrix, renderIntoTexture: true);
				Matrix4x4 gPUProjectionMatrix2 = GL.GetGPUProjectionMatrix(proj, renderIntoTexture: true);
				vp = gPUProjectionMatrix * worldToCameraRHS;
				Matrix4x4 captureCameraVP_NonOblique = gPUProjectionMatrix2 * worldToCameraRHS;
				IBLFilterBSDF.PlanarTextureFilteringParameters planarTextureFilteringParameters = default(IBLFilterBSDF.PlanarTextureFilteringParameters);
				planarTextureFilteringParameters.smoothPlanarReflection = !hdProbe.settings.roughReflections;
				planarTextureFilteringParameters.probeNormal = Vector3.Normalize(hdCamera.camera.transform.position - renderData.capturePosition);
				planarTextureFilteringParameters.probePosition = hdProbe.gameObject.transform.position;
				planarTextureFilteringParameters.captureCameraDepthBuffer = planarReflectionProbe.realtimeDepthTexture;
				planarTextureFilteringParameters.captureCameraScreenSize = new Vector4(hdProbe.texture.width, hdProbe.texture.height, 1f / (float)hdProbe.texture.width, 1f / (float)hdProbe.texture.height);
				planarTextureFilteringParameters.captureCameraIVP = vp.inverse;
				planarTextureFilteringParameters.captureCameraIVP_NonOblique = captureCameraVP_NonOblique.inverse;
				planarTextureFilteringParameters.captureCameraVP_NonOblique = captureCameraVP_NonOblique;
				planarTextureFilteringParameters.captureCameraPosition = renderData.capturePosition;
				planarTextureFilteringParameters.captureFOV = renderData.fieldOfView;
				planarTextureFilteringParameters.captureNearPlane = hdProbe.settings.cameraSettings.frustum.nearClipPlaneRaw;
				planarTextureFilteringParameters.captureFarPlane = hdProbe.settings.cameraSettings.frustum.farClipPlane;
				scaleOffset = m_TextureCaches.reflectionProbeTextureCache.FetchPlanarReflectionProbe(cmd, hdProbe, ref planarTextureFilteringParameters, out fetchIndex);
				capturePositionRWS = Vector3.zero;
				num = ((scaleOffset == Vector4.zero) ? int.MinValue : (-(fetchIndex + 1)));
				if (fetchIndex >= m_MaxPlanarReflectionsOnScreen)
				{
					Debug.LogWarning("Maximum planar reflection probes on screen reached. To fix this error, increase the 'Maximum Planar Reflection Probes on Screen' property in the HDRP asset.");
				}
				else
				{
					envLightData.roughReflections = (hdProbe.settings.roughReflections ? 1f : 0f);
					if (hdProbe.ExposureControlEnabled)
					{
						envLightData.rangeCompressionFactorCompensation = 1f / hdProbe.ProbeExposureValue();
					}
					else
					{
						envLightData.rangeCompressionFactorCompensation = Mathf.Max(hdProbe.rangeCompressionFactor, 1E-06f);
					}
				}
			}
			if (num == int.MinValue)
			{
				return false;
			}
			InfluenceVolume influenceVolume = hdProbe.influenceVolume;
			envLightData.lightLayers = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers) ? hdProbe.lightLayersAsUInt : uint.MaxValue);
			envLightData.influenceShapeType = influenceVolume.envShape;
			envLightData.weight = processedProbe.weight;
			envLightData.multiplier = hdProbe.multiplier * m_indirectLightingController.reflectionProbeIntensityMultiplier.value;
			envLightData.influenceExtents = influenceVolume.extents;
			switch (influenceVolume.envShape)
			{
			case EnvShapeType.Box:
				envLightData.blendDistancePositive = influenceVolume.boxBlendDistancePositive;
				envLightData.blendDistanceNegative = influenceVolume.boxBlendDistanceNegative;
				if (num >= 0)
				{
					envLightData.blendNormalDistancePositive = influenceVolume.boxBlendNormalDistancePositive;
					envLightData.blendNormalDistanceNegative = influenceVolume.boxBlendNormalDistanceNegative;
					envLightData.boxSideFadePositive = influenceVolume.boxSideFadePositive;
					envLightData.boxSideFadeNegative = influenceVolume.boxSideFadeNegative;
				}
				else
				{
					envLightData.blendNormalDistancePositive = Vector3.zero;
					envLightData.blendNormalDistanceNegative = Vector3.zero;
					envLightData.boxSideFadePositive = Vector3.one;
					envLightData.boxSideFadeNegative = Vector3.one;
				}
				break;
			case EnvShapeType.Sphere:
				envLightData.blendDistancePositive.x = influenceVolume.sphereBlendDistance;
				if (num >= 0)
				{
					envLightData.blendNormalDistancePositive.x = influenceVolume.sphereBlendNormalDistance;
				}
				else
				{
					envLightData.blendNormalDistancePositive.x = 0f;
				}
				break;
			default:
				throw new ArgumentOutOfRangeException("Unknown EnvShapeType");
			}
			envLightData.influenceRight = influenceToWorld.GetColumn(0).normalized;
			envLightData.influenceUp = influenceToWorld.GetColumn(1).normalized;
			envLightData.influenceForward = influenceToWorld.GetColumn(2).normalized;
			envLightData.capturePositionRWS = capturePositionRWS;
			envLightData.influencePositionRWS = influenceToWorld.GetColumn(3);
			envLightData.envIndex = num;
			envLightData.normalizeWithAPV = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.NormalizeReflectionProbeWithProbeVolume) ? 1 : 0);
			if (envLightData.normalizeWithAPV > 0 && !hdProbe.GetSHForNormalization(out envLightData.L0L1, out envLightData.L2_1, out envLightData.L2_2))
			{
				envLightData.normalizeWithAPV = 0;
			}
			Matrix4x4 proxyToWorld = hdProbe.proxyToWorld;
			envLightData.proxyExtents = hdProbe.proxyExtents;
			envLightData.minProjectionDistance = (hdProbe.isProjectionInfinite ? 65504f : 0f);
			envLightData.proxyRight = proxyToWorld.GetColumn(0).normalized;
			envLightData.proxyUp = proxyToWorld.GetColumn(1).normalized;
			envLightData.proxyForward = proxyToWorld.GetColumn(2).normalized;
			envLightData.proxyPositionRWS = proxyToWorld.GetColumn(3);
			return true;
		}

		private void GetEnvLightVolumeDataAndBound(HDProbe probe, LightVolumeType lightVolumeType, Matrix4x4 worldToView, int viewIndex)
		{
			SFiniteLightBound lightBound = default(SFiniteLightBound);
			LightVolumeData volumeData = default(LightVolumeData);
			Vector3 influenceExtents = probe.influenceExtents;
			Matrix4x4 influenceToWorld = probe.influenceToWorld;
			Vector3 vector = worldToView.MultiplyVector(influenceToWorld.GetColumn(0).normalized);
			Vector3 vector2 = worldToView.MultiplyVector(influenceToWorld.GetColumn(1).normalized);
			Vector3 vector3 = worldToView.MultiplyVector(influenceToWorld.GetColumn(2).normalized);
			Vector3 vector4 = worldToView.MultiplyPoint(influenceToWorld.GetColumn(3));
			volumeData.lightCategory = 2u;
			volumeData.lightVolume = (uint)lightVolumeType;
			volumeData.featureFlags = 32768u;
			switch (lightVolumeType)
			{
			case LightVolumeType.Sphere:
				volumeData.lightPos = vector4;
				volumeData.radiusSq = influenceExtents.x * influenceExtents.x;
				volumeData.lightAxisX = vector;
				volumeData.lightAxisY = vector2;
				volumeData.lightAxisZ = vector3;
				lightBound.center = vector4;
				lightBound.boxAxisX = vector * influenceExtents.x;
				lightBound.boxAxisY = vector2 * influenceExtents.x;
				lightBound.boxAxisZ = vector3 * influenceExtents.x;
				lightBound.scaleXY = 1f;
				lightBound.radius = influenceExtents.x;
				break;
			case LightVolumeType.Box:
				lightBound.center = vector4;
				lightBound.boxAxisX = influenceExtents.x * vector;
				lightBound.boxAxisY = influenceExtents.y * vector2;
				lightBound.boxAxisZ = influenceExtents.z * vector3;
				lightBound.scaleXY = 1f;
				lightBound.radius = influenceExtents.magnitude;
				volumeData.lightPos = vector4;
				volumeData.lightAxisX = vector;
				volumeData.lightAxisY = vector2;
				volumeData.lightAxisZ = vector3;
				volumeData.boxInnerDist = influenceExtents - k_BoxCullingExtentThreshold;
				volumeData.boxInvRange.Set(1f / k_BoxCullingExtentThreshold.x, 1f / k_BoxCullingExtentThreshold.y, 1f / k_BoxCullingExtentThreshold.z);
				break;
			}
			m_GpuLightsBuilder.AddLightBounds(viewIndex, in lightBound, in volumeData);
		}

		private void CreateBoxVolumeDataAndBound(OrientedBBox obb, LightCategory category, LightFeatureFlags featureFlags, Matrix4x4 worldToView, float normalBiasDilation, out LightVolumeData volumeData, out SFiniteLightBound bound)
		{
			volumeData = default(LightVolumeData);
			bound = default(SFiniteLightBound);
			float num = obb.extentX + normalBiasDilation;
			float num2 = obb.extentY + normalBiasDilation;
			float num3 = obb.extentZ + normalBiasDilation;
			float radius = Mathf.Sqrt(num * num + num2 * num2 + num3 * num3);
			Vector3 vector = worldToView.MultiplyPoint(obb.center);
			Vector3 vector2 = worldToView.MultiplyVector(obb.right);
			Vector3 vector3 = worldToView.MultiplyVector(obb.up);
			Vector3 vector4 = Vector3.Cross(vector3, vector2);
			Vector3 vector5 = new Vector3(num, num2, num3);
			volumeData.lightVolume = 2u;
			volumeData.lightCategory = (uint)category;
			volumeData.featureFlags = (uint)featureFlags;
			bound.center = vector;
			bound.boxAxisX = num * vector2;
			bound.boxAxisY = num2 * vector3;
			bound.boxAxisZ = num3 * vector4;
			bound.radius = radius;
			bound.scaleXY = 1f;
			volumeData.lightPos = vector;
			volumeData.lightAxisX = vector2;
			volumeData.lightAxisY = vector3;
			volumeData.lightAxisZ = vector4;
			volumeData.boxInnerDist = vector5 - k_BoxCullingExtentThreshold;
			volumeData.boxInvRange.Set(1f / k_BoxCullingExtentThreshold.x, 1f / k_BoxCullingExtentThreshold.y, 1f / k_BoxCullingExtentThreshold.z);
		}

		internal int GetCurrentShadowCount()
		{
			return m_ShadowManager.GetShadowRequestCount();
		}

		private void LightLoopUpdateCullingParameters(ref ScriptableCullingParameters cullingParams, HDCamera hdCamera)
		{
			float value = hdCamera.volumeStack.GetComponent<HDShadowSettings>().maxShadowDistance.value;
			m_ShadowManager.UpdateCullingParameters(ref cullingParams, value);
			cullingParams.cullingOptions |= CullingOptions.DisablePerObjectCulling;
		}

		internal static bool IsBakedShadowMaskLight(Light light)
		{
			if (light == null)
			{
				return false;
			}
			if (light.bakingOutput.lightmapBakeType == LightmapBakeType.Mixed && light.bakingOutput.mixedLightingMode == MixedLightingMode.Shadowmask)
			{
				return light.bakingOutput.occlusionMaskChannel != -1;
			}
			return false;
		}

		internal static void EvaluateGPULightType(HDLightType lightType, SpotLightShape spotLightShape, AreaLightShape areaLightShape, ref LightCategory lightCategory, ref GPULightType gpuLightType, ref LightVolumeType lightVolumeType)
		{
			lightCategory = LightCategory.Count;
			gpuLightType = GPULightType.Point;
			lightVolumeType = LightVolumeType.Count;
			switch (lightType)
			{
			case HDLightType.Spot:
				lightCategory = LightCategory.Punctual;
				switch (spotLightShape)
				{
				case SpotLightShape.Cone:
					gpuLightType = GPULightType.Spot;
					lightVolumeType = LightVolumeType.Cone;
					break;
				case SpotLightShape.Pyramid:
					gpuLightType = GPULightType.ProjectorPyramid;
					lightVolumeType = LightVolumeType.Cone;
					break;
				case SpotLightShape.Box:
					gpuLightType = GPULightType.ProjectorBox;
					lightVolumeType = LightVolumeType.Box;
					break;
				}
				break;
			case HDLightType.Directional:
				lightCategory = LightCategory.Punctual;
				gpuLightType = GPULightType.Directional;
				lightVolumeType = LightVolumeType.Count;
				break;
			case HDLightType.Point:
				lightCategory = LightCategory.Punctual;
				gpuLightType = GPULightType.Point;
				lightVolumeType = LightVolumeType.Sphere;
				break;
			case HDLightType.Area:
				lightCategory = LightCategory.Area;
				switch (areaLightShape)
				{
				case AreaLightShape.Rectangle:
					gpuLightType = GPULightType.Rectangle;
					lightVolumeType = LightVolumeType.Box;
					break;
				case AreaLightShape.Tube:
					gpuLightType = GPULightType.Tube;
					lightVolumeType = LightVolumeType.Box;
					break;
				case AreaLightShape.Disc:
					gpuLightType = GPULightType.Disc;
					lightVolumeType = LightVolumeType.Sphere;
					break;
				}
				break;
			}
		}

		private bool TrivialRejectLight(in VisibleLight light, Light lightComponent, int pixelCount, in AOVRequestData aovRequest)
		{
			if (light.screenRect.height * light.screenRect.width * (float)pixelCount < 1f)
			{
				return true;
			}
			if (lightComponent != null && !aovRequest.IsLightEnabled(lightComponent.gameObject))
			{
				return true;
			}
			return false;
		}

		private void PreprocessVisibleLights(CommandBuffer cmd, HDCamera hdCamera, in CullingResults cullResults, DebugDisplaySettings debugDisplaySettings, in AOVRequestData aovRequest)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.ProcessVisibleLights)))
			{
				GlobalLightLoopSettings lightLoopSettings = asset.currentPlatformRenderPipelineSettings.lightLoopSettings;
				m_ProcessedLightsBuilder.Build(hdCamera, in cullResults, GetRayTracingState(), m_ShadowManager, in m_ShadowInitParameters, in aovRequest, in lightLoopSettings, m_CurrentDebugDisplaySettings);
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.ProcessDirectionalAndCookies)))
				{
					int sortedLightCounts = m_ProcessedLightsBuilder.sortedLightCounts;
					HDLightRenderDatabase instance = HDLightRenderDatabase.instance;
					for (int i = 0; i < sortedLightCounts; i++)
					{
						HDGpuLightsBuilder.UnpackLightSortKey(m_ProcessedLightsBuilder.sortKeys[i], out var _, out var _, out var _, out var lightIndex);
						HDProcessedVisibleLight hDProcessedVisibleLight = m_ProcessedLightsBuilder.processedEntities[lightIndex];
						HDAdditionalLightData hDAdditionalLightData = instance.hdAdditionalLightData[hDProcessedVisibleLight.dataIndex];
						if (!(hDAdditionalLightData == null))
						{
							if (hDProcessedVisibleLight.gpuLightType == GPULightType.Directional && (hDAdditionalLightData.ShadowsEnabled() || m_CurrentSunLight == null))
							{
								m_CurrentSunLightDataIndex = i;
								m_CurrentSunLight = hDAdditionalLightData.legacyLight;
								m_CurrentSunLightAdditionalLightData = hDAdditionalLightData;
							}
							ReserveCookieAtlasTexture(hDAdditionalLightData, hDAdditionalLightData.legacyLight, hDProcessedVisibleLight.lightType);
						}
					}
				}
				CloudSettings cloudSettings;
				CloudRenderer cloudRenderer;
				if (HasVolumetricCloudsShadows_IgnoreSun(hdCamera))
				{
					RTHandle rTHandle = RequestVolumetricCloudsShadowTexture(hdCamera);
					m_TextureCaches.lightCookieManager.ReserveSpace(rTHandle);
				}
				else if (m_SkyManager.TryGetCloudSettings(hdCamera, out cloudSettings, out cloudRenderer))
				{
					CookieParameters cookieParams = default(CookieParameters);
					if (cloudRenderer.GetSunLightCookieParameters(cloudSettings, ref cookieParams))
					{
						m_TextureCaches.lightCookieManager.ReserveSpace(cookieParams.texture);
					}
				}
			}
		}

		private void PrepareGPULightdata(CommandBuffer cmd, HDCamera hdCamera, CullingResults cullResults)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.PrepareGPULightdata)))
			{
				m_GpuLightsBuilder.Build(cmd, hdCamera, in cullResults, m_ProcessedLightsBuilder, HDLightRenderDatabase.instance, in m_ShadowInitParameters, m_CurrentDebugDisplaySettings);
				m_EnableBakeShadowMask = m_EnableBakeShadowMask || m_ProcessedLightsBuilder.bakedShadowsCount > 0;
				m_CurrentShadowSortedSunLightIndex = m_GpuLightsBuilder.currentShadowSortedSunLightIndex;
				m_CurrentSunShadowMapFlags = m_GpuLightsBuilder.currentSunShadowMapFlags;
				m_CurrentSunLightDirectionalLightData = m_GpuLightsBuilder.currentSunLightDirectionalLightData;
				m_ContactShadowIndex = m_GpuLightsBuilder.contactShadowIndex;
				m_ScreenSpaceShadowIndex = m_GpuLightsBuilder.screenSpaceShadowIndex;
				m_ScreenSpaceShadowChannelSlot = m_GpuLightsBuilder.screenSpaceShadowChannelSlot;
				m_DebugSelectedLightShadowIndex = m_GpuLightsBuilder.debugSelectedLightShadowIndex;
				m_DebugSelectedLightShadowCount = m_GpuLightsBuilder.debugSelectedLightShadowCount;
				m_CurrentScreenSpaceShadowData = m_GpuLightsBuilder.currentScreenSpaceShadowData;
			}
		}

		private void ClearUnusedProcessedReferences(CullingResults cullResults, HDProbeCullingResults hdProbeCullingResults)
		{
			for (int i = cullResults.visibleReflectionProbes.Length; i < m_ProcessedReflectionProbeData.size; i++)
			{
				m_ProcessedReflectionProbeData[i].hdProbe = null;
			}
			for (int j = hdProbeCullingResults.visibleProbes.Count; j < m_ProcessedPlanarProbeData.size; j++)
			{
				m_ProcessedPlanarProbeData[j].hdProbe = null;
			}
		}

		private bool TrivialRejectProbe(in ProcessedProbeData processedProbe, HDCamera hdCamera)
		{
			if (processedProbe.hdProbe.mode == ProbeSettings.Mode.Realtime && hdCamera.camera.cameraType == CameraType.Reflection)
			{
				return true;
			}
			if (!m_CurrentDebugDisplaySettings.data.lightingDebugSettings.showReflectionProbe)
			{
				return true;
			}
			if (processedProbe.weight <= 0f)
			{
				return true;
			}
			if ((hdCamera.probeLayerMask.value & (1 << processedProbe.hdProbe.gameObject.layer)) == 0)
			{
				return true;
			}
			if (processedProbe.hdProbe.texture == null)
			{
				return true;
			}
			return false;
		}

		internal static void PreprocessReflectionProbeData(ref ProcessedProbeData processedData, VisibleReflectionProbe probe, HDCamera hdCamera)
		{
			HDAdditionalReflectionData hDAdditionalReflectionData = probe.reflectionProbe.GetComponent<HDAdditionalReflectionData>();
			if (hDAdditionalReflectionData == null)
			{
				hDAdditionalReflectionData = HDUtils.s_DefaultHDAdditionalReflectionData;
				Vector3 vector = Vector3.one * probe.blendDistance;
				hDAdditionalReflectionData.influenceVolume.boxBlendDistancePositive = vector;
				hDAdditionalReflectionData.influenceVolume.boxBlendDistanceNegative = vector;
				hDAdditionalReflectionData.influenceVolume.shape = InfluenceShape.Box;
			}
			PreprocessProbeData(ref processedData, hDAdditionalReflectionData, hdCamera);
		}

		internal static void PreprocessProbeData(ref ProcessedProbeData processedData, HDProbe probe, HDCamera hdCamera)
		{
			processedData.hdProbe = probe;
			processedData.weight = HDUtils.ComputeWeightedLinearFadeDistance(processedData.hdProbe.transform.position, hdCamera.camera.transform.position, processedData.hdProbe.weight, processedData.hdProbe.fadeDistance);
		}

		private int PreprocessVisibleProbes(HDCamera hdCamera, CullingResults cullResults, HDProbeCullingResults hdProbeCullingResults, in AOVRequestData aovRequest)
		{
			DebugLightFilterMode debugLightFilterMode = m_CurrentDebugDisplaySettings.GetDebugLightFilterMode();
			bool flag = debugLightFilterMode != DebugLightFilterMode.None;
			int num = 0;
			int num2 = Math.Min(cullResults.visibleReflectionProbes.Length + hdProbeCullingResults.visibleProbes.Count, m_MaxEnvLightsOnScreen);
			UpdateSortKeysArray(num2);
			bool num3 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ReflectionProbe) && (!flag || debugLightFilterMode.IsEnabledFor(ProbeSettings.ProbeType.ReflectionProbe));
			bool flag2 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.PlanarProbe) && (!flag || debugLightFilterMode.IsEnabledFor(ProbeSettings.ProbeType.PlanarProbe));
			if (num3)
			{
				m_ProcessedReflectionProbeData.Resize(cullResults.visibleReflectionProbes.Length);
				for (int i = 0; i < cullResults.visibleReflectionProbes.Length; i++)
				{
					VisibleReflectionProbe probe = cullResults.visibleReflectionProbes[i];
					if (probe.reflectionProbe == null || probe.reflectionProbe.Equals(null) || !probe.reflectionProbe.isActiveAndEnabled || !aovRequest.IsLightEnabled(probe.reflectionProbe.gameObject))
					{
						continue;
					}
					ref ProcessedProbeData reference = ref m_ProcessedReflectionProbeData[i];
					PreprocessReflectionProbeData(ref reference, probe, hdCamera);
					if (TrivialRejectProbe(in reference, hdCamera))
					{
						continue;
					}
					if (probe.localToWorldMatrix.determinant == 0f)
					{
						Debug.LogError("Reflection probe " + probe.reflectionProbe.name + " has an invalid local frame and needs to be fixed.");
					}
					else if (num < num2)
					{
						LightVolumeType lightVolumeType = LightVolumeType.Box;
						if (reference.hdProbe != null && reference.hdProbe.influenceVolume.shape == InfluenceShape.Sphere)
						{
							lightVolumeType = LightVolumeType.Sphere;
						}
						float logVolume = CalculateProbeLogVolume(probe.bounds);
						m_SortKeys[num++] = PackProbeKey(logVolume, lightVolumeType, 0u, i);
					}
				}
			}
			if (flag2)
			{
				m_ProcessedPlanarProbeData.Resize(hdProbeCullingResults.visibleProbes.Count);
				for (int j = 0; j < hdProbeCullingResults.visibleProbes.Count; j++)
				{
					HDProbe hDProbe = hdProbeCullingResults.visibleProbes[j];
					PreprocessProbeData(ref m_ProcessedPlanarProbeData[j], hDProbe, hdCamera);
					if (aovRequest.IsLightEnabled(hDProbe.gameObject) && num < num2)
					{
						LightVolumeType lightVolumeType2 = LightVolumeType.Box;
						if (hDProbe.influenceVolume.shape == InfluenceShape.Sphere)
						{
							lightVolumeType2 = LightVolumeType.Sphere;
						}
						float logVolume2 = CalculateProbeLogVolume(hDProbe.bounds);
						m_SortKeys[num++] = PackProbeKey(logVolume2, lightVolumeType2, 1u, j);
					}
				}
			}
			CoreUnsafeUtils.QuickSort(m_SortKeys, 0, num - 1);
			return num;
		}

		private void PrepareGPUProbeData(CommandBuffer cmd, HDCamera hdCamera, CullingResults cullResults, HDProbeCullingResults hdProbeCullingResults, int processedLightCount)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.PrepareGPUProbeData)))
			{
				Vector3 worldSpaceCameraPos = hdCamera.mainViewConstants.worldSpaceCameraPos;
				for (int i = 0; i < processedLightCount; i++)
				{
					ProcessedProbeData sortedProcessedProbe = GetSortedProcessedProbe(i);
					if (sortedProcessedProbe.hdProbe.HasValidRenderedData())
					{
						m_TextureCaches.reflectionProbeTextureCache.ReserveReflectionProbeSlot(sortedProcessedProbe.hdProbe);
					}
				}
				for (int j = 0; j < processedLightCount; j++)
				{
					ProcessedProbeData processedProbe = GetSortedProcessedProbe(j);
					EnvLightData envLightData = default(EnvLightData);
					if (!GetEnvLightData(cmd, hdCamera, in processedProbe, ref envLightData, out var fetchIndex, out var scaleOffset, out var vp))
					{
						continue;
					}
					HDProbe hdProbe = processedProbe.hdProbe;
					if (!(hdProbe is PlanarReflectionProbe))
					{
						if (hdProbe is HDAdditionalReflectionData)
						{
							SetCubeReflectionData(fetchIndex, ref scaleOffset);
						}
					}
					else
					{
						SetPlanarReflectionData(fetchIndex, ref vp, ref scaleOffset);
					}
					m_lightList.envLights.Add(envLightData);
					for (int k = 0; k < hdCamera.viewCount; k++)
					{
						Matrix4x4 worldToViewMatrix = GetWorldToViewMatrix(hdCamera, k);
						LightVolumeType sortedLightVolumeType = GetSortedLightVolumeType(j);
						GetEnvLightVolumeDataAndBound(processedProbe.hdProbe, sortedLightVolumeType, worldToViewMatrix, k);
					}
					UpdateEnvLighCameraRelativetData(ref envLightData, worldSpaceCameraPos);
					int index = m_lightList.envLights.Count - 1;
					m_lightList.envLights[index] = envLightData;
				}
			}
		}

		private ProcessedProbeData GetSortedProcessedProbe(int sortIndex)
		{
			UnpackProbeSortKey(m_SortKeys[sortIndex], out var _, out var probeIndex, out var listType);
			if (listType != 0)
			{
				return m_ProcessedPlanarProbeData[probeIndex];
			}
			return m_ProcessedReflectionProbeData[probeIndex];
		}

		private LightVolumeType GetSortedLightVolumeType(int sortIndex)
		{
			UnpackProbeSortKey(m_SortKeys[sortIndex], out var lightVolumeType, out var _, out var _);
			return lightVolumeType;
		}

		private bool PrepareLightsForGPU(CommandBuffer cmd, HDCamera hdCamera, CullingResults cullResults, HDProbeCullingResults hdProbeCullingResults, DebugDisplaySettings debugDisplaySettings, AOVRequestData aovRequest)
		{
			debugDisplaySettings.GetDebugLightFilterMode();
			HDShadowManager.cachedShadowManager.AssignSlotsInAtlases();
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.PrepareLightsForGPU)))
			{
				_ = hdCamera.camera;
				ClearUnusedProcessedReferences(cullResults, hdProbeCullingResults);
				m_EnableBakeShadowMask = false;
				m_lightList.Clear();
				m_CurrentSunLight = null;
				m_CurrentSunLightDataIndex = -1;
				m_CurrentSunLightAdditionalLightData = null;
				m_CurrentShadowSortedSunLightIndex = -1;
				m_DebugSelectedLightShadowIndex = -1;
				m_DebugSelectedLightShadowCount = 0;
				int num = Math.Min(DecalSystem.m_DecalDatasCount, m_MaxDecalsOnScreen);
				m_ShadowManager.Clear();
				m_ScreenSpaceShadowIndex = 0;
				m_ScreenSpaceShadowChannelSlot = 0;
				for (int i = 0; i < m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots; i++)
				{
					m_CurrentScreenSpaceShadowData[i].additionalLightData = null;
					m_CurrentScreenSpaceShadowData[i].lightDataIndex = -1;
					m_CurrentScreenSpaceShadowData[i].valid = false;
				}
				m_GpuLightsBuilder.NewFrame(hdCamera, cullResults.visibleLights.Length + cullResults.visibleReflectionProbes.Length + hdProbeCullingResults.visibleProbes.Count + num);
				if (cullResults.visibleLights.Length != 0)
				{
					PreprocessVisibleLights(cmd, hdCamera, in cullResults, debugDisplaySettings, in aovRequest);
					if (m_RayTracingSupported)
					{
						ReserveRayTracingCookieAtlasSlots();
					}
					PrepareGPULightdata(cmd, hdCamera, cullResults);
					m_ShadowManager.PrepareGPUShadowDatas(cullResults, hdCamera);
				}
				else if (m_RayTracingSupported)
				{
					ReserveRayTracingCookieAtlasSlots();
					m_TextureCaches.lightCookieManager.LayoutIfNeeded();
				}
				if (cullResults.visibleReflectionProbes.Length != 0 || hdProbeCullingResults.visibleProbes.Count != 0)
				{
					int processedLightCount = PreprocessVisibleProbes(hdCamera, cullResults, hdProbeCullingResults, in aovRequest);
					PrepareGPUProbeData(cmd, hdCamera, cullResults, hdProbeCullingResults, processedLightCount);
				}
				if (num > 0)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < hdCamera.viewCount; k++)
						{
							m_GpuLightsBuilder.AddLightBounds(k, in DecalSystem.m_Bounds[j], in DecalSystem.m_LightVolumes[j]);
						}
					}
				}
				for (int l = 0; l < hdCamera.viewCount; l++)
				{
					Matrix4x4 worldToViewMatrix = GetWorldToViewMatrix(hdCamera, l);
					if (ShaderConfig.s_CameraRelativeRendering != 0)
					{
						worldToViewMatrix.SetColumn(3, new Vector4(0f, 0f, 0f, 1f));
					}
				}
				m_TotalLightCount = m_GpuLightsBuilder.lightsCount + m_lightList.envLights.Count + num;
				PushLightDataGlobalParams(cmd);
				PushShadowGlobalParams(cmd);
			}
			m_ProcessedLightsBuilder.Reset();
			m_TextureCaches?.reflectionProbeTextureCache?.GarbageCollectTmpResources();
			m_EnableBakeShadowMask = m_EnableBakeShadowMask && hdCamera.frameSettings.IsEnabled(FrameSettingsField.Shadowmask);
			return m_EnableBakeShadowMask;
		}

		internal void ReserveCookieAtlasTexture(HDAdditionalLightData hdLightData, Light light, HDLightType lightType)
		{
			lightType = ((light == null) ? HDLightType.Point : lightType);
			switch (lightType)
			{
			case HDLightType.Directional:
				m_TextureCaches.lightCookieManager.ReserveSpace(hdLightData.surfaceTexture);
				m_TextureCaches.lightCookieManager.ReserveSpace(light?.cookie);
				break;
			case HDLightType.Point:
				if (light?.cookie != null && hdLightData.IESPoint != null && light.cookie != hdLightData.IESPoint)
				{
					m_TextureCaches.lightCookieManager.ReserveSpaceCube(light.cookie, hdLightData.IESPoint);
				}
				else if (light?.cookie != null)
				{
					m_TextureCaches.lightCookieManager.ReserveSpaceCube(light.cookie);
				}
				else if (hdLightData.IESPoint != null)
				{
					m_TextureCaches.lightCookieManager.ReserveSpaceCube(hdLightData.IESPoint);
				}
				break;
			case HDLightType.Spot:
				if (light?.cookie != null && hdLightData.IESSpot != null && light.cookie != hdLightData.IESSpot)
				{
					m_TextureCaches.lightCookieManager.ReserveSpace(light.cookie, hdLightData.IESSpot);
				}
				else if (light?.cookie != null)
				{
					m_TextureCaches.lightCookieManager.ReserveSpace(light.cookie);
				}
				else if (hdLightData.IESSpot != null)
				{
					m_TextureCaches.lightCookieManager.ReserveSpace(hdLightData.IESSpot);
				}
				else if (hdLightData.spotLightShape != 0)
				{
					m_TextureCaches.lightCookieManager.ReserveSpace(Texture2D.whiteTexture);
				}
				break;
			case HDLightType.Area:
				if (hdLightData.areaLightShape == AreaLightShape.Rectangle)
				{
					if (hdLightData.IESSpot != null && hdLightData.areaLightCookie != null && hdLightData.IESSpot != hdLightData.areaLightCookie)
					{
						m_TextureCaches.lightCookieManager.ReserveSpace(hdLightData.areaLightCookie, hdLightData.IESSpot);
					}
					else if (hdLightData.IESSpot != null)
					{
						m_TextureCaches.lightCookieManager.ReserveSpace(hdLightData.IESSpot);
					}
					else if (hdLightData.areaLightCookie != null)
					{
						m_TextureCaches.lightCookieManager.ReserveSpace(hdLightData.areaLightCookie);
					}
				}
				break;
			}
		}

		internal static void UpdateLightCameraRelativetData(ref LightData lightData, Vector3 camPosWS)
		{
			if (ShaderConfig.s_CameraRelativeRendering != 0)
			{
				lightData.positionRWS -= camPosWS;
			}
		}

		internal static void UpdateEnvLighCameraRelativetData(ref EnvLightData envLightData, Vector3 camPosWS)
		{
			if (ShaderConfig.s_CameraRelativeRendering != 0)
			{
				envLightData.capturePositionRWS -= camPosWS;
				envLightData.influencePositionRWS -= camPosWS;
				envLightData.proxyPositionRWS -= camPosWS;
			}
		}

		private static float CalculateProbeLogVolume(Bounds bounds)
		{
			float num = 8f * bounds.extents.x * bounds.extents.y * bounds.extents.z;
			return Mathf.Clamp(Mathf.Log(1f + num, 1.05f) * 1000f, 0f, 1048575f);
		}

		private static void UnpackProbeSortKey(uint sortKey, out LightVolumeType lightVolumeType, out int probeIndex, out int listType)
		{
			lightVolumeType = (LightVolumeType)((int)(sortKey >> 9) & 3);
			probeIndex = (int)(sortKey & 0xFF);
			listType = (int)((sortKey >> 8) & 1);
		}

		private static uint PackProbeKey(float logVolume, LightVolumeType lightVolumeType, uint listType, int probeIndex)
		{
			return ((uint)logVolume << 12) | (uint)((int)lightVolumeType << 9) | (listType << 8) | ((uint)probeIndex & 0xFFu);
		}

		private HDAdditionalLightData GetHDAdditionalLightData(Light light)
		{
			HDAdditionalLightData component = null;
			if (light != null)
			{
				light.TryGetComponent<HDAdditionalLightData>(out component);
			}
			if (component == null)
			{
				component = HDUtils.s_DefaultHDAdditionalLightData;
			}
			return component;
		}

		private void UpdateShaderVariablesGlobalLightLoop(ref ShaderVariablesGlobal cb, HDCamera hdCamera)
		{
			cb._CookieAtlasSize = m_TextureCaches.lightCookieManager.GetCookieAtlasSize();
			cb._CookieAtlasData = m_TextureCaches.lightCookieManager.GetCookieAtlasDatas();
			cb._ReflectionAtlasCubeData = m_TextureCaches.reflectionProbeTextureCache.GetTextureAtlasCubeData();
			cb._ReflectionAtlasPlanarData = m_TextureCaches.reflectionProbeTextureCache.GetTextureAtlasPlanarData();
			cb._EnvSliceSize = m_TextureCaches.reflectionProbeTextureCache.GetEnvSliceSize();
			cb._PunctualLightCount = (uint)m_GpuLightsBuilder.punctualLightCount;
			cb._AreaLightCount = (uint)m_GpuLightsBuilder.areaLightCount;
			cb._EnvLightCount = (uint)m_lightList.envLights.Count;
			cb._DirectionalLightCount = (uint)m_GpuLightsBuilder.directionalLightCount;
			cb._DecalCount = (uint)DecalSystem.m_DecalDatasCount;
			bool flag = GetHDAdditionalLightData(m_CurrentSunLight) != null && m_CurrentShadowSortedSunLightIndex >= 0;
			cb._DirectionalShadowIndex = (flag ? m_CurrentShadowSortedSunLightIndex : (-1));
			cb._EnableLightLayers = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers) ? 1u : 0u);
			cb._EnableDecalLayers = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers) ? 1u : 0u);
			cb._EnvLightSkyEnabled = (m_SkyManager.IsLightingSkyValid(hdCamera) ? 1 : 0);
			double num = (1.0 - (double)Mathf.Pow(1.02f, 64f)) / -0.019999980926513672;
			cb._NumTileFtplX = (uint)GetNumTileFtplX(hdCamera);
			cb._NumTileFtplY = (uint)GetNumTileFtplY(hdCamera);
			cb.g_fClustScale = (float)(num / (double)(hdCamera.camera.farClipPlane - hdCamera.camera.nearClipPlane));
			cb.g_fClustBase = 1.02f;
			cb.g_fNearPlane = hdCamera.camera.nearClipPlane;
			cb.g_fFarPlane = hdCamera.camera.farClipPlane;
			cb.g_iLog2NumClusters = 6;
			cb.g_isLogBaseBufferEnabled = 1u;
			cb._NumTileClusteredX = (uint)GetNumTileClusteredX(hdCamera);
			cb._NumTileClusteredY = (uint)GetNumTileClusteredY(hdCamera);
			cb._EnableSSRefraction = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Refraction) ? 1u : 0u);
		}

		private void PushLightDataGlobalParams(CommandBuffer cmd)
		{
			m_LightLoopLightData.directionalLightData.SetData(m_GpuLightsBuilder.directionalLights, 0, 0, m_GpuLightsBuilder.directionalLightCount);
			m_LightLoopLightData.lightData.SetData(m_GpuLightsBuilder.lights, 0, 0, m_GpuLightsBuilder.lightsCount);
			m_LightLoopLightData.envLightData.SetData(m_lightList.envLights);
			m_LightLoopLightData.decalData.SetData(DecalSystem.m_DecalDatas, 0, 0, Math.Min(DecalSystem.m_DecalDatasCount, m_MaxDecalsOnScreen));
			for (int i = 0; i < m_GpuLightsBuilder.lightsPerViewCount; i++)
			{
				HDGpuLightsBuilder.LightsPerView lightsPerView = m_GpuLightsBuilder.lightsPerView[i];
				int boundsOffset = lightsPerView.boundsOffset;
				int computeBufferStartIndex = i * m_TotalLightCount;
				m_TileAndClusterData.convexBoundsBuffer.SetData(m_GpuLightsBuilder.lightBounds, boundsOffset, computeBufferStartIndex, lightsPerView.boundsCount);
				m_TileAndClusterData.lightVolumeDataBuffer.SetData(m_GpuLightsBuilder.lightVolumes, boundsOffset, computeBufferStartIndex, lightsPerView.boundsCount);
			}
			ConstantBuffer.PushGlobal(cmd, in m_EnvLightReflectionData, HDShaderIDs._EnvLightReflectionData);
			cmd.SetGlobalTexture(HDShaderIDs._CookieAtlas, m_TextureCaches.lightCookieManager.atlasTexture);
			cmd.SetGlobalTexture(HDShaderIDs._ReflectionAtlas, m_TextureCaches.reflectionProbeTextureCache.GetAtlasTexture());
			cmd.SetGlobalBuffer(HDShaderIDs._LightDatas, m_LightLoopLightData.lightData);
			cmd.SetGlobalBuffer(HDShaderIDs._EnvLightDatas, m_LightLoopLightData.envLightData);
			cmd.SetGlobalBuffer(HDShaderIDs._DecalDatas, m_LightLoopLightData.decalData);
			cmd.SetGlobalBuffer(HDShaderIDs._DirectionalLightDatas, m_LightLoopLightData.directionalLightData);
		}

		private void PushShadowGlobalParams(CommandBuffer cmd)
		{
			m_ShadowManager.PushGlobalParameters(cmd);
		}

		private bool WillRenderContactShadow()
		{
			if (m_EnableContactShadow)
			{
				return m_ContactShadowIndex != 0;
			}
			return false;
		}

		private void GetContactShadowMask(HDAdditionalLightData hdAdditionalLightData, BoolScalableSetting contactShadowEnabled, HDCamera hdCamera, bool isRasterization, ref int contactShadowMask, ref float rayTracingShadowFlag)
		{
			contactShadowMask = 0;
			rayTracingShadowFlag = 0f;
			if (hdAdditionalLightData.useContactShadow.Value(contactShadowEnabled) && m_ContactShadowIndex < LightDefinitions.s_ContactShadowMaskMask && isRasterization)
			{
				contactShadowMask = 1 << m_ContactShadowIndex++;
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && hdAdditionalLightData.rayTraceContactShadow)
				{
					rayTracingShadowFlag = 1f;
				}
			}
		}

		private unsafe void SetPlanarReflectionData(int index, ref Matrix4x4 vp, ref Vector4 scaleOffset)
		{
			for (int i = 0; i < 16; i++)
			{
				m_EnvLightReflectionData._PlanarCaptureVP[index * 16 + i] = vp[i];
			}
			for (int j = 0; j < 4; j++)
			{
				m_EnvLightReflectionData._PlanarScaleOffset[index * 4 + j] = scaleOffset[j];
			}
		}

		private unsafe void SetCubeReflectionData(int index, ref Vector4 scaleOffset)
		{
			for (int i = 0; i < 4; i++)
			{
				m_EnvLightReflectionData._CubeScaleOffset[index * 4 + i] = scaleOffset[i];
			}
		}

		internal void RetrieveExtraDataFromProbeVolumeBake(ProbeReferenceVolume.ExtraDataActionInput input)
		{
			HDProbe[] array = Object.FindObjectsByType<HDProbe>(FindObjectsSortMode.None);
			for (int i = 0; i < array.Length; i++)
			{
				array[i].TryUpdateLuminanceSHL2ForNormalization();
			}
		}

		private void RegisterRetrieveOfProbeVolumeExtraDataAction()
		{
			ProbeReferenceVolume.instance.retrieveExtraDataAction = null;
			ProbeReferenceVolume instance = ProbeReferenceVolume.instance;
			instance.retrieveExtraDataAction = (Action<ProbeReferenceVolume.ExtraDataActionInput>)Delegate.Combine(instance.retrieveExtraDataAction, new Action<ProbeReferenceVolume.ExtraDataActionInput>(RetrieveExtraDataFromProbeVolumeBake));
		}

		private bool IsAPVEnabled()
		{
			return m_Asset.currentPlatformRenderPipelineSettings.supportProbeVolume;
		}

		private void BindAPVRuntimeResources(CommandBuffer cmdBuffer, HDCamera hdCamera)
		{
			bool flag = true;
			ProbeReferenceVolume instance = ProbeReferenceVolume.instance;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.ProbeVolume))
			{
				ProbeReferenceVolume.RuntimeResources runtimeResources = instance.GetRuntimeResources();
				if (runtimeResources.index != null && runtimeResources.L0_L1rx != null && runtimeResources.L1_G_ry != null && runtimeResources.L1_B_rz != null)
				{
					cmdBuffer.SetGlobalBuffer(HDShaderIDs._APVResIndex, runtimeResources.index);
					cmdBuffer.SetGlobalBuffer(HDShaderIDs._APVResCellIndices, runtimeResources.cellIndices);
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL0_L1Rx, runtimeResources.L0_L1rx);
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL1G_L1Ry, runtimeResources.L1_G_ry);
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL1B_L1Rz, runtimeResources.L1_B_rz);
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResValidity, runtimeResources.Validity);
					if (instance.shBands == ProbeVolumeSHBands.SphericalHarmonicsL2)
					{
						cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_0, runtimeResources.L2_0);
						cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_1, runtimeResources.L2_1);
						cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_2, runtimeResources.L2_2);
						cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_3, runtimeResources.L2_3);
					}
					flag = false;
				}
			}
			if (flag)
			{
				if (m_EmptyIndexBuffer == null)
				{
					m_EmptyIndexBuffer = new ComputeBuffer(1, 12, ComputeBufferType.Structured);
				}
				cmdBuffer.SetGlobalBuffer(HDShaderIDs._APVResIndex, m_EmptyIndexBuffer);
				cmdBuffer.SetGlobalBuffer(HDShaderIDs._APVResCellIndices, m_EmptyIndexBuffer);
				cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL0_L1Rx, TextureXR.GetBlackTexture3D());
				cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL1G_L1Ry, TextureXR.GetBlackTexture3D());
				cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL1B_L1Rz, TextureXR.GetBlackTexture3D());
				cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResValidity, TextureXR.GetBlackTexture3D());
				if (instance.shBands == ProbeVolumeSHBands.SphericalHarmonicsL2)
				{
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_0, TextureXR.GetBlackTexture3D());
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_1, TextureXR.GetBlackTexture3D());
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_2, TextureXR.GetBlackTexture3D());
					cmdBuffer.SetGlobalTexture(HDShaderIDs._APVResL2_3, TextureXR.GetBlackTexture3D());
				}
			}
		}

		private void UpdateShaderVariablesProbeVolumes(ref ShaderVariablesGlobal cb, HDCamera hdCamera, CommandBuffer cmd)
		{
			bool flag = ProbeReferenceVolume.instance.DataHasBeenLoaded();
			float probeVolumesWeight = ProbeReferenceVolume.instance.probeVolumesWeight;
			ProbeVolumesOptions component = hdCamera.volumeStack.GetComponent<ProbeVolumesOptions>();
			cb._EnableProbeVolumes = ((hdCamera.frameSettings.IsEnabled(FrameSettingsField.ProbeVolume) && flag && probeVolumesWeight > 0f) ? 1u : 0u);
			if (cb._EnableProbeVolumes != 0)
			{
				ProbeVolumeShadingParameters parameters = default(ProbeVolumeShadingParameters);
				parameters.normalBias = component.normalBias.value;
				parameters.viewBias = component.viewBias.value;
				parameters.scaleBiasByMinDistanceBetweenProbes = component.scaleBiasWithMinProbeDistance.value;
				parameters.samplingNoise = component.samplingNoise.value;
				parameters.weight = probeVolumesWeight;
				parameters.leakReductionMode = component.leakReductionMode.value;
				parameters.occlusionWeightContribution = 1f;
				parameters.frameIndexForNoise = hdCamera.taaFrameIndex * (component.animateSamplingNoise.value ? 1 : 0);
				parameters.reflNormalizationLowerClamp = 0.005f;
				parameters.reflNormalizationUpperClamp = (component.occlusionOnlyReflectionNormalization.value ? 1f : 7f);
				parameters.minValidNormalWeight = component.minValidDotProductValue.value;
				ProbeReferenceVolume.instance.UpdateConstantBuffer(cmd, parameters);
			}
		}

		private float EvaluateSpecularOcclusionFlag(HDCamera hdCamera)
		{
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && component.rayTracing.value)
			{
				return EvaluateRTSpecularOcclusionFlag(hdCamera, component);
			}
			return 1f;
		}

		private bool IsAmbientOcclusionActive(HDCamera camera, ScreenSpaceAmbientOcclusion settings)
		{
			if (camera.frameSettings.IsEnabled(FrameSettingsField.SSAO))
			{
				return settings.intensity.value > 0f;
			}
			return false;
		}

		private RenderAOParameters PrepareRenderAOParameters(HDCamera camera, Vector2 historySize, in HDUtils.PackedMipChainInfo depthMipInfo)
		{
			RenderAOParameters result = default(RenderAOParameters);
			ref ShaderVariablesAmbientOcclusion cb = ref result.cb;
			ScreenSpaceAmbientOcclusion component = camera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			result.fullResolution = component.fullResolution;
			if (result.fullResolution)
			{
				result.runningRes = new Vector2(camera.actualWidth, camera.actualHeight);
				cb._AOBufferSize = new Vector4(camera.actualWidth, camera.actualHeight, 1f / (float)camera.actualWidth, 1f / (float)camera.actualHeight);
			}
			else
			{
				result.runningRes = new Vector2(Mathf.RoundToInt((float)camera.actualWidth * 0.5f), Mathf.RoundToInt((float)camera.actualHeight * 0.5f));
				cb._AOBufferSize = new Vector4(result.runningRes.x, result.runningRes.y, 1f / result.runningRes.x, 1f / result.runningRes.y);
			}
			result.temporalAccumulation = component.temporalAccumulation.value && camera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors);
			result.viewCount = camera.viewCount;
			result.runAsync = camera.frameSettings.SSAORunsAsync();
			float num = 0f - camera.mainViewConstants.projMatrix[1, 1];
			float num2 = result.runningRes.y / result.runningRes.x;
			uint cameraFrameCount = camera.GetCameraFrameCount();
			cb._AOParams0 = new Vector4(result.fullResolution ? 0f : 1f, result.runningRes.y * num * 0.25f, component.radius.value, component.stepCount);
			cb._AOParams1 = new Vector4(component.intensity.value, 1f / (component.radius.value * component.radius.value), cameraFrameCount / 6 % 4, cameraFrameCount % 6);
			cb._AODepthToViewParams = new Vector4(2f / (num * num2 * result.runningRes.x), 2f / (num * result.runningRes.y), 1f / (num * num2), 1f / num);
			float f = result.runningRes.x * result.runningRes.y / 518400f;
			float w = Mathf.Max(16f, (float)component.maximumRadiusInPixels * Mathf.Sqrt(f));
			cb._AOParams2 = new Vector4(historySize.x, historySize.y, 1f / ((float)component.stepCount + 1f), w);
			float num3 = (component.fullResolution ? 1f : 0.5f);
			float num4 = 1f - component.blurSharpness.value;
			float num5 = 0.25f;
			float num6 = -2.5f;
			num4 = num6 + num4 * (num5 - num6);
			float num7 = 1f - Mathf.Pow(10f, num4) * num3;
			num7 *= num7;
			float num8 = Mathf.Pow(10f, -7f);
			float z = 1f / (Mathf.Pow(10f, 0f) + num8);
			cb._AOParams3 = new Vector4(num7, num8, z, num3);
			float num9 = 1f - component.ghostingReduction.value;
			num9 = 0.25f + num9 * 4.75f;
			cb._AOParams4 = new Vector4(component.directionCount, num9, 0.25f, component.spatialBilateralAggressiveness.value * 15f);
			cb._FirstTwoDepthMipOffsets = new Vector4(depthMipInfo.mipLevelOffsets[1].x, depthMipInfo.mipLevelOffsets[1].y, depthMipInfo.mipLevelOffsets[2].x, depthMipInfo.mipLevelOffsets[2].y);
			result.bilateralUpsample = component.bilateralUpsample;
			result.temporalAccumulation = component.temporalAccumulation.value && camera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors);
			result.viewCount = camera.viewCount;
			result.runAsync = camera.frameSettings.SSAORunsAsync();
			return result;
		}

		private TextureHandle CreateAmbientOcclusionTexture(RenderGraph renderGraph, bool fullResolution)
		{
			TextureDesc desc;
			if (fullResolution)
			{
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					enableRandomWrite = true,
					colorFormat = GraphicsFormat.R8_UNorm,
					name = "Ambient Occlusion"
				};
				return renderGraph.CreateTexture(in desc);
			}
			desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
			{
				enableRandomWrite = true,
				colorFormat = GraphicsFormat.R32_SFloat,
				name = "Final Half Res AO Packed"
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle RenderAmbientOcclusion(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle motionVectors, TextureHandle historyValidityBuffer, in HDUtils.PackedMipChainInfo depthMipInfo, ShaderVariablesRaytracing shaderVariablesRaytracing, TextureHandle rayCountTexture)
		{
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			TextureHandle textureHandle;
			if (IsAmbientOcclusionActive(hdCamera, component))
			{
				using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(HDProfileId.AmbientOcclusion)))
				{
					if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && component.rayTracing.value && GetRayTracingState())
					{
						textureHandle = RenderRTAO(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVectors, historyValidityBuffer, rayCountTexture, in shaderVariablesRaytracing);
					}
					else
					{
						m_AOHistoryReady = !hdCamera.AllocateAmbientOcclusionHistoryBuffer(component.fullResolution ? 1f : 0.5f);
						RTHandle currentFrameRT = hdCamera.GetCurrentFrameRT(8);
						TextureHandle currentHistory = renderGraph.ImportTexture(currentFrameRT);
						TextureHandle outputHistory = renderGraph.ImportTexture(hdCamera.GetPreviousFrameRT(8));
						Vector2 vector = currentFrameRT.GetScaledSize();
						Vector4 rtHandleScale = hdCamera.historyRTHandleProperties.rtHandleScale;
						RenderAOParameters parameters = PrepareRenderAOParameters(hdCamera, vector * rtHandleScale, in depthMipInfo);
						textureHandle = RenderAO(renderGraph, in parameters, depthPyramid, normalBuffer);
						if (parameters.temporalAccumulation || parameters.fullResolution)
						{
							textureHandle = SpatialDenoiseAO(renderGraph, in parameters, textureHandle);
						}
						if (parameters.temporalAccumulation)
						{
							textureHandle = TemporalDenoiseAO(renderGraph, in parameters, depthPyramid, motionVectors, textureHandle, currentHistory, outputHistory);
						}
						if (!parameters.fullResolution)
						{
							textureHandle = UpsampleAO(renderGraph, in parameters, textureHandle, depthPyramid);
						}
					}
				}
			}
			else
			{
				textureHandle = renderGraph.defaultResources.blackTextureXR;
			}
			PushFullScreenDebugTexture(m_RenderGraph, textureHandle, FullScreenDebugMode.ScreenSpaceAmbientOcclusion);
			return textureHandle;
		}

		private TextureHandle RenderAO(RenderGraph renderGraph, in RenderAOParameters parameters, TextureHandle depthPyramid, TextureHandle normalBuffer)
		{
			RenderAOPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderAOPassData>("GTAO Horizon search and integration", out passData, ProfilingSampler.Get(HDProfileId.HorizonSSAO));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(parameters.runAsync);
				passData.parameters = parameters;
				passData.gtaoCS = defaultResources.shaders.GTAOCS;
				passData.gtaoCS.shaderKeywords = null;
				if (parameters.temporalAccumulation)
				{
					passData.gtaoCS.EnableKeyword("TEMPORAL");
				}
				if (parameters.fullResolution)
				{
					passData.gtaoCS.EnableKeyword("FULL_RES");
				}
				else
				{
					passData.gtaoCS.EnableKeyword("HALF_RES");
				}
				passData.gtaoKernel = passData.gtaoCS.FindKernel("GTAOMain");
				float num = (parameters.fullResolution ? 1f : 0.5f);
				RenderAOPassData renderAOPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one * num, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "AO Packed data"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				renderAOPassData.packedData = renderGraphBuilder.WriteTexture(in input);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				renderGraphBuilder.SetRenderFunc(delegate(RenderAOPassData data, RenderGraphContext ctx)
				{
					ConstantBuffer.Push(ctx.cmd, in data.parameters.cb, data.gtaoCS, HDShaderIDs._ShaderVariablesAmbientOcclusion);
					ctx.cmd.SetComputeTextureParam(data.gtaoCS, data.gtaoKernel, HDShaderIDs._AOPackedData, data.packedData);
					ctx.cmd.SetComputeTextureParam(data.gtaoCS, data.gtaoKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.gtaoCS, data.gtaoKernel, HDShaderIDs._CameraDepthTexture, data.depthPyramid);
					int threadGroupsX = ((int)data.parameters.runningRes.x + 7) / 8;
					int threadGroupsY = ((int)data.parameters.runningRes.y + 7) / 8;
					ctx.cmd.DispatchCompute(data.gtaoCS, data.gtaoKernel, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
				return passData.packedData;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle SpatialDenoiseAO(RenderGraph renderGraph, in RenderAOParameters parameters, TextureHandle aoPackedData)
		{
			SpatialDenoiseAOPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SpatialDenoiseAOPassData>("Spatial Denoise GTAO", out passData);
			try
			{
				renderGraphBuilder.EnableAsyncCompute(parameters.runAsync);
				_ = parameters.fullResolution;
				passData.parameters = parameters;
				passData.spatialDenoiseAOCS = defaultResources.shaders.GTAOSpatialDenoiseCS;
				passData.spatialDenoiseAOCS.shaderKeywords = null;
				if (parameters.temporalAccumulation)
				{
					passData.spatialDenoiseAOCS.EnableKeyword("TO_TEMPORAL");
				}
				passData.denoiseKernelSpatial = passData.spatialDenoiseAOCS.FindKernel("SpatialDenoise");
				passData.packedData = renderGraphBuilder.ReadTexture(in aoPackedData);
				if (parameters.temporalAccumulation)
				{
					SpatialDenoiseAOPassData spatialDenoiseAOPassData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one * (parameters.fullResolution ? 1f : 0.5f), dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "AO Packed blurred data"
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					spatialDenoiseAOPassData.denoiseOutput = renderGraphBuilder.WriteTexture(in input);
				}
				else
				{
					SpatialDenoiseAOPassData spatialDenoiseAOPassData2 = passData;
					TextureHandle input = CreateAmbientOcclusionTexture(renderGraph, parameters.fullResolution);
					spatialDenoiseAOPassData2.denoiseOutput = renderGraphBuilder.WriteTexture(in input);
				}
				renderGraphBuilder.SetRenderFunc(delegate(SpatialDenoiseAOPassData data, RenderGraphContext ctx)
				{
					int threadGroupsX = ((int)data.parameters.runningRes.x + 7) / 8;
					int threadGroupsY = ((int)data.parameters.runningRes.y + 7) / 8;
					ComputeShader spatialDenoiseAOCS = data.spatialDenoiseAOCS;
					ConstantBuffer.Set<ShaderVariablesAmbientOcclusion>(ctx.cmd, spatialDenoiseAOCS, HDShaderIDs._ShaderVariablesAmbientOcclusion);
					ctx.cmd.SetComputeTextureParam(spatialDenoiseAOCS, data.denoiseKernelSpatial, HDShaderIDs._AOPackedData, data.packedData);
					ctx.cmd.SetComputeTextureParam(spatialDenoiseAOCS, data.denoiseKernelSpatial, HDShaderIDs._OcclusionTexture, data.denoiseOutput);
					ctx.cmd.DispatchCompute(spatialDenoiseAOCS, data.denoiseKernelSpatial, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
				return passData.denoiseOutput;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle TemporalDenoiseAO(RenderGraph renderGraph, in RenderAOParameters parameters, TextureHandle depthTexture, TextureHandle motionVectors, TextureHandle aoPackedDataBlurred, TextureHandle currentHistory, TextureHandle outputHistory)
		{
			TemporalDenoiseAOPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TemporalDenoiseAOPassData>("Temporal Denoise GTAO", out passData);
			try
			{
				renderGraphBuilder.EnableAsyncCompute(parameters.runAsync);
				_ = parameters.fullResolution;
				passData.parameters = parameters;
				passData.temporalDenoiseAOCS = defaultResources.shaders.GTAOTemporalDenoiseCS;
				passData.temporalDenoiseAOCS.shaderKeywords = null;
				if (parameters.fullResolution)
				{
					passData.temporalDenoiseAOCS.EnableKeyword("FULL_RES");
				}
				else
				{
					passData.temporalDenoiseAOCS.EnableKeyword("HALF_RES");
				}
				passData.denoiseKernelTemporal = passData.temporalDenoiseAOCS.FindKernel("TemporalDenoise");
				passData.copyHistoryAOCS = defaultResources.shaders.GTAOCopyHistoryCS;
				passData.denoiseKernelCopyHistory = passData.copyHistoryAOCS.FindKernel("GTAODenoise_CopyHistory");
				passData.historyReady = m_AOHistoryReady;
				passData.motionVectors = renderGraphBuilder.ReadTexture(in motionVectors);
				passData.currentHistory = renderGraphBuilder.ReadTexture(in currentHistory);
				passData.outputHistory = renderGraphBuilder.WriteTexture(in outputHistory);
				passData.packedDataBlurred = renderGraphBuilder.ReadTexture(in aoPackedDataBlurred);
				TemporalDenoiseAOPassData temporalDenoiseAOPassData = passData;
				TextureHandle input = CreateAmbientOcclusionTexture(renderGraph, parameters.fullResolution);
				temporalDenoiseAOPassData.denoiseOutput = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TemporalDenoiseAOPassData data, RenderGraphContext ctx)
				{
					int threadGroupsX = ((int)data.parameters.runningRes.x + 7) / 8;
					int threadGroupsY = ((int)data.parameters.runningRes.y + 7) / 8;
					if (!data.historyReady)
					{
						ctx.cmd.SetComputeTextureParam(data.copyHistoryAOCS, data.denoiseKernelCopyHistory, HDShaderIDs._InputTexture, data.packedDataBlurred);
						ctx.cmd.SetComputeTextureParam(data.copyHistoryAOCS, data.denoiseKernelCopyHistory, HDShaderIDs._OutputTexture, data.currentHistory);
						ctx.cmd.DispatchCompute(data.copyHistoryAOCS, data.denoiseKernelCopyHistory, threadGroupsX, threadGroupsY, data.parameters.viewCount);
					}
					ComputeShader temporalDenoiseAOCS = data.temporalDenoiseAOCS;
					ConstantBuffer.Set<ShaderVariablesAmbientOcclusion>(ctx.cmd, temporalDenoiseAOCS, HDShaderIDs._ShaderVariablesAmbientOcclusion);
					ctx.cmd.SetComputeTextureParam(temporalDenoiseAOCS, data.denoiseKernelTemporal, HDShaderIDs._AOPackedBlurred, data.packedDataBlurred);
					ctx.cmd.SetComputeTextureParam(temporalDenoiseAOCS, data.denoiseKernelTemporal, HDShaderIDs._AOPackedHistory, data.currentHistory);
					ctx.cmd.SetComputeTextureParam(temporalDenoiseAOCS, data.denoiseKernelTemporal, HDShaderIDs._AOOutputHistory, data.outputHistory);
					ctx.cmd.SetComputeTextureParam(temporalDenoiseAOCS, data.denoiseKernelTemporal, HDShaderIDs._CameraMotionVectorsTexture, data.motionVectors);
					ctx.cmd.SetComputeTextureParam(temporalDenoiseAOCS, data.denoiseKernelTemporal, HDShaderIDs._OcclusionTexture, data.denoiseOutput);
					ctx.cmd.DispatchCompute(temporalDenoiseAOCS, data.denoiseKernelTemporal, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
				return passData.denoiseOutput;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle UpsampleAO(RenderGraph renderGraph, in RenderAOParameters parameters, TextureHandle input, TextureHandle depthTexture)
		{
			if (parameters.fullResolution)
			{
				return input;
			}
			UpsampleAOPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpsampleAOPassData>("Upsample GTAO", out passData, ProfilingSampler.Get(HDProfileId.UpSampleSSAO));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(parameters.runAsync);
				passData.parameters = parameters;
				passData.upsampleAndBlurAOCS = defaultResources.shaders.GTAOBlurAndUpsample;
				if (parameters.temporalAccumulation)
				{
					passData.upsampleAOKernel = passData.upsampleAndBlurAOCS.FindKernel(parameters.bilateralUpsample ? "BilateralUpsampling" : "BoxUpsampling");
				}
				else
				{
					passData.upsampleAOKernel = passData.upsampleAndBlurAOCS.FindKernel("BlurUpsample");
				}
				passData.input = renderGraphBuilder.ReadTexture(in input);
				passData.depthTexture = renderGraphBuilder.ReadTexture(in depthTexture);
				UpsampleAOPassData upsampleAOPassData = passData;
				TextureHandle input2 = CreateAmbientOcclusionTexture(renderGraph, fullResolution: true);
				upsampleAOPassData.output = renderGraphBuilder.WriteTexture(in input2);
				renderGraphBuilder.SetRenderFunc(delegate(UpsampleAOPassData data, RenderGraphContext ctx)
				{
					ConstantBuffer.Set<ShaderVariablesAmbientOcclusion>(ctx.cmd, data.upsampleAndBlurAOCS, HDShaderIDs._ShaderVariablesAmbientOcclusion);
					ctx.cmd.SetComputeTextureParam(data.upsampleAndBlurAOCS, data.upsampleAOKernel, HDShaderIDs._AOPackedData, data.input);
					ctx.cmd.SetComputeTextureParam(data.upsampleAndBlurAOCS, data.upsampleAOKernel, HDShaderIDs._OcclusionTexture, data.output);
					ctx.cmd.SetComputeTextureParam(data.upsampleAndBlurAOCS, data.upsampleAOKernel, HDShaderIDs._CameraDepthTexture, data.depthTexture);
					int threadGroupsX = ((int)data.parameters.runningRes.x + 7) / 8;
					int threadGroupsY = ((int)data.parameters.runningRes.y + 7) / 8;
					ctx.cmd.DispatchCompute(data.upsampleAndBlurAOCS, data.upsampleAOKernel, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void UpdateShaderVariableGlobalAmbientOcclusion(ref ShaderVariablesGlobal cb, HDCamera hdCamera)
		{
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			bool flag = false;
			if (IsAmbientOcclusionActive(hdCamera, component))
			{
				flag = true;
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && component.rayTracing.value && !currentPipeline.GetRayTracingState())
				{
					flag = false;
				}
			}
			if (flag)
			{
				cb._AmbientOcclusionParam = new Vector4(0f, 0f, 0f, component.directLightingStrength.value);
			}
			else
			{
				cb._AmbientOcclusionParam = Vector4.zero;
			}
		}

		private void InitScreenSpaceGlobalIllumination()
		{
			if (m_Asset.currentPlatformRenderPipelineSettings.supportSSGI)
			{
				ComputeShader screenSpaceGlobalIlluminationCS = m_Asset.renderPipelineResources.shaders.screenSpaceGlobalIlluminationCS;
				ComputeShader bilateralUpsampleCS = m_Asset.renderPipelineResources.shaders.bilateralUpsampleCS;
				m_TraceGlobalIlluminationKernel = screenSpaceGlobalIlluminationCS.FindKernel("TraceGlobalIllumination");
				m_TraceGlobalIlluminationHalfKernel = screenSpaceGlobalIlluminationCS.FindKernel("TraceGlobalIlluminationHalf");
				m_ReprojectGlobalIlluminationKernel = screenSpaceGlobalIlluminationCS.FindKernel("ReprojectGlobalIllumination");
				m_ReprojectGlobalIlluminationHalfKernel = screenSpaceGlobalIlluminationCS.FindKernel("ReprojectGlobalIlluminationHalf");
				m_BilateralUpSampleColorKernel = bilateralUpsampleCS.FindKernel("BilateralUpSampleColor");
			}
		}

		private IndirectDiffuseMode GetIndirectDiffuseMode(HDCamera hdCamera)
		{
			IndirectDiffuseMode result = IndirectDiffuseMode.Off;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SSGI))
			{
				GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
				if (component.enable.value)
				{
					bool flag = hdCamera.colorPyramidHistoryIsValid && !hdCamera.isFirstFrame;
					result = ((!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) || component.tracing.value == RayCastingMode.RayMarching || !GetRayTracingState()) ? (flag ? IndirectDiffuseMode.ScreenSpace : IndirectDiffuseMode.Off) : ((component.tracing.value == RayCastingMode.RayTracing) ? IndirectDiffuseMode.RayTraced : IndirectDiffuseMode.Mixed));
				}
			}
			return result;
		}

		private int CombineIndirectDiffuseHistoryStateToMask(bool fullResolution, bool rayTraced)
		{
			return 0 | (fullResolution ? 1 : 0) | (rayTraced ? 2 : 0);
		}

		private float EvaluateIndirectDiffuseHistoryValidityCombined(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			float num = ((hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination0, flagMask) && hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination1, flagMask)) ? 1f : 0f);
			return EvaluateHistoryValidity(hdCamera) * num;
		}

		private float EvaluateIndirectDiffuseHistoryValidity0(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			float num = (hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination0, flagMask) ? 1f : 0f);
			return EvaluateHistoryValidity(hdCamera) * num;
		}

		private float EvaluateIndirectDiffuseHistoryValidity1(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			float num = (hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination1, flagMask) ? 1f : 0f);
			return EvaluateHistoryValidity(hdCamera) * num;
		}

		private void PropagateIndirectDiffuseHistoryValidityCombined(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination0, flagMask);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination1, flagMask);
		}

		private void PropagateIndirectDiffuseHistoryValidity0(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination0, flagMask);
		}

		private void PropagateIndirectDiffuseHistoryValidity1(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineIndirectDiffuseHistoryStateToMask(fullResolution, rayTraced);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.GlobalIllumination1, flagMask);
		}

		private TextureHandle TraceSSGI(RenderGraph renderGraph, HDCamera hdCamera, GlobalIllumination giSettings, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle stencilBuffer, TextureHandle motionVectorsBuffer, ComputeBufferHandle lightList)
		{
			TraceSSGIPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TraceSSGIPassData>("Trace SSGI", out passData, ProfilingSampler.Get(HDProfileId.SSGITrace));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				if (giSettings.fullResolutionSS.value)
				{
					passData.texWidth = hdCamera.actualWidth;
					passData.texHeight = hdCamera.actualHeight;
					passData.halfScreenSize.Set((float)passData.texWidth * 0.5f, (float)passData.texHeight * 0.5f, 2f / (float)passData.texWidth, 2f / (float)passData.texHeight);
				}
				else
				{
					passData.texWidth = hdCamera.actualWidth / 2;
					passData.texHeight = hdCamera.actualHeight / 2;
					passData.halfScreenSize.Set(passData.texWidth, passData.texHeight, 1f / (float)passData.texWidth, 1f / (float)passData.texHeight);
				}
				passData.viewCount = hdCamera.viewCount;
				passData.nearClipPlane = hdCamera.camera.nearClipPlane;
				passData.farClipPlane = hdCamera.camera.farClipPlane;
				passData.fullResolutionSS = true;
				passData.thickness = giSettings.depthBufferThickness.value;
				passData.raySteps = giSettings.maxRaySteps;
				passData.frameIndex = RayTracingFrameIndex(hdCamera, 16);
				passData.colorPyramidUvScaleAndLimitPrevFrame = HDUtils.ComputeViewportScaleAndLimit(hdCamera.historyRTHandleProperties.previousViewportSize, hdCamera.historyRTHandleProperties.previousRenderTargetSize);
				passData.rayMiss = (int)giSettings.rayMiss.value;
				passData.ssGICS = asset.renderPipelineResources.shaders.screenSpaceGlobalIlluminationCS;
				passData.traceKernel = (giSettings.fullResolutionSS.value ? m_TraceGlobalIlluminationKernel : m_TraceGlobalIlluminationHalfKernel);
				passData.projectKernel = (giSettings.fullResolutionSS.value ? m_ReprojectGlobalIlluminationKernel : m_ReprojectGlobalIlluminationHalfKernel);
				BlueNoise blueNoiseManager = GetBlueNoiseManager();
				passData.ditheredTextureSet = blueNoiseManager.DitheredTextureSet8SPP();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.offsetBuffer = hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer);
				passData.lightList = renderGraphBuilder.ReadComputeBuffer(in lightList);
				passData.depthTexture = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.stencilBuffer = renderGraphBuilder.ReadTexture(in stencilBuffer);
				TextureHandle input;
				if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.ObjectMotionVectors))
				{
					TraceSSGIPassData traceSSGIPassData = passData;
					input = renderGraph.defaultResources.blackTextureXR;
					traceSSGIPassData.motionVectorsBuffer = renderGraphBuilder.ReadTexture(in input);
				}
				else
				{
					passData.motionVectorsBuffer = renderGraphBuilder.ReadTexture(in motionVectorsBuffer);
				}
				RTHandle previousFrameRT = hdCamera.GetPreviousFrameRT(0);
				TraceSSGIPassData traceSSGIPassData2 = passData;
				TextureHandle colorPyramid;
				if (previousFrameRT == null)
				{
					colorPyramid = renderGraph.defaultResources.blackTextureXR;
				}
				else
				{
					input = renderGraph.ImportTexture(previousFrameRT);
					colorPyramid = renderGraphBuilder.ReadTexture(in input);
				}
				traceSSGIPassData2.colorPyramid = colorPyramid;
				RTHandle currentFrameRT = hdCamera.GetCurrentFrameRT(6);
				TraceSSGIPassData traceSSGIPassData3 = passData;
				TextureHandle historyDepth;
				if (currentFrameRT == null)
				{
					historyDepth = renderGraph.defaultResources.blackTextureXR;
				}
				else
				{
					input = renderGraph.ImportTexture(currentFrameRT);
					historyDepth = renderGraphBuilder.ReadTexture(in input);
				}
				traceSSGIPassData3.historyDepth = historyDepth;
				TraceSSGIPassData traceSSGIPassData4 = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16_SFloat,
					enableRandomWrite = true,
					name = "SSGI Hit Point"
				};
				traceSSGIPassData4.hitPointBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceSSGIPassData traceSSGIPassData5 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
					enableRandomWrite = true,
					name = "SSGI Color"
				};
				input = renderGraph.CreateTexture(in desc);
				traceSSGIPassData5.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TraceSSGIPassData data, RenderGraphContext ctx)
				{
					int num = 8;
					int threadGroupsX = (data.texWidth + (num - 1)) / num;
					int threadGroupsY = (data.texHeight + (num - 1)) / num;
					float nearClipPlane = data.nearClipPlane;
					float farClipPlane = data.farClipPlane;
					float num2 = 1f / (1f + data.thickness);
					float val = (0f - nearClipPlane) / (farClipPlane - nearClipPlane) * (data.thickness * num2);
					ctx.cmd.SetComputeFloatParam(data.ssGICS, HDShaderIDs._RayMarchingThicknessScale, num2);
					ctx.cmd.SetComputeFloatParam(data.ssGICS, HDShaderIDs._RayMarchingThicknessBias, val);
					ctx.cmd.SetComputeIntParam(data.ssGICS, HDShaderIDs._RayMarchingSteps, data.raySteps);
					ctx.cmd.SetComputeIntParam(data.ssGICS, HDShaderIDs._RayMarchingReflectSky, 1);
					ctx.cmd.SetComputeIntParam(data.ssGICS, HDShaderIDs._IndirectDiffuseFrameIndex, data.frameIndex);
					if (!data.fullResolutionSS)
					{
						ctx.cmd.SetComputeVectorParam(data.ssGICS, HDShaderIDs._HalfScreenSize, data.halfScreenSize);
					}
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.traceKernel, HDShaderIDs._DepthTexture, data.depthTexture);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.traceKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.traceKernel, HDShaderIDs._IndirectDiffuseHitPointTextureRW, data.hitPointBuffer);
					ctx.cmd.SetComputeBufferParam(data.ssGICS, data.traceKernel, HDShaderIDs._DepthPyramidMipLevelOffsets, data.offsetBuffer);
					ctx.cmd.SetComputeBufferParam(data.ssGICS, data.traceKernel, HDShaderIDs.g_vLightListTile, data.lightList);
					ctx.cmd.DispatchCompute(data.ssGICS, data.traceKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetComputeVectorParam(data.ssGICS, HDShaderIDs._ColorPyramidUvScaleAndLimitPrevFrame, data.colorPyramidUvScaleAndLimitPrevFrame);
					ctx.cmd.SetComputeIntParam(data.ssGICS, HDShaderIDs._ObjectMotionStencilBit, 32);
					ctx.cmd.SetComputeIntParam(data.ssGICS, HDShaderIDs._RayMarchingFallbackHierarchy, data.rayMiss);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._DepthTexture, data.depthTexture);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._StencilTexture, data.stencilBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._CameraMotionVectorsTexture, data.motionVectorsBuffer);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._IndirectDiffuseHitPointTexture, data.hitPointBuffer);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._ColorPyramidTexture, data.colorPyramid);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._HistoryDepthTexture, data.historyDepth);
					ctx.cmd.SetComputeBufferParam(data.ssGICS, data.projectKernel, HDShaderIDs._DepthPyramidMipLevelOffsets, data.offsetBuffer);
					ctx.cmd.SetComputeBufferParam(data.ssGICS, data.projectKernel, HDShaderIDs.g_vLightListTile, data.lightList);
					ctx.cmd.SetComputeTextureParam(data.ssGICS, data.projectKernel, HDShaderIDs._IndirectDiffuseTextureRW, data.outputBuffer);
					ctx.cmd.DispatchCompute(data.ssGICS, data.projectKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private unsafe TextureHandle UpscaleSSGI(RenderGraph renderGraph, HDCamera hdCamera, GlobalIllumination giSettings, HDUtils.PackedMipChainInfo info, TextureHandle depthPyramid, TextureHandle inputBuffer)
		{
			UpscaleSSGIPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpscaleSSGIPassData>("Upscale SSGI", out passData, ProfilingSampler.Get(HDProfileId.SSGIUpscale));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.shaderVariablesBilateralUpsampleCB._HalfScreenSize = new Vector4(passData.texWidth / 2, passData.texHeight / 2, 1f / ((float)passData.texWidth * 0.5f), 1f / ((float)passData.texHeight * 0.5f));
				for (int i = 0; i < 16; i++)
				{
					passData.shaderVariablesBilateralUpsampleCB._DistanceBasedWeights[i] = BilateralUpsample.distanceBasedWeights_2x2[i];
				}
				for (int j = 0; j < 32; j++)
				{
					passData.shaderVariablesBilateralUpsampleCB._TapOffsets[j] = BilateralUpsample.tapOffsets_2x2[j];
				}
				passData.bilateralUpsampleCS = m_Asset.renderPipelineResources.shaders.bilateralUpsampleCS;
				passData.upscaleKernel = m_BilateralUpSampleColorKernel;
				passData.depthTexture = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.inputBuffer = renderGraphBuilder.ReadTexture(in inputBuffer);
				UpscaleSSGIPassData upscaleSSGIPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
					enableRandomWrite = true,
					name = "SSGI Final"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				upscaleSSGIPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(UpscaleSSGIPassData data, RenderGraphContext ctx)
				{
					int num = 8;
					int threadGroupsX = (data.texWidth + (num - 1)) / num;
					int threadGroupsY = (data.texHeight + (num - 1)) / num;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesBilateralUpsampleCB, HDShaderIDs._ShaderVariablesBilateralUpsample);
					ctx.cmd.SetComputeTextureParam(data.bilateralUpsampleCS, data.upscaleKernel, HDShaderIDs._DepthTexture, data.depthTexture);
					ctx.cmd.SetComputeTextureParam(data.bilateralUpsampleCS, data.upscaleKernel, HDShaderIDs._LowResolutionTexture, data.inputBuffer);
					ctx.cmd.SetComputeTextureParam(data.bilateralUpsampleCS, data.upscaleKernel, HDShaderIDs._OutputUpscaledTexture, data.outputBuffer);
					ctx.cmd.DispatchCompute(data.bilateralUpsampleCS, data.upscaleKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle DenoiseSSGI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle rtGIBuffer, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle motionVectorBuffer, TextureHandle historyValidationTexture, bool fullResolution)
		{
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			if (component.denoiseSS)
			{
				float historyValidity = EvaluateIndirectDiffuseHistoryValidity0(hdCamera, fullResolution, rayTraced: false);
				HDTemporalFilter temporalFilter = GetTemporalFilter();
				HDDiffuseDenoiser diffuseDenoiser = GetDiffuseDenoiser();
				TextureHandle historyBuffer = renderGraph.ImportTexture(RequestIndirectDiffuseHistoryTextureHF(hdCamera));
				HDTemporalFilter.TemporalFilterParameters filterParams = default(HDTemporalFilter.TemporalFilterParameters);
				filterParams.singleChannel = false;
				filterParams.historyValidity = historyValidity;
				filterParams.occluderMotionRejection = false;
				filterParams.receiverMotionRejection = false;
				filterParams.exposureControl = true;
				filterParams.fullResolution = fullResolution;
				TextureHandle noisyBuffer = temporalFilter.Denoise(renderGraph, hdCamera, filterParams, rtGIBuffer, renderGraph.defaultResources.blackTextureXR, historyBuffer, depthPyramid, normalBuffer, motionVectorBuffer, historyValidationTexture);
				HDDiffuseDenoiser.DiffuseDenoiserParameters denoiserParams = default(HDDiffuseDenoiser.DiffuseDenoiserParameters);
				denoiserParams.singleChannel = false;
				denoiserParams.kernelSize = component.denoiserRadiusSS;
				denoiserParams.halfResolutionFilter = component.halfResolutionDenoiserSS;
				denoiserParams.jitterFilter = component.secondDenoiserPassSS;
				denoiserParams.fullResolutionInput = fullResolution;
				rtGIBuffer = diffuseDenoiser.Denoise(renderGraph, hdCamera, denoiserParams, noisyBuffer, depthPyramid, normalBuffer, rtGIBuffer);
				if (component.secondDenoiserPassSS)
				{
					float historyValidity2 = EvaluateIndirectDiffuseHistoryValidity1(hdCamera, fullResolution, rayTraced: false);
					TextureHandle historyBuffer2 = renderGraph.ImportTexture(RequestIndirectDiffuseHistoryTextureLF(hdCamera));
					filterParams.singleChannel = false;
					filterParams.historyValidity = historyValidity2;
					filterParams.occluderMotionRejection = false;
					filterParams.receiverMotionRejection = false;
					filterParams.exposureControl = true;
					filterParams.fullResolution = fullResolution;
					noisyBuffer = temporalFilter.Denoise(renderGraph, hdCamera, filterParams, rtGIBuffer, renderGraph.defaultResources.blackTextureXR, historyBuffer2, depthPyramid, normalBuffer, motionVectorBuffer, historyValidationTexture);
					denoiserParams.singleChannel = false;
					denoiserParams.kernelSize = component.denoiserRadiusSS * 0.5f;
					denoiserParams.halfResolutionFilter = component.halfResolutionDenoiserSS;
					denoiserParams.jitterFilter = false;
					denoiserParams.fullResolutionInput = fullResolution;
					rtGIBuffer = diffuseDenoiser.Denoise(renderGraph, hdCamera, denoiserParams, noisyBuffer, depthPyramid, normalBuffer, rtGIBuffer);
					PropagateIndirectDiffuseHistoryValidity1(hdCamera, fullResolution, rayTraced: false);
				}
				PropagateIndirectDiffuseHistoryValidity0(hdCamera, fullResolution, rayTraced: false);
				return rtGIBuffer;
			}
			return rtGIBuffer;
		}

		private TextureHandle RenderSSGI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthPyramid, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidationTexture, ShaderVariablesRaytracing shaderVariablesRayTracingCB, HDUtils.PackedMipChainInfo info, ComputeBufferHandle lightList)
		{
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(HDProfileId.SSGIPass)))
			{
				TextureHandle textureHandle = TraceSSGI(renderGraph, hdCamera, component, depthPyramid, normalBuffer, depthStencilBuffer, motionVectorsBuffer, lightList);
				TextureHandle inputBuffer = DenoiseSSGI(renderGraph, hdCamera, textureHandle, depthStencilBuffer, normalBuffer, motionVectorsBuffer, historyValidationTexture, component.fullResolutionSS.value);
				if (!component.fullResolutionSS.value)
				{
					textureHandle = UpscaleSSGI(renderGraph, hdCamera, component, info, depthPyramid, inputBuffer);
				}
				return textureHandle;
			}
		}

		private TextureHandle RenderScreenSpaceIndirectDiffuse(HDCamera hdCamera, in PrepassOutput prepassOutput, TextureHandle rayCountTexture, TextureHandle historyValidationTexture, ComputeBufferHandle lightList)
		{
			TextureHandle textureHandle;
			switch (GetIndirectDiffuseMode(hdCamera))
			{
			case IndirectDiffuseMode.ScreenSpace:
				textureHandle = RenderSSGI(m_RenderGraph, hdCamera, prepassOutput.depthPyramidTexture, prepassOutput.depthBuffer, prepassOutput.normalBuffer, prepassOutput.resolvedMotionVectorsBuffer, historyValidationTexture, m_ShaderVariablesRayTracingCB, hdCamera.depthBufferMipChainInfo, lightList);
				break;
			case IndirectDiffuseMode.RayTraced:
			case IndirectDiffuseMode.Mixed:
				textureHandle = RenderRayTracedIndirectDiffuse(m_RenderGraph, hdCamera, in prepassOutput, historyValidationTexture, m_SkyManager.GetSkyReflection(hdCamera), rayCountTexture, m_ShaderVariablesRayTracingCB);
				break;
			default:
				textureHandle = m_RenderGraph.defaultResources.blackTextureXR;
				break;
			}
			PushFullScreenDebugTexture(m_RenderGraph, textureHandle, FullScreenDebugMode.ScreenSpaceGlobalIllumination);
			return textureHandle;
		}

		private static RTHandle ShadowHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			int num = Math.Max((int)Math.Ceiling((float)(RenderPipelineManager.currentPipeline as HDRenderPipeline).m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots / 4f), 1);
			return rtHandleSystem.Alloc(Vector2.one, num * TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_ScreenSpaceShadowHistoryBuffer{frameIndex}");
		}

		private static RTHandle ShadowHistoryValidityBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			int num = Math.Max((int)Math.Ceiling((float)(RenderPipelineManager.currentPipeline as HDRenderPipeline).m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots / 4f), 1);
			return rtHandleSystem.Alloc(Vector2.one, num * TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_ShadowHistoryValidityBuffer{frameIndex}");
		}

		private static RTHandle ShadowHistoryDistanceBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			int num = Math.Max((int)Math.Ceiling((float)(RenderPipelineManager.currentPipeline as HDRenderPipeline).m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots / 4f), 1);
			return rtHandleSystem.Alloc(Vector2.one, num * TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_ShadowHistoryDistanceBuffer{frameIndex}");
		}

		private RTHandle RequestShadowHistoryBuffer(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(10) ?? hdCamera.AllocHistoryFrameRT(10, ShadowHistoryBufferAllocatorFunction, 1);
		}

		private RTHandle RequestShadowHistoryValidityBuffer(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(11) ?? hdCamera.AllocHistoryFrameRT(11, ShadowHistoryValidityBufferAllocatorFunction, 1);
		}

		private RTHandle RequestShadowHistoryDistanceBuffer(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(12) ?? hdCamera.AllocHistoryFrameRT(12, ShadowHistoryDistanceBufferAllocatorFunction, 1);
		}

		private static void GetShadowChannelMask(int shadowSlot, ScreenSpaceShadowType shadowType, ref Vector4 outputMask)
		{
			int num = shadowSlot % 4;
			switch (shadowType)
			{
			case ScreenSpaceShadowType.GrayScale:
				switch (num)
				{
				case 0:
					outputMask.Set(1f, 0f, 0f, 0f);
					break;
				case 1:
					outputMask.Set(0f, 1f, 0f, 0f);
					break;
				case 2:
					outputMask.Set(0f, 0f, 1f, 0f);
					break;
				case 3:
					outputMask.Set(0f, 0f, 0f, 1f);
					break;
				}
				break;
			case ScreenSpaceShadowType.Area:
				switch (num)
				{
				case 0:
					outputMask.Set(1f, 1f, 0f, 0f);
					break;
				case 1:
					outputMask.Set(0f, 1f, 1f, 0f);
					break;
				case 2:
					outputMask.Set(0f, 0f, 1f, 1f);
					break;
				}
				break;
			case ScreenSpaceShadowType.Color:
				if (num == 0)
				{
					outputMask.Set(1f, 1f, 1f, 0f);
				}
				break;
			}
		}

		private void InitializeScreenSpaceShadows()
		{
			if (m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.supportScreenSpaceShadows)
			{
				if (m_RayTracingSupported)
				{
					m_ScreenSpaceShadowsCS = m_GlobalSettings.renderPipelineRayTracingResources.shadowRaytracingCS;
					m_ScreenSpaceShadowsFilterCS = m_GlobalSettings.renderPipelineRayTracingResources.shadowFilterCS;
					m_ScreenSpaceShadowsRT = m_GlobalSettings.renderPipelineRayTracingResources.shadowRaytracingRT;
					m_ClearShadowTexture = m_ScreenSpaceShadowsCS.FindKernel("ClearShadowTexture");
					m_OutputShadowTextureKernel = m_ScreenSpaceShadowsCS.FindKernel("OutputShadowTexture");
					m_OutputColorShadowTextureKernel = m_ScreenSpaceShadowsCS.FindKernel("OutputColorShadowTexture");
					m_OutputSpecularShadowTextureKernel = m_ScreenSpaceShadowsCS.FindKernel("OutputSpecularShadowTexture");
					m_RaytracingDirectionalShadowSample = m_ScreenSpaceShadowsCS.FindKernel("RaytracingDirectionalShadowSample");
					m_RaytracingPointShadowSample = m_ScreenSpaceShadowsCS.FindKernel("RaytracingPointShadowSample");
					m_RaytracingSpotShadowSample = m_ScreenSpaceShadowsCS.FindKernel("RaytracingSpotShadowSample");
					m_AreaRaytracingShadowPrepassKernel = m_ScreenSpaceShadowsCS.FindKernel("RaytracingAreaShadowPrepass");
					m_AreaRaytracingShadowNewSampleKernel = m_ScreenSpaceShadowsCS.FindKernel("RaytracingAreaShadowNewSample");
					m_AreaShadowApplyTAAKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowApplyTAA");
					m_AreaUpdateAnalyticHistoryKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaAnalyticHistoryCopy");
					m_AreaUpdateShadowHistoryKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowHistoryCopy");
					m_AreaEstimateNoiseKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowEstimateNoise");
					m_AreaFirstDenoiseKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowDenoiseFirstPass");
					m_AreaSecondDenoiseKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowDenoiseSecondPass");
					m_AreaShadowNoDenoiseKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("AreaShadowNoDenoise");
					m_WriteShadowTextureDebugKernel = m_ScreenSpaceShadowsFilterCS.FindKernel("WriteShadowTextureDebug");
				}
				s_ScreenSpaceShadowsMat = CoreUtils.CreateEngineMaterial(screenSpaceShadowsShader);
				switch (m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.shadowFilteringQuality)
				{
				case HDShadowFilteringQuality.Low:
					s_ScreenSpaceShadowsMat.EnableKeyword("SHADOW_LOW");
					break;
				case HDShadowFilteringQuality.Medium:
					s_ScreenSpaceShadowsMat.EnableKeyword("SHADOW_MEDIUM");
					break;
				case HDShadowFilteringQuality.High:
					s_ScreenSpaceShadowsMat.EnableKeyword("SHADOW_HIGH");
					break;
				default:
					s_ScreenSpaceShadowsMat.EnableKeyword("SHADOW_MEDIUM");
					break;
				}
				switch (m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.areaShadowFilteringQuality)
				{
				case HDAreaShadowFilteringQuality.Medium:
					s_ScreenSpaceShadowsMat.EnableKeyword("AREA_SHADOW_MEDIUM");
					break;
				case HDAreaShadowFilteringQuality.High:
					s_ScreenSpaceShadowsMat.EnableKeyword("AREA_SHADOW_HIGH");
					break;
				default:
					s_ScreenSpaceShadowsMat.EnableKeyword("AREA_SHADOW_MEDIUM");
					break;
				}
			}
		}

		private void ReleaseScreenSpaceShadows()
		{
			CoreUtils.Destroy(s_ScreenSpaceShadowsMat);
		}

		internal TextureHandle CreateScreenSpaceShadowTextureArray(RenderGraph renderGraph)
		{
			int num = Math.Max((int)Math.Ceiling((float)m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots / 4f), 1);
			GraphicsFormat screenSpaceShadowBufferFormat = (GraphicsFormat)m_Asset.currentPlatformRenderPipelineSettings.hdShadowInitParams.screenSpaceShadowBufferFormat;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = screenSpaceShadowBufferFormat,
				slices = num * TextureXR.slices,
				dimension = TextureDimension.Tex2DArray,
				filterMode = FilterMode.Point,
				enableRandomWrite = true,
				useMipMap = false,
				name = "ScreenSpaceShadowArrayBuffer"
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle EvaluateShadowDebugView(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle screenSpaceShadowArray)
		{
			if (!rayTracingSupported || m_ScreenSpaceShadowChannelSlot <= m_CurrentDebugDisplaySettings.data.screenSpaceShadowIndex)
			{
				return m_RenderGraph.defaultResources.blackTextureXR;
			}
			ScreenSpaceShadowDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ScreenSpaceShadowDebugPassData>("Screen Space Shadows Debug", out passData, ProfilingSampler.Get(HDProfileId.ScreenSpaceShadowsDebug));
			try
			{
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.targetShadow = (int)m_CurrentDebugDisplaySettings.data.screenSpaceShadowIndex;
				passData.debugKernel = m_WriteShadowTextureDebugKernel;
				passData.shadowFilter = m_GlobalSettings.renderPipelineRayTracingResources.shadowFilterCS;
				passData.screenSpaceShadowArray = renderGraphBuilder.ReadTexture(in screenSpaceShadowArray);
				ScreenSpaceShadowDebugPassData screenSpaceShadowDebugPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "EvaluateShadowDebug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				screenSpaceShadowDebugPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ScreenSpaceShadowDebugPassData data, RenderGraphContext ctx)
				{
					int num = 8;
					int threadGroupsX = (data.texWidth + (num - 1)) / num;
					int threadGroupsY = (data.texHeight + (num - 1)) / num;
					ctx.cmd.SetComputeIntParam(data.shadowFilter, HDShaderIDs._DenoisingHistorySlot, data.targetShadow);
					ctx.cmd.SetComputeTextureParam(data.shadowFilter, data.debugKernel, HDShaderIDs._ScreenSpaceShadowsTextureRW, data.screenSpaceShadowArray);
					ctx.cmd.SetComputeTextureParam(data.shadowFilter, data.debugKernel, HDShaderIDs._DenoiseOutputTextureRW, data.outputBuffer);
					ctx.cmd.DispatchCompute(data.shadowFilter, data.debugKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void WriteScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle shadowTexture, TextureHandle screenSpaceShadowArray, int shadowIndex, ScreenSpaceShadowType shadowType)
		{
			WriteScreenSpaceShadowPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<WriteScreenSpaceShadowPassData>("Write Screen Space Shadows", out passData, ProfilingSampler.Get(HDProfileId.RaytracingWriteShadow));
			passData.texWidth = hdCamera.actualWidth;
			passData.texHeight = hdCamera.actualHeight;
			passData.viewCount = hdCamera.viewCount;
			GetShadowChannelMask(shadowIndex, shadowType, ref passData.shadowChannelMask);
			if (shadowType == ScreenSpaceShadowType.Area)
			{
				GetShadowChannelMask(shadowIndex, ScreenSpaceShadowType.GrayScale, ref passData.shadowChannelMask0);
				GetShadowChannelMask(shadowIndex + 1, ScreenSpaceShadowType.GrayScale, ref passData.shadowChannelMask1);
			}
			passData.shadowSlot = shadowIndex;
			switch (shadowType)
			{
			case ScreenSpaceShadowType.GrayScale:
				passData.shadowKernel = m_OutputShadowTextureKernel;
				break;
			case ScreenSpaceShadowType.Area:
				passData.shadowKernel = m_OutputSpecularShadowTextureKernel;
				break;
			case ScreenSpaceShadowType.Color:
				passData.shadowKernel = m_OutputColorShadowTextureKernel;
				break;
			}
			passData.screenSpaceShadowCS = m_ScreenSpaceShadowsCS;
			passData.inputShadowBuffer = renderGraphBuilder.ReadTexture(in shadowTexture);
			passData.outputShadowArrayBuffer = renderGraphBuilder.ReadWriteTexture(in screenSpaceShadowArray);
			renderGraphBuilder.SetRenderFunc(delegate(WriteScreenSpaceShadowPassData data, RenderGraphContext ctx)
			{
				int num = 8;
				int threadGroupsX = (data.texWidth + (num - 1)) / num;
				int threadGroupsY = (data.texHeight + (num - 1)) / num;
				ctx.cmd.SetComputeIntParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingShadowSlot, data.shadowSlot / 4);
				ctx.cmd.SetComputeVectorParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingChannelMask, data.shadowChannelMask);
				ctx.cmd.SetComputeVectorParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingChannelMask0, data.shadowChannelMask0);
				ctx.cmd.SetComputeVectorParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingChannelMask1, data.shadowChannelMask1);
				ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.inputShadowBuffer);
				ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._ScreenSpaceShadowsTextureRW, data.outputShadowArrayBuffer);
				ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.shadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
			});
		}

		private bool RenderLightScreenSpaceShadows(RenderGraph renderGraph, HDCamera hdCamera, PrepassOutput prepassOutput, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidityBuffer, TextureHandle rayCountTexture, TextureHandle screenSpaceShadowArray)
		{
			for (int i = 0; i < m_ScreenSpaceShadowIndex; i++)
			{
				if (m_CurrentScreenSpaceShadowData[i].valid)
				{
					LightData lightData = m_GpuLightsBuilder.lights[m_CurrentScreenSpaceShadowData[i].lightDataIndex];
					HDAdditionalLightData additionalLightData = m_CurrentScreenSpaceShadowData[i].additionalLightData;
					switch (lightData.lightType)
					{
					case GPULightType.Rectangle:
						RenderAreaScreenSpaceShadow(renderGraph, hdCamera, in lightData, additionalLightData, m_CurrentScreenSpaceShadowData[i].lightDataIndex, prepassOutput, depthBuffer, normalBuffer, motionVectorsBuffer, rayCountTexture, screenSpaceShadowArray);
						break;
					case GPULightType.Point:
					case GPULightType.Spot:
						RenderPunctualScreenSpaceShadow(renderGraph, hdCamera, in lightData, additionalLightData, m_CurrentScreenSpaceShadowData[i].lightDataIndex, prepassOutput, depthBuffer, normalBuffer, motionVectorsBuffer, historyValidityBuffer, rayCountTexture, screenSpaceShadowArray);
						break;
					}
				}
			}
			return true;
		}

		private bool RequestedScreenSpaceShadows()
		{
			bool flag = m_CurrentSunLightAdditionalLightData != null && (m_CurrentSunShadowMapFlags & HDProcessedVisibleLightsBuilder.ShadowMapFlags.WillRenderScreenSpaceShadow) != 0;
			bool flag2 = false;
			for (int i = 0; i < m_ScreenSpaceShadowIndex; i++)
			{
				if (m_CurrentScreenSpaceShadowData[i].valid)
				{
					flag2 = true;
					break;
				}
			}
			return flag || flag2;
		}

		private TextureHandle RenderScreenSpaceShadows(RenderGraph renderGraph, HDCamera hdCamera, PrepassOutput prepassOutput, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidityBuffer, TextureHandle rayCountTexture)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.ScreenSpaceShadows) || !RequestedScreenSpaceShadows())
			{
				PushFullScreenDebugTexture(m_RenderGraph, m_RenderGraph.defaultResources.whiteTextureXR, FullScreenDebugMode.ScreenSpaceShadows);
				return m_RenderGraph.defaultResources.blackTextureArrayXR;
			}
			using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(HDProfileId.ScreenSpaceShadows)))
			{
				TextureHandle textureHandle = CreateScreenSpaceShadowTextureArray(renderGraph);
				RenderDirectionalLightScreenSpaceShadow(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVectorsBuffer, historyValidityBuffer, rayCountTexture, textureHandle);
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && GetRayTracingState())
				{
					RenderLightScreenSpaceShadows(renderGraph, hdCamera, prepassOutput, depthBuffer, normalBuffer, motionVectorsBuffer, historyValidityBuffer, rayCountTexture, textureHandle);
				}
				TextureHandle input = EvaluateShadowDebugView(renderGraph, hdCamera, textureHandle);
				PushFullScreenDebugTexture(m_RenderGraph, input, FullScreenDebugMode.ScreenSpaceShadows);
				return textureHandle;
			}
		}

		private static void ExecuteSSSAreaRayTrace(CommandBuffer cmd, RTShadowAreaPassData data)
		{
			BlueNoise.BindDitheredTextureSet(cmd, data.ditheredTextureSet);
			int num = 8;
			int threadGroupsX = (data.texWidth + (num - 1)) / num;
			int threadGroupsY = (data.texHeight + (num - 1)) / num;
			cmd.SetComputeMatrixParam(data.screenSpaceShadowsCS, HDShaderIDs._RaytracingAreaWorldToLocal, data.worldToLocalMatrix);
			cmd.SetComputeIntParam(data.screenSpaceShadowsCS, HDShaderIDs._RaytracingTargetLight, data.lightIndex);
			data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.numSamples;
			ConstantBuffer.PushGlobal(cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._GBufferTexture[0], data.gbuffer0);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._GBufferTexture[1], data.gbuffer1);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._GBufferTexture[2], data.gbuffer2);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._GBufferTexture[3], data.gbuffer3);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._RaytracedAreaShadowIntegration, data.outputShadowTexture);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._RaytracedAreaShadowSample, data.intermediateBufferRGBA1);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
			cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
			cmd.DispatchCompute(data.screenSpaceShadowsCS, data.areaRaytracingShadowPrepassKernel, threadGroupsX, threadGroupsY, data.viewCount);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
			cmd.SetRayTracingAccelerationStructure(data.screenSpaceShadowsRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
			cmd.SetRayTracingShaderPass(data.screenSpaceShadowsRT, "VisibilityDXR");
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracedAreaShadowSample, data.intermediateBufferRGBA1);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
			cmd.SetRayTracingIntParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracingTargetLight, data.lightIndex);
			cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracedAreaShadowIntegration, data.outputShadowTexture);
			cmd.DispatchRays(data.screenSpaceShadowsRT, "RayGenAreaShadowSingle", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
			for (int i = 1; i < data.numSamples; i++)
			{
				data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.numSamples;
				data.shaderVariablesRayTracingCB._RaytracingSampleIndex = i;
				ConstantBuffer.PushGlobal(cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
				cmd.SetComputeIntParam(data.screenSpaceShadowsCS, HDShaderIDs._RaytracingTargetLight, data.lightIndex);
				cmd.SetComputeMatrixParam(data.screenSpaceShadowsCS, HDShaderIDs._RaytracingAreaWorldToLocal, data.worldToLocalMatrix);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._GBufferTexture[0], data.gbuffer0);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._GBufferTexture[1], data.gbuffer1);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._GBufferTexture[2], data.gbuffer2);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._GBufferTexture[3], data.gbuffer3);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._RaytracedAreaShadowSample, data.intermediateBufferRGBA1);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
				cmd.DispatchCompute(data.screenSpaceShadowsCS, data.areaRaytracingShadowNewSampleKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracedAreaShadowSample, data.intermediateBufferRGBA1);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
				cmd.SetRayTracingIntParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracingTargetLight, data.lightIndex);
				cmd.SetRayTracingTextureParam(data.screenSpaceShadowsRT, HDShaderIDs._RaytracedAreaShadowIntegration, data.outputShadowTexture);
				cmd.DispatchRays(data.screenSpaceShadowsRT, "RayGenAreaShadowSingle", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
			}
			if (data.filterTracedShadow)
			{
				Vector4 outputMask = default(Vector4);
				Vector4 outputMask2 = default(Vector4);
				Vector4 outputMask3 = default(Vector4);
				GetShadowChannelMask(data.areaShadowSlot, ScreenSpaceShadowType.Area, ref outputMask);
				GetShadowChannelMask(data.areaShadowSlot, ScreenSpaceShadowType.GrayScale, ref outputMask2);
				GetShadowChannelMask(data.areaShadowSlot + 1, ScreenSpaceShadowType.GrayScale, ref outputMask3);
				cmd.SetComputeIntParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._RaytracingDenoiseRadius, data.filterSize);
				cmd.SetComputeIntParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._DenoisingHistorySlice, data.areaShadowSlot / 4);
				cmd.SetComputeVectorParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._DenoisingHistoryMask, outputMask);
				cmd.SetComputeVectorParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._DenoisingHistoryMaskSn, outputMask2);
				cmd.SetComputeVectorParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._DenoisingHistoryMaskUn, outputMask3);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._CameraMotionVectorsTexture, data.motionVectorsBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._AreaShadowHistory, data.shadowHistoryArray);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._AnalyticHistoryBuffer, data.analyticHistoryArray);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._DenoiseInputTexture, data.outputShadowTexture);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, HDShaderIDs._DenoiseOutputTextureRW, data.intermediateBufferRGBA1);
				cmd.SetComputeFloatParam(data.screenSpaceShadowsFilterCS, HDShaderIDs._HistoryValidity, data.historyValidity);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaShadowApplyTAAKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaUpdateAnalyticHistoryKernel, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaUpdateAnalyticHistoryKernel, HDShaderIDs._AnalyticHistoryBufferRW, data.analyticHistoryArray);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaUpdateAnalyticHistoryKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaUpdateShadowHistoryKernel, HDShaderIDs._DenoiseInputTexture, data.intermediateBufferRGBA1);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaUpdateShadowHistoryKernel, HDShaderIDs._AreaShadowHistoryRW, data.shadowHistoryArray);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaUpdateShadowHistoryKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, HDShaderIDs._ScramblingTexture, data.scramblingTex);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, HDShaderIDs._DenoiseInputTexture, data.intermediateBufferRGBA1);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, HDShaderIDs._DenoiseOutputTextureRW, data.outputShadowTexture);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaEstimateNoiseKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaFirstDenoiseKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaFirstDenoiseKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaFirstDenoiseKernel, HDShaderIDs._DenoiseInputTexture, data.outputShadowTexture);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaFirstDenoiseKernel, HDShaderIDs._DenoiseOutputTextureRW, data.intermediateBufferRGBA1);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaFirstDenoiseKernel, threadGroupsX, threadGroupsY, data.viewCount);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaSecondDenoiseKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaSecondDenoiseKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaSecondDenoiseKernel, HDShaderIDs._DenoiseInputTexture, data.intermediateBufferRGBA1);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaSecondDenoiseKernel, HDShaderIDs._DenoiseOutputTextureRW, data.outputShadowTexture);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaSecondDenoiseKernel, threadGroupsX, threadGroupsY, data.viewCount);
			}
			else
			{
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowNoDenoiseKernel, HDShaderIDs._AnalyticProbBuffer, data.intermediateBufferRG0);
				cmd.SetComputeTextureParam(data.screenSpaceShadowsFilterCS, data.areaShadowNoDenoiseKernel, HDShaderIDs._DenoiseOutputTextureRW, data.outputShadowTexture);
				cmd.DispatchCompute(data.screenSpaceShadowsFilterCS, data.areaShadowNoDenoiseKernel, threadGroupsX, threadGroupsY, data.viewCount);
			}
		}

		private void RenderAreaScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, in LightData lightData, HDAdditionalLightData additionalLightData, int lightIndex, PrepassOutput prepassOutput, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle rayCountTexture, TextureHandle screenSpaceShadowArray)
		{
			RTHandle rt = RequestShadowHistoryBuffer(hdCamera);
			RTHandle rt2 = RequestShadowHistoryValidityBuffer(hdCamera);
			RTShadowAreaPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RTShadowAreaPassData>("Screen Space Shadows Debug", out passData, ProfilingSampler.Get(HDProfileId.RaytracingAreaLightShadow));
			TextureHandle outputShadowTexture;
			try
			{
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.numSamples = additionalLightData.numRayTracingSamples;
				passData.lightIndex = lightIndex;
				passData.worldToLocalMatrix.SetColumn(0, lightData.right);
				passData.worldToLocalMatrix.SetColumn(1, lightData.up);
				passData.worldToLocalMatrix.SetColumn(2, lightData.forward);
				Vector3 positionRWS = lightData.positionRWS;
				passData.worldToLocalMatrix.SetColumn(3, positionRWS);
				passData.worldToLocalMatrix.m33 = 1f;
				passData.worldToLocalMatrix = passData.worldToLocalMatrix.inverse;
				passData.historyValidity = EvaluateHistoryValidity(hdCamera);
				passData.filterTracedShadow = additionalLightData.filterTracedShadow;
				passData.areaShadowSlot = m_GpuLightsBuilder.lights[lightIndex].screenSpaceShadowIndex;
				passData.filterSize = additionalLightData.filterSizeTraced;
				passData.areaRaytracingShadowPrepassKernel = m_AreaRaytracingShadowPrepassKernel;
				passData.areaRaytracingShadowNewSampleKernel = m_AreaRaytracingShadowNewSampleKernel;
				passData.areaShadowApplyTAAKernel = m_AreaShadowApplyTAAKernel;
				passData.areaUpdateAnalyticHistoryKernel = m_AreaUpdateAnalyticHistoryKernel;
				passData.areaUpdateShadowHistoryKernel = m_AreaUpdateShadowHistoryKernel;
				passData.areaEstimateNoiseKernel = m_AreaEstimateNoiseKernel;
				passData.areaFirstDenoiseKernel = m_AreaFirstDenoiseKernel;
				passData.areaSecondDenoiseKernel = m_AreaSecondDenoiseKernel;
				passData.areaShadowNoDenoiseKernel = m_AreaShadowNoDenoiseKernel;
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.screenSpaceShadowsCS = m_ScreenSpaceShadowsCS;
				passData.screenSpaceShadowsRT = m_ScreenSpaceShadowsRT;
				passData.screenSpaceShadowsFilterCS = m_ScreenSpaceShadowsFilterCS;
				passData.scramblingTex = m_Asset.renderPipelineResources.textures.scramblingTex;
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.motionVectorsBuffer = renderGraphBuilder.ReadTexture(in motionVectorsBuffer);
				TextureHandle input;
				if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred)
				{
					passData.gbuffer0 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[0]);
					passData.gbuffer1 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[1]);
					passData.gbuffer2 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[2]);
					passData.gbuffer3 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[3]);
				}
				else
				{
					RTShadowAreaPassData rTShadowAreaPassData = passData;
					input = renderGraph.defaultResources.blackTextureXR;
					rTShadowAreaPassData.gbuffer0 = renderGraphBuilder.ReadTexture(in input);
					RTShadowAreaPassData rTShadowAreaPassData2 = passData;
					input = renderGraph.defaultResources.blackTextureXR;
					rTShadowAreaPassData2.gbuffer1 = renderGraphBuilder.ReadTexture(in input);
					RTShadowAreaPassData rTShadowAreaPassData3 = passData;
					input = renderGraph.defaultResources.blackTextureXR;
					rTShadowAreaPassData3.gbuffer2 = renderGraphBuilder.ReadTexture(in input);
					RTShadowAreaPassData rTShadowAreaPassData4 = passData;
					input = renderGraph.defaultResources.blackTextureXR;
					rTShadowAreaPassData4.gbuffer3 = renderGraphBuilder.ReadTexture(in input);
				}
				RTShadowAreaPassData rTShadowAreaPassData5 = passData;
				input = renderGraph.ImportTexture(rt);
				rTShadowAreaPassData5.shadowHistoryArray = renderGraphBuilder.ReadWriteTexture(in input);
				RTShadowAreaPassData rTShadowAreaPassData6 = passData;
				input = renderGraph.ImportTexture(rt2);
				rTShadowAreaPassData6.analyticHistoryArray = renderGraphBuilder.ReadWriteTexture(in input);
				RTShadowAreaPassData rTShadowAreaPassData7 = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Direction Buffer"
				};
				rTShadowAreaPassData7.directionBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				RTShadowAreaPassData rTShadowAreaPassData8 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Ray Length Buffer"
				};
				rTShadowAreaPassData8.rayLengthBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				RTShadowAreaPassData rTShadowAreaPassData9 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Buffer RGBA1"
				};
				rTShadowAreaPassData9.intermediateBufferRGBA1 = renderGraphBuilder.CreateTransientTexture(in desc);
				RTShadowAreaPassData rTShadowAreaPassData10 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Buffer RG0"
				};
				rTShadowAreaPassData10.intermediateBufferRG0 = renderGraphBuilder.CreateTransientTexture(in desc);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				RTShadowAreaPassData rTShadowAreaPassData11 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Shadow Buffer"
				};
				input = renderGraph.CreateTexture(in desc);
				rTShadowAreaPassData11.outputShadowTexture = renderGraphBuilder.ReadWriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RTShadowAreaPassData data, RenderGraphContext context)
				{
					ExecuteSSSAreaRayTrace(context.cmd, data);
				});
				outputShadowTexture = passData.outputShadowTexture;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			int screenSpaceShadowIndex = m_GpuLightsBuilder.lights[lightIndex].screenSpaceShadowIndex;
			WriteScreenSpaceShadow(renderGraph, hdCamera, outputShadowTexture, screenSpaceShadowArray, screenSpaceShadowIndex, ScreenSpaceShadowType.Area);
			if (additionalLightData.filterTracedShadow)
			{
				hdCamera.PropagateShadowHistory(additionalLightData, screenSpaceShadowIndex, GPULightType.Rectangle);
			}
		}

		private static float EvaluateHistoryValidityDirectionalShadow(HDCamera hdCamera, int dirShadowIndex, HDAdditionalLightData additionalLightData)
		{
			float num = 1f;
			if (hdCamera.shadowHistoryUsage[dirShadowIndex].transform != additionalLightData.transform.localToWorldMatrix || !hdCamera.ValidShadowHistory(additionalLightData, dirShadowIndex, GPULightType.Directional))
			{
				num = 0f;
			}
			return num * EvaluateHistoryValidity(hdCamera);
		}

		private TextureHandle DenoiseDirectionalScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVetorsBuffer, TextureHandle historyValidityBuffer, TextureHandle noisyBuffer, TextureHandle velocityBuffer, TextureHandle distanceBuffer)
		{
			int num = m_CurrentSunLightDirectionalLightData.screenSpaceShadowIndex & (int)LightDefinitions.s_ScreenSpaceShadowIndexMask;
			float historyValidity = EvaluateHistoryValidityDirectionalShadow(hdCamera, num, m_CurrentSunLightAdditionalLightData);
			RTHandle historyBuffer = RequestShadowHistoryBuffer(hdCamera);
			RTHandle distanceHistorySignal = RequestShadowHistoryDistanceBuffer(hdCamera);
			RTHandle validationHistoryBuffer = RequestShadowHistoryValidityBuffer(hdCamera);
			GetShadowChannelMask(num, m_CurrentSunLightAdditionalLightData.colorShadow ? ScreenSpaceShadowType.Color : ScreenSpaceShadowType.GrayScale, ref m_ShadowChannelMask0);
			GetShadowChannelMask(num, ScreenSpaceShadowType.GrayScale, ref m_ShadowChannelMask1);
			HDTemporalFilter.TemporalDenoiserArrayOutputData temporalDenoiserArrayOutputData = GetTemporalFilter().DenoiseBuffer(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVetorsBuffer, historyValidityBuffer, noisyBuffer, historyBuffer, distanceBuffer, distanceHistorySignal, velocityBuffer, validationHistoryBuffer, num / 4, m_ShadowChannelMask0, m_ShadowChannelMask1, distanceBased: true, !m_CurrentSunLightAdditionalLightData.colorShadow, historyValidity);
			TextureHandle result = GetDiffuseShadowDenoiser().DenoiseBufferDirectional(renderGraph, hdCamera, depthBuffer, normalBuffer, temporalDenoiserArrayOutputData.outputSignal, temporalDenoiserArrayOutputData.outputSignalDistance, m_CurrentSunLightAdditionalLightData.filterSizeTraced, m_CurrentSunLightAdditionalLightData.angularDiameter * 0.5f, !m_CurrentSunLightAdditionalLightData.colorShadow);
			hdCamera.PropagateShadowHistory(m_CurrentSunLightAdditionalLightData, num, GPULightType.Directional);
			return result;
		}

		private void RenderRayTracedDirectionalScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVetorsBuffer, TextureHandle historyValidityBuffer, TextureHandle rayCountTexture, TextureHandle screenSpaceShadowArray)
		{
			bool flag = (double)m_CurrentSunLightAdditionalLightData.angularDiameter > 0.0;
			RTSDirectionalTracePassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RTSDirectionalTracePassData>("Directional RT Shadow", out passData, ProfilingSampler.Get(HDProfileId.RaytracingDirectionalLightShadow));
			TextureHandle textureHandle;
			TextureHandle velocityBuffer;
			TextureHandle distanceBuffer;
			try
			{
				RayTracingSettings component = hdCamera.volumeStack.GetComponent<RayTracingSettings>();
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.softShadow = flag;
				passData.numShadowSamples = ((!passData.softShadow) ? 1 : m_CurrentSunLightAdditionalLightData.numRayTracingSamples);
				passData.colorShadow = m_CurrentSunLightAdditionalLightData.colorShadow;
				passData.maxShadowLength = component.directionalShadowRayLength.value;
				passData.clearShadowKernel = m_ClearShadowTexture;
				passData.directionalShadowSample = m_RaytracingDirectionalShadowSample;
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.screenSpaceShadowCS = m_ScreenSpaceShadowsCS;
				passData.screenSpaceShadowRT = m_ScreenSpaceShadowsRT;
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				RTSDirectionalTracePassData rTSDirectionalTracePassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Direction Buffer"
				};
				rTSDirectionalTracePassData.directionBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				RTSDirectionalTracePassData rTSDirectionalTracePassData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8_SNorm,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "Velocity Buffer"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				rTSDirectionalTracePassData2.velocityBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				RTSDirectionalTracePassData rTSDirectionalTracePassData3 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "Distance Buffer"
				};
				input = renderGraph.CreateTexture(in desc);
				rTSDirectionalTracePassData3.distanceBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				RTSDirectionalTracePassData rTSDirectionalTracePassData4 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "RT Directional Shadow"
				};
				input = renderGraph.CreateTexture(in desc);
				rTSDirectionalTracePassData4.outputShadowBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RTSDirectionalTracePassData data, RenderGraphContext ctx)
				{
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					int num = 8;
					int threadGroupsX = (data.texWidth + (num - 1)) / num;
					int threadGroupsY = (data.texHeight + (num - 1)) / num;
					ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.outputShadowBuffer);
					ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.velocityBuffer);
					ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.distanceBuffer);
					ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ctx.cmd.SetRayTracingAccelerationStructure(data.screenSpaceShadowRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					CoreUtils.SetKeyword(ctx.cmd, "TRANSPARENT_COLOR_SHADOW", data.colorShadow);
					string rayGenName = (data.colorShadow ? "RayGenDirectionalColorShadowSingle" : "RayGenDirectionalShadowSingle");
					for (int i = 0; i < data.numShadowSamples; i++)
					{
						data.shaderVariablesRayTracingCB._RaytracingSampleIndex = i;
						data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.numShadowSamples;
						ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.directionalShadowSample, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.directionalShadowSample, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.directionalShadowSample, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.directionalShadowSample, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
						ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.directionalShadowSample, threadGroupsX, threadGroupsY, data.viewCount);
						ctx.cmd.SetRayTracingShaderPass(data.screenSpaceShadowRT, "VisibilityDXR");
						ctx.cmd.SetRayTracingFloatParam(data.screenSpaceShadowRT, HDShaderIDs._DirectionalMaxRayLength, data.maxShadowLength);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, data.colorShadow ? HDShaderIDs._RaytracedColorShadowIntegration : HDShaderIDs._RaytracedShadowIntegration, data.outputShadowBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._VelocityBuffer, data.velocityBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RaytracingDistanceBufferRW, data.distanceBuffer);
						ctx.cmd.DispatchRays(data.screenSpaceShadowRT, rayGenName, (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
					}
					CoreUtils.SetKeyword(ctx.cmd, "TRANSPARENT_COLOR_SHADOW", state: false);
				});
				textureHandle = passData.outputShadowBuffer;
				velocityBuffer = passData.velocityBuffer;
				distanceBuffer = passData.distanceBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			if (m_CurrentSunLightAdditionalLightData.filterTracedShadow && flag)
			{
				textureHandle = DenoiseDirectionalScreenSpaceShadow(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVetorsBuffer, historyValidityBuffer, textureHandle, velocityBuffer, distanceBuffer);
			}
			int shadowIndex = m_CurrentSunLightDirectionalLightData.screenSpaceShadowIndex & (int)LightDefinitions.s_ScreenSpaceShadowIndexMask;
			ScreenSpaceShadowType shadowType = (m_CurrentSunLightAdditionalLightData.colorShadow ? ScreenSpaceShadowType.Color : ScreenSpaceShadowType.GrayScale);
			WriteScreenSpaceShadow(renderGraph, hdCamera, textureHandle, screenSpaceShadowArray, shadowIndex, shadowType);
		}

		private void RenderDirectionalLightScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidityBuffer, TextureHandle rayCountTexture, TextureHandle screenSpaceShadowArray)
		{
			if (!(m_CurrentSunLightAdditionalLightData != null) || (m_CurrentSunShadowMapFlags & HDProcessedVisibleLightsBuilder.ShadowMapFlags.WillRenderScreenSpaceShadow) == 0)
			{
				return;
			}
			if ((m_CurrentSunShadowMapFlags & HDProcessedVisibleLightsBuilder.ShadowMapFlags.WillRenderRayTracedShadow) != 0 && GetRayTracingState())
			{
				RenderRayTracedDirectionalScreenSpaceShadow(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVectorsBuffer, historyValidityBuffer, rayCountTexture, screenSpaceShadowArray);
				return;
			}
			SSSDirectionalTracePassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SSSDirectionalTracePassData>("Directional RT Shadow", out passData, ProfilingSampler.Get(HDProfileId.RaytracingDirectionalLightShadow));
			passData.depthSlice = m_CurrentSunLightDirectionalLightData.screenSpaceShadowIndex;
			passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
			passData.screenSpaceShadowArray = renderGraphBuilder.ReadWriteTexture(in screenSpaceShadowArray);
			renderGraphBuilder.SetRenderFunc(delegate(SSSDirectionalTracePassData data, RenderGraphContext ctx)
			{
				MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				CoreUtils.SetRenderTarget(ctx.cmd, data.screenSpaceShadowArray, ClearFlag.None, 0, CubemapFace.Unknown, data.depthSlice);
				tempMaterialPropertyBlock.SetTexture(HDShaderIDs._NormalBufferTexture, data.normalBuffer);
				HDUtils.DrawFullScreen(ctx.cmd, s_ScreenSpaceShadowsMat, data.screenSpaceShadowArray, tempMaterialPropertyBlock);
			});
		}

		private static float EvaluateHistoryValidityPointShadow(HDCamera hdCamera, LightData lightData, HDAdditionalLightData additionalLightData)
		{
			float num = 1f;
			if (hdCamera.shadowHistoryUsage[lightData.screenSpaceShadowIndex].transform != additionalLightData.transform.localToWorldMatrix || !hdCamera.ValidShadowHistory(additionalLightData, lightData.screenSpaceShadowIndex, lightData.lightType))
			{
				num = 0f;
			}
			return num * EvaluateHistoryValidity(hdCamera);
		}

		private TextureHandle DenoisePunctualScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, HDAdditionalLightData additionalLightData, in LightData lightData, PunctualShadowProperties properties, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVetorsBuffer, TextureHandle historyValidityBuffer, TextureHandle noisyBuffer, TextureHandle velocityBuffer, TextureHandle distanceBufferI)
		{
			float historyValidity = EvaluateHistoryValidityPointShadow(hdCamera, lightData, additionalLightData);
			GetShadowChannelMask(lightData.screenSpaceShadowIndex, ScreenSpaceShadowType.GrayScale, ref m_ShadowChannelMask0);
			HDTemporalFilter temporalFilter = GetTemporalFilter();
			RTHandle distanceHistorySignal = null;
			TextureHandle distanceBuffer = default(TextureHandle);
			if (additionalLightData.distanceBasedFiltering)
			{
				distanceBuffer = distanceBufferI;
				distanceHistorySignal = RequestShadowHistoryDistanceBuffer(hdCamera);
			}
			RTHandle historyBuffer = RequestShadowHistoryBuffer(hdCamera);
			RTHandle validationHistoryBuffer = RequestShadowHistoryValidityBuffer(hdCamera);
			HDTemporalFilter.TemporalDenoiserArrayOutputData temporalDenoiserArrayOutputData = temporalFilter.DenoiseBuffer(renderGraph, hdCamera, depthBuffer, normalBuffer, motionVetorsBuffer, historyValidityBuffer, noisyBuffer, historyBuffer, distanceBuffer, distanceHistorySignal, velocityBuffer, validationHistoryBuffer, lightData.screenSpaceShadowIndex / 4, m_ShadowChannelMask0, m_ShadowChannelMask0, additionalLightData.distanceBasedFiltering, singleChannel: true, historyValidity);
			TextureHandle result = GetDiffuseShadowDenoiser().DenoiseBufferSphere(renderGraph, hdCamera, depthBuffer, normalBuffer, temporalDenoiserArrayOutputData.outputSignal, temporalDenoiserArrayOutputData.outputSignalDistance, properties);
			hdCamera.PropagateShadowHistory(additionalLightData, lightData.screenSpaceShadowIndex, lightData.lightType);
			return result;
		}

		private void RenderPunctualScreenSpaceShadow(RenderGraph renderGraph, HDCamera hdCamera, in LightData lightData, HDAdditionalLightData additionalLightData, int lightIndex, PrepassOutput prepassOutput, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidityBuffer, TextureHandle rayCountTexture, TextureHandle screenSpaceShadowArray)
		{
			PunctualShadowProperties properties = default(PunctualShadowProperties);
			properties.isSpot = lightData.lightType == GPULightType.Spot;
			properties.lightIndex = lightIndex;
			properties.softShadow = (double)additionalLightData.shapeRadius > 0.0;
			properties.lightRadius = additionalLightData.shapeRadius;
			properties.lightPosition = additionalLightData.transform.position;
			properties.kernelSize = additionalLightData.filterSizeTraced;
			properties.lightConeAngle = additionalLightData.legacyLight.spotAngle * MathF.PI / 180f;
			properties.distanceBasedDenoiser = additionalLightData.distanceBasedFiltering;
			RTSPunctualTracePassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RTSPunctualTracePassData>("Punctual RT Shadow", out passData, ProfilingSampler.Get(HDProfileId.RaytracingLightShadow));
			TextureHandle textureHandle;
			TextureHandle velocityBuffer;
			TextureHandle distanceBuffer;
			try
			{
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.numShadowSamples = ((!properties.softShadow) ? 1 : additionalLightData.numRayTracingSamples);
				passData.distanceBasedFiltering = additionalLightData.distanceBasedFiltering;
				passData.semiTransparentShadow = additionalLightData.semiTransparentShadow;
				passData.lightType = lightData.lightType;
				passData.properties = properties;
				passData.clearShadowKernel = m_ClearShadowTexture;
				passData.shadowKernel = ((lightData.lightType == GPULightType.Point) ? m_RaytracingPointShadowSample : m_RaytracingSpotShadowSample);
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.screenSpaceShadowCS = m_ScreenSpaceShadowsCS;
				passData.screenSpaceShadowRT = m_ScreenSpaceShadowsRT;
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				RTSPunctualTracePassData rTSPunctualTracePassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Direction Buffer"
				};
				rTSPunctualTracePassData.directionBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				RTSPunctualTracePassData rTSPunctualTracePassData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Ray Length Buffer"
				};
				rTSPunctualTracePassData2.rayLengthBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				RTSPunctualTracePassData rTSPunctualTracePassData3 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8_SNorm,
					enableRandomWrite = true,
					name = "Velocity Buffer"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				rTSPunctualTracePassData3.velocityBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				RTSPunctualTracePassData rTSPunctualTracePassData4 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Distance Buffer"
				};
				input = renderGraph.CreateTexture(in desc);
				rTSPunctualTracePassData4.distanceBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				RTSPunctualTracePassData rTSPunctualTracePassData5 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "RT Sphere Shadow"
				};
				input = renderGraph.CreateTexture(in desc);
				rTSPunctualTracePassData5.outputShadowBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RTSPunctualTracePassData data, RenderGraphContext ctx)
				{
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					int num = 8;
					int threadGroupsX = (data.texWidth + (num - 1)) / num;
					int threadGroupsY = (data.texHeight + (num - 1)) / num;
					ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.outputShadowBuffer);
					ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.velocityBuffer);
					ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					if (data.distanceBasedFiltering)
					{
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.clearShadowKernel, HDShaderIDs._RaytracedShadowIntegration, data.distanceBuffer);
						ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.clearShadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
					}
					ctx.cmd.SetRayTracingAccelerationStructure(data.screenSpaceShadowRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					ctx.cmd.SetRayTracingShaderPass(data.screenSpaceShadowRT, "VisibilityDXR");
					ctx.cmd.SetComputeIntParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingTargetLight, data.properties.lightIndex);
					ctx.cmd.SetComputeFloatParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingLightRadius, data.properties.lightRadius);
					ctx.cmd.SetComputeFloatParam(data.screenSpaceShadowCS, HDShaderIDs._RaytracingLightAngle, data.properties.lightConeAngle);
					for (int i = 0; i < data.numShadowSamples; i++)
					{
						data.shaderVariablesRayTracingCB._RaytracingSampleIndex = i;
						data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.numShadowSamples;
						ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
						ctx.cmd.SetComputeTextureParam(data.screenSpaceShadowCS, data.shadowKernel, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
						ctx.cmd.DispatchCompute(data.screenSpaceShadowCS, data.shadowKernel, threadGroupsX, threadGroupsY, data.viewCount);
						ctx.cmd.SetRayTracingShaderPass(data.screenSpaceShadowRT, "VisibilityDXR");
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RayTracingLengthBuffer, data.rayLengthBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RaytracedShadowIntegration, data.outputShadowBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._VelocityBuffer, data.velocityBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.screenSpaceShadowRT, HDShaderIDs._RaytracingDistanceBufferRW, data.distanceBuffer);
						CoreUtils.SetKeyword(ctx.cmd, "TRANSPARENT_COLOR_SHADOW", data.semiTransparentShadow);
						ctx.cmd.DispatchRays(data.screenSpaceShadowRT, data.semiTransparentShadow ? "RayGenSemiTransparentShadowSegmentSingle" : "RayGenShadowSegmentSingle", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
						CoreUtils.SetKeyword(ctx.cmd, "TRANSPARENT_COLOR_SHADOW", state: false);
					}
				});
				textureHandle = passData.outputShadowBuffer;
				velocityBuffer = passData.velocityBuffer;
				distanceBuffer = passData.distanceBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			if (additionalLightData.filterTracedShadow && properties.softShadow)
			{
				textureHandle = DenoisePunctualScreenSpaceShadow(renderGraph, hdCamera, additionalLightData, in lightData, properties, depthBuffer, normalBuffer, motionVectorsBuffer, historyValidityBuffer, textureHandle, velocityBuffer, distanceBuffer);
			}
			WriteScreenSpaceShadow(renderGraph, hdCamera, textureHandle, screenSpaceShadowArray, lightData.screenSpaceShadowIndex, ScreenSpaceShadowType.GrayScale);
		}

		private void InitializeVolumetricClouds()
		{
			m_ActiveVolumetricClouds = m_Asset.currentPlatformRenderPipelineSettings.supportVolumetricClouds;
			if (m_ActiveVolumetricClouds)
			{
				m_PhaseZHClouds = default(ZonalHarmonicsL2);
				m_PhaseZHClouds.coeffs = new float[3];
				ComputeShader volumetricCloudsCS = m_Asset.renderPipelineResources.shaders.volumetricCloudsCS;
				m_ConvertObliqueDepthKernel = volumetricCloudsCS.FindKernel("ConvertObliqueDepth");
				m_CloudDownscaleDepthKernel = volumetricCloudsCS.FindKernel("DownscaleDepth");
				m_CloudRenderKernel = volumetricCloudsCS.FindKernel("RenderClouds");
				m_ReprojectCloudsKernel = volumetricCloudsCS.FindKernel("ReprojectClouds");
				m_ReprojectCloudsRejectionKernel = volumetricCloudsCS.FindKernel("ReprojectCloudsRejection");
				m_PreUpscaleCloudsKernel = volumetricCloudsCS.FindKernel("PreUpscaleClouds");
				m_PreUpscaleCloudsSkyKernel = volumetricCloudsCS.FindKernel("PreUpscaleCloudsSky");
				m_UpscaleAndCombineCloudsKernelColorCopy = volumetricCloudsCS.FindKernel("UpscaleAndCombineClouds_ColorCopy");
				m_UpscaleAndCombineCloudsKernelColorRW = volumetricCloudsCS.FindKernel("UpscaleAndCombineClouds_ColorRW");
				m_UpscaleAndCombineCloudsSkyKernel = volumetricCloudsCS.FindKernel("UpscaleAndCombineCloudsSky");
				m_CombineCloudsKernelColorCopy = volumetricCloudsCS.FindKernel("CombineClouds_ColorCopy");
				m_CombineCloudsKernelColorRW = volumetricCloudsCS.FindKernel("CombineClouds_ColorRW");
				m_CombineCloudsSkyKernel = volumetricCloudsCS.FindKernel("CombineCloudsSky");
				m_CloudCombinePass = CoreUtils.CreateEngineMaterial(defaultResources.shaders.volumetricCloudsCombinePS);
				AllocatePresetTextures();
				volumetricCloudsAnimationData.lastTime = -1f;
				volumetricCloudsAnimationData.cloudOffset = new Vector2(0f, 0f);
				volumetricCloudsAnimationData.verticalShapeOffset = 0f;
				volumetricCloudsAnimationData.verticalErosionOffset = 0f;
				InitializeVolumetricCloudsMap();
				InitializeVolumetricCloudsShadows();
				InitializeVolumetricCloudsAmbientProbe();
			}
		}

		private void ReleaseVolumetricClouds()
		{
			if (m_ActiveVolumetricClouds)
			{
				CoreUtils.Destroy(m_CloudCombinePass);
				ReleaseVolumetricCloudsMap();
				ReleaseVolumetricCloudsShadows();
				ReleaseVolumetricCloudsAmbientProbe();
			}
		}

		private void AllocatePresetTextures()
		{
			m_CustomPresetMap = new Texture2D(1, 1, GraphicsFormat.R8G8B8A8_UNorm, TextureCreationFlags.None)
			{
				name = "Default Cloud Map Texture"
			};
			m_CustomPresetMap.SetPixel(0, 0, new Color(0.9f, 0f, 0.25f, 1f));
			m_CustomPresetMap.Apply();
		}

		private float Square(float x)
		{
			return x * x;
		}

		private float ComputeNormalizationFactor(float earthRadius, float lowerCloudRadius)
		{
			return Mathf.Sqrt((6378100f + lowerCloudRadius) * (6378100f + lowerCloudRadius) - 6378100f * earthRadius);
		}

		private void GetPresetCloudMapValues(VolumetricClouds.CloudPresets preset, out CloudModelData cloudModelData)
		{
			switch (preset)
			{
			case VolumetricClouds.CloudPresets.Sparse:
				cloudModelData.densityMultiplier = 0.25f;
				cloudModelData.shapeFactor = 0.9f;
				cloudModelData.shapeScale = 3f;
				cloudModelData.erosionFactor = 0.9f;
				cloudModelData.erosionScale = 61.4f;
				cloudModelData.erosionNoise = VolumetricClouds.CloudErosionNoise.Perlin32;
				break;
			case VolumetricClouds.CloudPresets.Cloudy:
				cloudModelData.densityMultiplier = 0.3f;
				cloudModelData.shapeFactor = 0.9f;
				cloudModelData.shapeScale = 5f;
				cloudModelData.erosionFactor = 0.95f;
				cloudModelData.erosionScale = 87.7f;
				cloudModelData.erosionNoise = VolumetricClouds.CloudErosionNoise.Perlin32;
				break;
			case VolumetricClouds.CloudPresets.Overcast:
				cloudModelData.densityMultiplier = 0.3f;
				cloudModelData.shapeFactor = 0.6f;
				cloudModelData.shapeScale = 6f;
				cloudModelData.erosionFactor = 0.75f;
				cloudModelData.erosionScale = 87.2f;
				cloudModelData.erosionNoise = VolumetricClouds.CloudErosionNoise.Perlin32;
				break;
			case VolumetricClouds.CloudPresets.Stormy:
				cloudModelData.densityMultiplier = 0.3f;
				cloudModelData.shapeFactor = 0.85f;
				cloudModelData.shapeScale = 3f;
				cloudModelData.erosionFactor = 0.9f;
				cloudModelData.erosionScale = 57.9f;
				cloudModelData.erosionNoise = VolumetricClouds.CloudErosionNoise.Perlin32;
				break;
			default:
				cloudModelData.densityMultiplier = 0f;
				cloudModelData.shapeFactor = 0f;
				cloudModelData.shapeScale = 0f;
				cloudModelData.erosionFactor = 0f;
				cloudModelData.erosionScale = 0f;
				cloudModelData.erosionNoise = VolumetricClouds.CloudErosionNoise.Perlin32;
				break;
			}
		}

		private float ErosionNoiseTypeToErosionCompensation(VolumetricClouds.CloudErosionNoise noiseType)
		{
			return noiseType switch
			{
				VolumetricClouds.CloudErosionNoise.Worley32 => 1f, 
				VolumetricClouds.CloudErosionNoise.Perlin32 => 0.75f, 
				_ => 1f, 
			};
		}

		private void PrepareCustomLutData(in VolumetricClouds clouds)
		{
			if (m_CustomLutPresetMap == null)
			{
				m_CustomLutPresetMap = new Texture2D(1, 32, GraphicsFormat.R16G16B16A16_SFloat, TextureCreationFlags.None)
				{
					name = "Custom LUT Curve",
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp
				};
				m_CustomLutPresetMap.hideFlags = HideFlags.HideAndDontSave;
			}
			Color[] customLutColorArray = m_CustomLutColorArray;
			AnimationCurve value = clouds.densityCurve.value;
			AnimationCurve value2 = clouds.erosionCurve.value;
			AnimationCurve value3 = clouds.ambientOcclusionCurve.value;
			if (value == null || value.length == 0)
			{
				for (int i = 0; i < 32; i++)
				{
					customLutColorArray[i] = Color.white;
				}
			}
			else
			{
				float num = 1f / 31f;
				for (int j = 0; j < 32; j++)
				{
					float time = num * (float)j;
					float r = ((j == 0 || j == 31) ? 0f : Mathf.Clamp(value.Evaluate(time), 0f, 1f));
					float g = Mathf.Clamp(value2.Evaluate(time), 0f, 1f);
					float b = Mathf.Clamp(1f - value3.Evaluate(time), 0f, 1f);
					customLutColorArray[j] = new Color(r, g, b, 1f);
				}
			}
			m_CustomLutPresetMap.SetPixels(customLutColorArray);
			m_CustomLutPresetMap.Apply();
		}

		private static bool HasVolumetricClouds(HDCamera hdCamera, in VolumetricClouds settings)
		{
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.VolumetricClouds))
			{
				return settings.enable.value;
			}
			return false;
		}

		private static bool HasVolumetricClouds(HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			return HasVolumetricClouds(hdCamera, in settings);
		}

		private static bool VolumetricCloudsRequireMaxZ(HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			if (HasVolumetricClouds(hdCamera, in settings))
			{
				return !settings.localClouds.value;
			}
			return false;
		}

		private Texture2D GetPresetCloudMapTexture()
		{
			if (m_CustomPresetMap == null || (object)m_CustomPresetMap == null)
			{
				AllocatePresetTextures();
			}
			return m_CustomPresetMap;
		}

		private TVolumetricCloudsCameraType GetCameraType(HDCamera hdCamera)
		{
			if (hdCamera.camera.cameraType == CameraType.Reflection)
			{
				if (GeometryUtils.IsProjectionMatrixOblique(hdCamera.camera.projectionMatrix))
				{
					return TVolumetricCloudsCameraType.PlanarReflection;
				}
				if (hdCamera.realtimeReflectionProbe)
				{
					return TVolumetricCloudsCameraType.RealtimeReflection;
				}
				return TVolumetricCloudsCameraType.BakedReflection;
			}
			return TVolumetricCloudsCameraType.Default;
		}

		private CloudModelData GetCloudModelData(VolumetricClouds settings)
		{
			CloudModelData result = default(CloudModelData);
			result.densityMultiplier = settings.densityMultiplier.value;
			result.shapeFactor = settings.shapeFactor.value;
			result.shapeScale = settings.shapeScale.value;
			result.erosionFactor = settings.erosionFactor.value;
			result.erosionScale = settings.erosionScale.value;
			result.erosionNoise = settings.erosionNoiseType.value;
			return result;
		}

		private unsafe void UpdateShaderVariableslClouds(ref ShaderVariablesClouds cb, HDCamera hdCamera, VolumetricClouds settings, in VolumetricCloudsCameraData cameraData, in CloudModelData cloudModelData, bool shadowPass)
		{
			cb._LowestCloudAltitude = settings.bottomAltitude.value;
			if (!settings.localClouds.value)
			{
				cb._LowestCloudAltitude = Mathf.Max(cb._LowestCloudAltitude, 1f);
			}
			cb._HighestCloudAltitude = cb._LowestCloudAltitude + settings.altitudeRange.value;
			cb._EarthRadius = Mathf.Lerp(1f, 0.025f, settings.earthCurvature.value) * 6378100f;
			cb._CloudRangeSquared.Set(Square(cb._LowestCloudAltitude + cb._EarthRadius), Square(cb._HighestCloudAltitude + cb._EarthRadius));
			cb._NumPrimarySteps = settings.numPrimarySteps.value;
			cb._NumLightSteps = settings.numLightSteps.value;
			cb._MaxRayMarchingDistance = Mathf.Min(settings.altitudeRange.value / 8f * (float)cb._NumPrimarySteps, hdCamera.camera.farClipPlane);
			cb._CloudMapTiling.Set(settings.cloudTiling.value.x, settings.cloudTiling.value.y, settings.cloudOffset.value.x, settings.cloudOffset.value.y);
			cb._ScatteringTint = Color.white - settings.scatteringTint.value * 0.75f;
			cb._PowderEffectIntensity = settings.powderEffectIntensity.value;
			cb._NormalizationFactor = ComputeNormalizationFactor(cb._EarthRadius, (cb._LowestCloudAltitude + cb._HighestCloudAltitude) * 0.5f);
			int num = RayTracingFrameIndex(hdCamera, 64);
			cb._AccumulationFrameIndex = num / 4;
			cb._SubPixelIndex = num % 4;
			VisualEnvironment component = hdCamera.volumeStack.GetComponent<VisualEnvironment>();
			cb._PhysicallyBasedSun = ((component.skyType.value == 4) ? 1 : 0);
			Light mainLight = GetMainLight();
			HDAdditionalLightData component2 = null;
			if (mainLight != null)
			{
				m_CurrentSunLight.TryGetComponent<HDAdditionalLightData>(out component2);
				cb._SunDirection = -mainLight.transform.forward;
				cb._SunRight = mainLight.transform.right;
				cb._SunUp = mainLight.transform.up;
				if (!shadowPass)
				{
					cb._SunLightColor = m_GpuLightsBuilder.directionalLights[m_CurrentSunLightDataIndex].color * settings.sunLightDimmer.value;
				}
			}
			else
			{
				cb._SunDirection = Vector3.up;
				cb._SunRight = Vector3.right;
				cb._SunUp = Vector3.forward;
				cb._SunLightColor = Vector3.zero;
			}
			float f = settings.orientation.GetValue(hdCamera) / 180f * MathF.PI;
			cb._WindDirection = new Vector2(0f - Mathf.Cos(f), 0f - Mathf.Sin(f));
			cb._WindVector = volumetricCloudsAnimationData.cloudOffset;
			cb._VerticalShapeWindDisplacement = volumetricCloudsAnimationData.verticalShapeOffset;
			cb._VerticalErosionWindDisplacement = volumetricCloudsAnimationData.verticalErosionOffset;
			cb._LargeWindSpeed = settings.cloudMapSpeedMultiplier.value;
			cb._MediumWindSpeed = settings.shapeSpeedMultiplier.value;
			cb._SmallWindSpeed = settings.erosionSpeedMultiplier.value;
			cb._AltitudeDistortion = settings.altitudeDistortion.value * 0.25f;
			cb._MultiScattering = 1f - settings.multiScattering.value * 0.95f;
			cb._DensityMultiplier = cloudModelData.densityMultiplier * cloudModelData.densityMultiplier * 2f;
			cb._ShapeFactor = cloudModelData.shapeFactor;
			cb._ShapeScale = cloudModelData.shapeScale;
			cb._ErosionFactor = cloudModelData.erosionFactor;
			cb._ErosionScale = cloudModelData.erosionScale;
			cb._ShapeNoiseOffset = new Vector2(settings.shapeOffset.value.x, settings.shapeOffset.value.z);
			cb._VerticalShapeNoiseOffset = settings.shapeOffset.value.y;
			float num2 = 0f;
			if (component2 != null)
			{
				num2 = Quaternion.Angle(component2.previousTransform.rotation, component2.transform.localToWorldMatrix.rotation);
			}
			cb._CloudHistoryInvalidation = Mathf.Lerp(1f, 0f, Mathf.Clamp(num2 / 10f, 0f, 1f));
			cb._TemporalAccumulationFactor = settings.temporalAccumulationFactor.value;
			if (settings.fadeInMode.value == VolumetricClouds.CloudFadeInMode.Automatic)
			{
				cb._FadeInStart = Mathf.Max((cb._HighestCloudAltitude - cb._LowestCloudAltitude) * 0.2f, hdCamera.camera.nearClipPlane);
				cb._FadeInDistance = (cb._HighestCloudAltitude - cb._LowestCloudAltitude) * 0.3f;
			}
			else
			{
				cb._FadeInStart = Mathf.Max(settings.fadeInStart.value, hdCamera.camera.nearClipPlane);
				cb._FadeInDistance = settings.fadeInDistance.value;
			}
			cb._FinalScreenSize.Set(cameraData.finalWidth, cameraData.finalHeight, 1f / (float)cameraData.finalWidth, 1f / (float)cameraData.finalHeight);
			cb._IntermediateScreenSize.Set(cameraData.intermediateWidth, cameraData.intermediateHeight, 1f / (float)cameraData.intermediateWidth, 1f / (float)cameraData.intermediateHeight);
			cb._TraceScreenSize.Set(cameraData.traceWidth, cameraData.traceHeight, 1f / (float)cameraData.traceWidth, 1f / (float)cameraData.traceHeight);
			float num3 = cb._HighestCloudAltitude + cb._EarthRadius;
			cb._MaxCloudDistance = Mathf.Sqrt(num3 * num3 - cb._EarthRadius * cb._EarthRadius);
			cb._ErosionOcclusion = settings.erosionOcclusion.value;
			cb._ErosionFactorCompensation = ErosionNoiseTypeToErosionCompensation(settings.erosionNoiseType.value);
			cb._IsPlanarReflection = ((cameraData.cameraType == TVolumetricCloudsCameraType.PlanarReflection) ? 1 : 0);
			if (cb._IsPlanarReflection == 1)
			{
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(Matrix4x4.Perspective(hdCamera.camera.fieldOfView, hdCamera.camera.aspect, hdCamera.camera.nearClipPlane, hdCamera.camera.farClipPlane), renderIntoTexture: true);
				Matrix4x4 viewMatrix = hdCamera.mainViewConstants.viewMatrix;
				Matrix4x4 prevViewMatrix = hdCamera.mainViewConstants.prevViewMatrix;
				Matrix4x4 cameraViewProjection_NO = gPUProjectionMatrix * viewMatrix;
				Matrix4x4 cameraPrevViewProjection_NO = gPUProjectionMatrix * prevViewMatrix;
				cb._CameraViewProjection_NO = cameraViewProjection_NO;
				cb._CameraInverseViewProjection_NO = cameraViewProjection_NO.inverse;
				cb._CameraPrevViewProjection_NO = cameraPrevViewProjection_NO;
			}
			if (shadowPass)
			{
				cb._ShadowCookieResolution = (int)settings.shadowResolution.value;
				cb._ShadowIntensity = settings.shadowOpacity.value;
				cb._ShadowFallbackValue = 1f - settings.shadowOpacityFallback.value;
				cb._ShadowPlaneOffset = settings.shadowPlaneHeightOffset.value;
				float value = settings.shadowDistance.value;
				cb._WorldSpaceShadowCenter = new Vector4(hdCamera.camera.transform.position.x, hdCamera.camera.transform.position.y, hdCamera.camera.transform.position.z, 0f);
				if (HasVolumetricCloudsShadows(hdCamera, in settings))
				{
					float num4 = Mathf.Abs(Vector3.Dot(cb._SunRight, Vector3.Normalize(new Vector3(cb._SunRight.x, 0f, cb._SunRight.z))));
					float num5 = Mathf.Abs(Vector3.Dot(cb._SunUp, Vector3.Normalize(new Vector3(cb._SunUp.x, 0f, cb._SunUp.z))));
					cb._ShadowRegionSize = new Vector2(value * num4, value * num5);
				}
			}
			cb._EnableFastToneMapping = (cameraData.enableExposureControl ? 1 : 0);
			cb._LowResolutionEvaluation = (cameraData.lowResolution ? 1 : 0);
			cb._EnableIntegration = (cameraData.enableIntegration ? 1 : 0);
			cb._RenderForSky = ((cameraData.cameraType == TVolumetricCloudsCameraType.Sky) ? 1 : 0);
			cb._ValidMaxZMask = ((!settings.localClouds.value) ? 1 : 0);
			for (int i = 0; i < 4; i++)
			{
				for (int j = 0; j < 9; j++)
				{
					cb._DistanceBasedWeights[12 * i + j] = BilateralUpsample.distanceBasedWeights_3x3[9 * i + j];
				}
			}
		}

		private Texture3D ErosionNoiseTypeToTexture(VolumetricClouds.CloudErosionNoise noiseType)
		{
			return noiseType switch
			{
				VolumetricClouds.CloudErosionNoise.Worley32 => m_Asset.renderPipelineResources.textures.worleyNoise32RGB, 
				VolumetricClouds.CloudErosionNoise.Perlin32 => m_Asset.renderPipelineResources.textures.perlinNoise32RGB, 
				_ => m_Asset.renderPipelineResources.textures.worleyNoise32RGB, 
			};
		}

		private void FillVolumetricCloudsCommonData(bool enableExposureControl, VolumetricClouds settings, TVolumetricCloudsCameraType cameraType, in CloudModelData cloudModelData, ref VolumetricCloudCommonData commonData)
		{
			commonData.cameraType = cameraType;
			commonData.localClouds = settings.localClouds.value;
			commonData.volumetricCloudsCS = m_Asset.renderPipelineResources.shaders.volumetricCloudsCS;
			if (settings.cloudControl.value == VolumetricClouds.CloudControl.Simple)
			{
				commonData.cloudMapTexture = GetPresetCloudMapTexture();
				PrepareCustomLutData(in settings);
				commonData.cloudLutTexture = m_CustomLutPresetMap;
			}
			else if (settings.cloudControl.value == VolumetricClouds.CloudControl.Advanced)
			{
				commonData.cloudMapTexture = m_AdvancedCloudMap;
				commonData.cloudLutTexture = m_Asset.renderPipelineResources.textures.cloudLutRainAO;
			}
			else
			{
				commonData.cloudMapTexture = ((settings.cloudMap.value != null) ? settings.cloudMap.value : Texture2D.blackTexture);
				commonData.cloudLutTexture = ((settings.cloudLut.value != null) ? settings.cloudLut.value : Texture2D.blackTexture);
			}
			commonData.worley128RGBA = m_Asset.renderPipelineResources.textures.worleyNoise128RGBA;
			commonData.erosionNoise = ErosionNoiseTypeToTexture(cloudModelData.erosionNoise);
			BlueNoise blueNoiseManager = GetBlueNoiseManager();
			commonData.ditheredTextureSet = blueNoiseManager.DitheredTextureSet8SPP();
			commonData.sunLight = GetMainLight();
			commonData.enableExposureControl = enableExposureControl;
		}

		private void UpdateVolumetricClouds(HDCamera hdCamera, in VolumetricClouds settings)
		{
			if (volumetricCloudsAnimationData.lastTime == -1f || !EvaluateVolumetricCloudsHistoryValidity(hdCamera, settings.localClouds.value))
			{
				volumetricCloudsAnimationData.lastTime = hdCamera.time;
				return;
			}
			float num = hdCamera.time - volumetricCloudsAnimationData.lastTime;
			float f = settings.orientation.GetValue(hdCamera) / 180f * MathF.PI;
			Vector2 vector = new Vector2(Mathf.Cos(f), Mathf.Sin(f));
			Vector2 vector2 = 0.277778f * num * settings.globalWindSpeed.GetValue(hdCamera) * -vector;
			volumetricCloudsAnimationData.cloudOffset += vector2;
			volumetricCloudsAnimationData.verticalShapeOffset += (0f - settings.verticalShapeWindSpeed.value) * num * 0.277778f;
			volumetricCloudsAnimationData.verticalErosionOffset += (0f - settings.verticalErosionWindSpeed.value) * num * 0.277778f;
			volumetricCloudsAnimationData.lastTime = hdCamera.time;
		}

		private TextureHandle RenderVolumetricClouds(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthPyramid, TextureHandle motionVector, TextureHandle volumetricLighting, TextureHandle maxZMask)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			if (m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera) || !HasVolumetricClouds(hdCamera, in settings))
			{
				return renderGraph.defaultResources.whiteTextureXR;
			}
			UpdateVolumetricClouds(hdCamera, in settings);
			TVolumetricCloudsCameraType cameraType = GetCameraType(hdCamera);
			bool num = cameraType == TVolumetricCloudsCameraType.Default || cameraType == TVolumetricCloudsCameraType.PlanarReflection;
			bool flag = cameraType == TVolumetricCloudsCameraType.BakedReflection;
			TextureHandle result;
			if (!num)
			{
				result = ((!flag) ? RenderVolumetricClouds_LowResolution(renderGraph, hdCamera, cameraType, colorBuffer, depthPyramid, motionVector, volumetricLighting, maxZMask) : RenderVolumetricClouds_FullResolution(renderGraph, hdCamera, cameraType, colorBuffer, depthPyramid, motionVector, volumetricLighting, maxZMask));
			}
			else
			{
				result = RenderVolumetricClouds_Accumulation(renderGraph, hdCamera, cameraType, colorBuffer, depthPyramid, motionVector, volumetricLighting, maxZMask);
				PropagateVolumetricCloudsHistoryValidity(hdCamera, settings.localClouds.value);
			}
			return result;
		}

		private void PreRenderVolumetricClouds(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera))
			{
				return;
			}
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			if (HasVolumetricClouds(hdCamera, in settings))
			{
				if (HasVolumetricCloudsShadows(hdCamera))
				{
					RTHandle rt = RequestVolumetricCloudsShadowTexture(in settings);
					PushFullScreenDebugTexture(m_RenderGraph, renderGraph.ImportTexture(rt), FullScreenDebugMode.VolumetricCloudsShadow, GraphicsFormat.R16G16B16A16_SFloat, xrTexture: false);
				}
				PreRenderVolumetricCloudMap(renderGraph, hdCamera, in settings);
			}
		}

		private static RTHandle VolumetricClouds0HistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one * 0.5f, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_CloudsHistory0Buffer{frameIndex}");
		}

		private static RTHandle VolumetricClouds1HistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one * 0.5f, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_CloudsHistory1Buffer{frameIndex}");
		}

		private static RTHandle RequestCurrentVolumetricCloudsHistoryTexture0(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(19) ?? hdCamera.AllocHistoryFrameRT(19, VolumetricClouds0HistoryBufferAllocatorFunction, 2);
		}

		private static RTHandle RequestPreviousVolumetricCloudsHistoryTexture0(HDCamera hdCamera)
		{
			return hdCamera.GetPreviousFrameRT(19) ?? hdCamera.AllocHistoryFrameRT(19, VolumetricClouds0HistoryBufferAllocatorFunction, 2);
		}

		private static RTHandle RequestCurrentVolumetricCloudsHistoryTexture1(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(20) ?? hdCamera.AllocHistoryFrameRT(20, VolumetricClouds1HistoryBufferAllocatorFunction, 2);
		}

		private static RTHandle RequestPreviousVolumetricCloudsHistoryTexture1(HDCamera hdCamera)
		{
			return hdCamera.GetPreviousFrameRT(20) ?? hdCamera.AllocHistoryFrameRT(20, VolumetricClouds1HistoryBufferAllocatorFunction, 2);
		}

		private int CombineVolumetricCLoudsHistoryStateToMask(bool localClouds)
		{
			if (!localClouds)
			{
				return 0;
			}
			return 8;
		}

		private bool EvaluateVolumetricCloudsHistoryValidity(HDCamera hdCamera, bool localClouds)
		{
			int flagMask = CombineVolumetricCLoudsHistoryStateToMask(localClouds);
			return hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.VolumetricClouds, flagMask);
		}

		private void PropagateVolumetricCloudsHistoryValidity(HDCamera hdCamera, bool localClouds)
		{
			int flagMask = CombineVolumetricCLoudsHistoryStateToMask(localClouds);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.VolumetricClouds, flagMask);
		}

		private VolumetricCloudsParameters_Accumulation PrepareVolumetricCloudsParameters_Accumulation(HDCamera hdCamera, VolumetricClouds settings, TVolumetricCloudsCameraType cameraType, bool historyValidity)
		{
			VolumetricCloudsParameters_Accumulation result = default(VolumetricCloudsParameters_Accumulation);
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(hdCamera.exposureControlFS, settings, cameraType, in cloudModelData, ref result.commonData);
			result.finalWidth = hdCamera.actualWidth;
			result.finalHeight = hdCamera.actualHeight;
			result.intermediateWidth = Mathf.RoundToInt(0.5f * (float)hdCamera.actualWidth);
			result.intermediateHeight = Mathf.RoundToInt(0.5f * (float)hdCamera.actualHeight);
			result.traceWidth = Mathf.RoundToInt(0.25f * (float)hdCamera.actualWidth);
			result.traceHeight = Mathf.RoundToInt(0.25f * (float)hdCamera.actualHeight);
			result.viewCount = hdCamera.viewCount;
			result.previousViewportSize = hdCamera.historyRTHandleProperties.previousViewportSize;
			result.historyValidity = historyValidity;
			result.needsTemporaryBuffer = hdCamera.msaaEnabled;
			result.cloudCombinePass = m_CloudCombinePass;
			result.needExtraColorBufferCopy = GetColorBufferFormat() == GraphicsFormat.B10G11R11_UFloatPack32 && (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D12 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Vulkan);
			result.needExtraColorBufferCopy &= !result.needsTemporaryBuffer;
			result.convertObliqueDepthKernel = m_ConvertObliqueDepthKernel;
			result.depthDownscaleKernel = m_CloudDownscaleDepthKernel;
			result.renderKernel = m_CloudRenderKernel;
			result.reprojectKernel = (settings.ghostingReduction.value ? m_ReprojectCloudsRejectionKernel : m_ReprojectCloudsKernel);
			result.upscaleAndCombineKernel = (result.needExtraColorBufferCopy ? m_UpscaleAndCombineCloudsKernelColorCopy : m_UpscaleAndCombineCloudsKernelColorRW);
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = result.commonData.cameraType;
			cameraData.traceWidth = result.traceWidth;
			cameraData.traceHeight = result.traceHeight;
			cameraData.intermediateWidth = result.intermediateWidth;
			cameraData.intermediateHeight = result.intermediateHeight;
			cameraData.finalWidth = result.finalWidth;
			cameraData.finalHeight = result.finalHeight;
			cameraData.viewCount = result.viewCount;
			cameraData.enableExposureControl = result.commonData.enableExposureControl;
			cameraData.lowResolution = true;
			cameraData.enableIntegration = true;
			UpdateShaderVariableslClouds(ref result.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: false);
			float value = settings.perceptualBlending.value;
			result.commonData.cloudsCB._ImprovedTransmittanceBlend = ((result.commonData.cameraType == TVolumetricCloudsCameraType.Default) ? value : 0f);
			result.commonData.cloudsCB._CubicTransmittance = ((result.commonData.cameraType == TVolumetricCloudsCameraType.Default && hdCamera.msaaEnabled) ? value : 0f);
			return result;
		}

		private static void TraceVolumetricClouds_Accumulation(CommandBuffer cmd, VolumetricCloudsParameters_Accumulation parameters, ComputeBuffer ambientProbe, RTHandle colorBuffer, RTHandle depthPyramid, RTHandle motionVectors, RTHandle volumetricLightingTexture, RTHandle scatteringFallbackTexture, RTHandle maxZMask, RTHandle currentHistory0Buffer, RTHandle previousHistory0Buffer, RTHandle currentHistory1Buffer, RTHandle previousHistory1Buffer, RTHandle intermediateLightingBuffer0, RTHandle intermediateLightingBuffer1, RTHandle intermediateDepthBuffer0, RTHandle intermediateDepthBuffer1, RTHandle intermediateDepthBuffer2, RTHandle intermediateColorBuffer, RTHandle intermediateUpscaleBuffer)
		{
			int threadGroupsX = (parameters.traceWidth + 7) / 8;
			int threadGroupsY = (parameters.traceHeight + 7) / 8;
			int threadGroupsX2 = (parameters.intermediateWidth + 7) / 8;
			int threadGroupsY2 = (parameters.intermediateHeight + 7) / 8;
			int threadGroupsX3 = (parameters.finalWidth + 7) / 8;
			int threadGroupsY3 = (parameters.finalHeight + 7) / 8;
			BlueNoise.BindDitheredTextureSet(cmd, parameters.commonData.ditheredTextureSet);
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", parameters.commonData.localClouds);
			Vector2Int scaledSize = previousHistory0Buffer.GetScaledSize(parameters.previousViewportSize);
			parameters.commonData.cloudsCB._HistoryViewportSize = new Vector2(scaledSize.x, scaledSize.y);
			parameters.commonData.cloudsCB._HistoryBufferSize = new Vector2(previousHistory0Buffer.rt.width, previousHistory0Buffer.rt.height);
			ConstantBuffer.PushGlobal(cmd, in parameters.commonData.cloudsCB, HDShaderIDs._ShaderVariablesClouds);
			RTHandle rTHandle = depthPyramid;
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsPrepare)))
			{
				if (parameters.commonData.cameraType == TVolumetricCloudsCameraType.PlanarReflection)
				{
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.convertObliqueDepthKernel, HDShaderIDs._DepthTexture, depthPyramid);
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.convertObliqueDepthKernel, HDShaderIDs._DepthBufferRW, intermediateDepthBuffer2);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.convertObliqueDepthKernel, threadGroupsX3, threadGroupsY3, parameters.viewCount);
					rTHandle = intermediateDepthBuffer2;
				}
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, HDShaderIDs._DepthTexture, rTHandle);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, HDShaderIDs._HalfResDepthBufferRW, intermediateDepthBuffer0);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, threadGroupsX2, threadGroupsY2, parameters.viewCount);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsTrace)))
			{
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", parameters.commonData.cloudsCB._PhysicallyBasedSun == 1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._MaxZMaskTexture, maxZMask);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsSourceDepth, intermediateDepthBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._Worley128RGBA, parameters.commonData.worley128RGBA);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._ErosionNoise, parameters.commonData.erosionNoise);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudMapTexture, parameters.commonData.cloudMapTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudLutTexture, parameters.commonData.cloudLutTexture);
				cmd.SetComputeBufferParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsAmbientProbeBuffer, ambientProbe);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsLightingTextureRW, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsDepthTextureRW, intermediateDepthBuffer1);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, threadGroupsX, threadGroupsY, parameters.viewCount);
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", state: false);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsReproject)))
			{
				if (!parameters.historyValidity)
				{
					CoreUtils.SetRenderTarget(cmd, previousHistory0Buffer, ClearFlag.Color, Color.black);
					CoreUtils.SetRenderTarget(cmd, previousHistory1Buffer, ClearFlag.Color, Color.black);
				}
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._CloudsLightingTexture, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._CloudsDepthTexture, intermediateDepthBuffer1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._HalfResDepthBuffer, intermediateDepthBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._HistoryVolumetricClouds0Texture, previousHistory0Buffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._HistoryVolumetricClouds1Texture, previousHistory1Buffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._CloudsLightingTextureRW, currentHistory0Buffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, HDShaderIDs._CloudsAdditionalTextureRW, currentHistory1Buffer);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.reprojectKernel, threadGroupsX2, threadGroupsY2, parameters.viewCount);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsUpscaleAndCombine)))
			{
				if (parameters.needExtraColorBufferCopy)
				{
					HDUtils.BlitCameraTexture(cmd, colorBuffer, intermediateColorBuffer);
				}
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._DepthStatusTexture, currentHistory1Buffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsTexture, currentHistory0Buffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._DepthTexture, rTHandle);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._CameraColorTexture, intermediateColorBuffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._VBufferLighting, volumetricLightingTexture);
				if (parameters.commonData.cloudsCB._PhysicallyBasedSun == 0)
				{
					cmd.SetGlobalTexture(HDShaderIDs._AirSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._AerosolSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._MultipleScatteringTexture, scatteringFallbackTexture);
				}
				if (parameters.needsTemporaryBuffer)
				{
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: true);
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, threadGroupsX3, threadGroupsY3, parameters.viewCount);
					parameters.cloudCombinePass.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					HDUtils.DrawFullScreen(cmd, parameters.cloudCombinePass, colorBuffer);
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: false);
				}
				else
				{
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, colorBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, threadGroupsX3, threadGroupsY3, parameters.viewCount);
				}
			}
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", state: false);
		}

		private TextureHandle RenderVolumetricClouds_Accumulation(RenderGraph renderGraph, HDCamera hdCamera, TVolumetricCloudsCameraType cameraType, TextureHandle colorBuffer, TextureHandle depthPyramid, TextureHandle motionVectors, TextureHandle volumetricLighting, TextureHandle maxZMask)
		{
			VolumetricCloudsAccumulationData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<VolumetricCloudsAccumulationData>("Volumetric Clouds", out passData, ProfilingSampler.Get(HDProfileId.VolumetricClouds));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				VolumetricClouds component = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
				bool historyValidity = EvaluateVolumetricCloudsHistoryValidity(hdCamera, component.localClouds.value) && hdCamera.GetCurrentFrameRT(19) != null;
				passData.parameters = PrepareVolumetricCloudsParameters_Accumulation(hdCamera, component, cameraType, historyValidity);
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData = passData;
				TextureHandle input = renderGraphBuilder.WriteTexture(in colorBuffer);
				volumetricCloudsAccumulationData.colorBuffer = renderGraphBuilder.ReadTexture(in input);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.motionVectors = renderGraphBuilder.ReadTexture(in motionVectors);
				passData.maxZMask = (component.localClouds.value ? renderGraph.defaultResources.blackTextureXR : renderGraphBuilder.ReadTexture(in maxZMask));
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData2 = passData;
				ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(m_CloudsDynamicProbeBuffer);
				volumetricCloudsAccumulationData2.ambientProbeBuffer = renderGraphBuilder.ReadComputeBuffer(in input2);
				passData.volumetricLighting = renderGraphBuilder.ReadTexture(in volumetricLighting);
				passData.scatteringFallbackTexture = renderGraph.defaultResources.blackTexture3DXR;
				passData.currentHistoryBuffer0 = renderGraph.ImportTexture(RequestCurrentVolumetricCloudsHistoryTexture0(hdCamera));
				passData.previousHistoryBuffer0 = renderGraph.ImportTexture(RequestPreviousVolumetricCloudsHistoryTexture0(hdCamera));
				passData.currentHistoryBuffer1 = renderGraph.ImportTexture(RequestCurrentVolumetricCloudsHistoryTexture1(hdCamera));
				passData.previousHistoryBuffer1 = renderGraph.ImportTexture(RequestPreviousVolumetricCloudsHistoryTexture1(hdCamera));
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData3 = passData;
				TextureDesc desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 0"
				};
				volumetricCloudsAccumulationData3.intermediateBuffer0 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData4 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 1 "
				};
				volumetricCloudsAccumulationData4.intermediateBuffer1 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData5 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Depth Buffer 0"
				};
				volumetricCloudsAccumulationData5.intermediateBufferDepth0 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData6 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Depth Buffer 1"
				};
				volumetricCloudsAccumulationData6.intermediateBufferDepth1 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsAccumulationData volumetricCloudsAccumulationData7 = passData;
				TextureHandle intermediateColorBufferCopy;
				if (!passData.parameters.needExtraColorBufferCopy)
				{
					intermediateColorBufferCopy = renderGraph.defaultResources.blackTextureXR;
				}
				else
				{
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GetColorBufferFormat(),
						enableRandomWrite = true,
						name = "Temporary Color Buffer"
					};
					intermediateColorBufferCopy = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				volumetricCloudsAccumulationData7.intermediateColorBufferCopy = intermediateColorBufferCopy;
				if (passData.parameters.needsTemporaryBuffer)
				{
					VolumetricCloudsAccumulationData volumetricCloudsAccumulationData8 = passData;
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
						enableRandomWrite = true,
						name = "Temporary Clouds Upscaling Buffer"
					};
					volumetricCloudsAccumulationData8.intermediateBufferUpscale = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					passData.intermediateBufferUpscale = renderGraph.defaultResources.blackTexture;
				}
				if (passData.parameters.commonData.cameraType == TVolumetricCloudsCameraType.PlanarReflection)
				{
					VolumetricCloudsAccumulationData volumetricCloudsAccumulationData9 = passData;
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "Temporary Clouds Depth Buffer 2"
					};
					volumetricCloudsAccumulationData9.intermediateBufferDepth2 = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					passData.intermediateBufferDepth2 = renderGraph.defaultResources.blackTexture;
				}
				renderGraphBuilder.SetRenderFunc(delegate(VolumetricCloudsAccumulationData data, RenderGraphContext ctx)
				{
					TraceVolumetricClouds_Accumulation(ctx.cmd, data.parameters, data.ambientProbeBuffer, data.colorBuffer, data.depthPyramid, data.motionVectors, data.volumetricLighting, data.scatteringFallbackTexture, data.maxZMask, data.currentHistoryBuffer0, data.previousHistoryBuffer0, data.currentHistoryBuffer1, data.previousHistoryBuffer1, data.intermediateBuffer0, data.intermediateBuffer1, data.intermediateBufferDepth0, data.intermediateBufferDepth1, data.intermediateBufferDepth2, data.intermediateColorBufferCopy, data.intermediateBufferUpscale);
				});
				PushFullScreenDebugTexture(m_RenderGraph, passData.currentHistoryBuffer0, FullScreenDebugMode.VolumetricClouds);
				return passData.currentHistoryBuffer0;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private VolumetricCloudsParameters_FullResolution PrepareVolumetricCloudsParameters_FullResolution(HDCamera hdCamera, int width, int height, int viewCount, bool exposureControl, VolumetricClouds settings, TVolumetricCloudsCameraType cameraType)
		{
			VolumetricCloudsParameters_FullResolution result = default(VolumetricCloudsParameters_FullResolution);
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(exposureControl, settings, cameraType, in cloudModelData, ref result.commonData);
			result.finalWidth = width;
			result.finalHeight = height;
			result.viewCount = viewCount;
			result.needsTemporaryBuffer = hdCamera.msaaEnabled;
			result.cloudCombinePass = m_CloudCombinePass;
			result.needExtraColorBufferCopy = GetColorBufferFormat() == GraphicsFormat.B10G11R11_UFloatPack32 && (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D12 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Vulkan);
			result.needExtraColorBufferCopy &= !result.needsTemporaryBuffer;
			result.renderKernel = m_CloudRenderKernel;
			result.combineKernel = (result.needExtraColorBufferCopy ? m_CombineCloudsKernelColorCopy : m_CombineCloudsKernelColorRW);
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = result.commonData.cameraType;
			cameraData.traceWidth = result.finalWidth;
			cameraData.traceHeight = result.finalHeight;
			cameraData.intermediateWidth = result.finalWidth;
			cameraData.intermediateHeight = result.finalHeight;
			cameraData.finalWidth = result.finalWidth;
			cameraData.finalHeight = result.finalHeight;
			cameraData.viewCount = result.viewCount;
			cameraData.enableExposureControl = result.commonData.enableExposureControl;
			cameraData.lowResolution = false;
			cameraData.enableIntegration = true;
			UpdateShaderVariableslClouds(ref result.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: false);
			return result;
		}

		private static void TraceVolumetricClouds_FullResolution(CommandBuffer cmd, VolumetricCloudsParameters_FullResolution parameters, ComputeBuffer ambientProbeBuffer, RTHandle colorBuffer, RTHandle depthPyramid, RTHandle volumetricLightingTexture, RTHandle scatteringFallbackTexture, RTHandle maxZMask, RTHandle intermediateLightingBuffer0, RTHandle intermediateDepthBuffer0, RTHandle intermediateColorBuffer, RTHandle intermediateUpscaleBuffer)
		{
			int threadGroupsX = (parameters.finalWidth + 7) / 8;
			int threadGroupsY = (parameters.finalHeight + 7) / 8;
			BlueNoise.BindDitheredTextureSet(cmd, parameters.commonData.ditheredTextureSet);
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", parameters.commonData.localClouds);
			ConstantBuffer.Push(cmd, in parameters.commonData.cloudsCB, parameters.commonData.volumetricCloudsCS, HDShaderIDs._ShaderVariablesClouds);
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsTrace)))
			{
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", parameters.commonData.cloudsCB._PhysicallyBasedSun == 1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._MaxZMaskTexture, maxZMask);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsSourceDepth, depthPyramid);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._Worley128RGBA, parameters.commonData.worley128RGBA);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._ErosionNoise, parameters.commonData.erosionNoise);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudMapTexture, parameters.commonData.cloudMapTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudLutTexture, parameters.commonData.cloudLutTexture);
				cmd.SetComputeBufferParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsAmbientProbeBuffer, ambientProbeBuffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsLightingTextureRW, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsDepthTextureRW, intermediateDepthBuffer0);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, threadGroupsX, threadGroupsY, parameters.viewCount);
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", state: false);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsUpscaleAndCombine)))
			{
				if (parameters.needExtraColorBufferCopy)
				{
					HDUtils.BlitCameraTexture(cmd, colorBuffer, intermediateColorBuffer);
				}
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._VolumetricCloudsTexture, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._DepthStatusTexture, intermediateDepthBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._DepthTexture, depthPyramid);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._CameraColorTexture, intermediateColorBuffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._VBufferLighting, volumetricLightingTexture);
				if (parameters.commonData.cloudsCB._PhysicallyBasedSun == 0)
				{
					cmd.SetGlobalTexture(HDShaderIDs._AirSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._AerosolSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._MultipleScatteringTexture, scatteringFallbackTexture);
				}
				if (parameters.needsTemporaryBuffer)
				{
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: true);
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, threadGroupsX, threadGroupsY, parameters.viewCount);
					parameters.cloudCombinePass.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					HDUtils.DrawFullScreen(cmd, parameters.cloudCombinePass, colorBuffer);
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: false);
				}
				else
				{
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, colorBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.combineKernel, threadGroupsX, threadGroupsY, parameters.viewCount);
				}
			}
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", state: false);
		}

		private TextureHandle RenderVolumetricClouds_FullResolution(RenderGraph renderGraph, HDCamera hdCamera, TVolumetricCloudsCameraType cameraType, TextureHandle colorBuffer, TextureHandle depthPyramid, TextureHandle motionVectors, TextureHandle volumetricLighting, TextureHandle maxZMask)
		{
			VolumetricCloudsFullResolutionData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<VolumetricCloudsFullResolutionData>("Generating the rays for RTR", out passData, ProfilingSampler.Get(HDProfileId.VolumetricClouds));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				VolumetricClouds component = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
				passData.parameters = PrepareVolumetricCloudsParameters_FullResolution(hdCamera, hdCamera.actualWidth, hdCamera.actualHeight, hdCamera.viewCount, hdCamera.exposureControlFS, component, cameraType);
				VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData = passData;
				TextureHandle input = renderGraphBuilder.WriteTexture(in colorBuffer);
				volumetricCloudsFullResolutionData.colorBuffer = renderGraphBuilder.ReadTexture(in input);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.maxZMask = (component.localClouds.value ? renderGraph.defaultResources.blackTextureXR : renderGraphBuilder.ReadTexture(in maxZMask));
				VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData2 = passData;
				ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(m_CloudsDynamicProbeBuffer);
				volumetricCloudsFullResolutionData2.ambientProbeBuffer = renderGraphBuilder.ReadComputeBuffer(in input2);
				passData.volumetricLighting = renderGraphBuilder.ReadTexture(in volumetricLighting);
				passData.scatteringFallbackTexture = renderGraph.defaultResources.blackTexture3DXR;
				VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData3 = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 0"
				};
				volumetricCloudsFullResolutionData3.intermediateLightingBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData4 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Depth Buffer 0"
				};
				volumetricCloudsFullResolutionData4.intermediateBufferDepth = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData5 = passData;
				TextureHandle intermediateColorBufferCopy;
				if (!passData.parameters.needExtraColorBufferCopy)
				{
					intermediateColorBufferCopy = renderGraph.defaultResources.blackTextureXR;
				}
				else
				{
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GetColorBufferFormat(),
						enableRandomWrite = true,
						name = "Temporary Color Buffer"
					};
					intermediateColorBufferCopy = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				volumetricCloudsFullResolutionData5.intermediateColorBufferCopy = intermediateColorBufferCopy;
				if (passData.parameters.needsTemporaryBuffer)
				{
					VolumetricCloudsFullResolutionData volumetricCloudsFullResolutionData6 = passData;
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
						enableRandomWrite = true,
						name = "Temporary Clouds Upscaling Buffer"
					};
					volumetricCloudsFullResolutionData6.intermediateBufferUpscale = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					passData.intermediateBufferUpscale = renderGraph.defaultResources.blackTexture;
				}
				renderGraphBuilder.SetRenderFunc(delegate(VolumetricCloudsFullResolutionData data, RenderGraphContext ctx)
				{
					TraceVolumetricClouds_FullResolution(ctx.cmd, data.parameters, data.ambientProbeBuffer, data.colorBuffer, data.depthPyramid, data.volumetricLighting, data.scatteringFallbackTexture, data.maxZMask, data.intermediateLightingBuffer, data.intermediateBufferDepth, data.intermediateColorBufferCopy, data.intermediateBufferUpscale);
				});
				return renderGraph.defaultResources.whiteTextureXR;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void InitializeVolumetricCloudsAmbientProbe()
		{
			m_CloudsDynamicProbeBuffer = new ComputeBuffer(7, 16);
			m_CloudsStaticProbeBuffer = new ComputeBuffer(7, 16);
		}

		private void ReleaseVolumetricCloudsAmbientProbe()
		{
			CoreUtils.SafeRelease(m_CloudsDynamicProbeBuffer);
			CoreUtils.SafeRelease(m_CloudsStaticProbeBuffer);
		}

		internal ComputeBuffer RenderVolumetricCloudsAmbientProbe(RenderGraph renderGraph, HDCamera hdCamera, SkyUpdateContext lightingSky, bool staticSky)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			ComputeBuffer computeBuffer = (staticSky ? m_CloudsStaticProbeBuffer : m_CloudsDynamicProbeBuffer);
			if (HasVolumetricClouds(hdCamera, in settings) && lightingSky.skyRenderer != null)
			{
				m_SkyManager.RenderSkyAmbientProbe(renderGraph, lightingSky, hdCamera, computeBuffer, renderBackgroundClouds: true, HDProfileId.VolumetricCloudsAmbientProbe, settings.ambientLightProbeDimmer.value);
			}
			return computeBuffer;
		}

		private VolumetricCloudsParameters_LowResolution PrepareVolumetricCloudsParameters_LowResolution(HDCamera hdCamera, int width, int height, int viewCount, bool exposureControl, VolumetricClouds settings, TVolumetricCloudsCameraType cameraType)
		{
			VolumetricCloudsParameters_LowResolution result = default(VolumetricCloudsParameters_LowResolution);
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(exposureControl, settings, cameraType, in cloudModelData, ref result.commonData);
			result.finalWidth = width;
			result.finalHeight = height;
			result.intermediateWidth = Mathf.RoundToInt(0.5f * (float)width);
			result.intermediateHeight = Mathf.RoundToInt(0.5f * (float)height);
			result.traceWidth = Mathf.RoundToInt(0.25f * (float)width);
			result.traceHeight = Mathf.RoundToInt(0.25f * (float)height);
			result.viewCount = viewCount;
			result.needsTemporaryBuffer = hdCamera.msaaEnabled;
			result.cloudCombinePass = m_CloudCombinePass;
			result.needExtraColorBufferCopy = GetColorBufferFormat() == GraphicsFormat.B10G11R11_UFloatPack32 && (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D11 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Direct3D12 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Vulkan);
			result.needExtraColorBufferCopy &= !result.needsTemporaryBuffer;
			result.depthDownscaleKernel = m_CloudDownscaleDepthKernel;
			result.renderKernel = m_CloudRenderKernel;
			result.preUpscaleKernel = m_PreUpscaleCloudsKernel;
			result.upscaleAndCombineKernel = (result.needExtraColorBufferCopy ? m_UpscaleAndCombineCloudsKernelColorCopy : m_UpscaleAndCombineCloudsKernelColorRW);
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = result.commonData.cameraType;
			cameraData.traceWidth = result.traceWidth;
			cameraData.traceHeight = result.traceHeight;
			cameraData.intermediateWidth = result.intermediateWidth;
			cameraData.intermediateHeight = result.intermediateHeight;
			cameraData.finalWidth = result.finalWidth;
			cameraData.finalHeight = result.finalHeight;
			cameraData.viewCount = result.viewCount;
			cameraData.enableExposureControl = result.commonData.enableExposureControl;
			cameraData.lowResolution = true;
			cameraData.enableIntegration = false;
			UpdateShaderVariableslClouds(ref result.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: false);
			return result;
		}

		private static void TraceVolumetricClouds_LowResolution(CommandBuffer cmd, VolumetricCloudsParameters_LowResolution parameters, ComputeBuffer ambientProbeBuffer, RTHandle colorBuffer, RTHandle depthPyramid, RTHandle volumetricLightingTexture, RTHandle scatteringFallbackTexture, RTHandle maxZMask, RTHandle intermediateLightingBuffer0, RTHandle intermediateLightingBuffer1, RTHandle intermediateLightingBuffer2, RTHandle intermediateDepthBuffer0, RTHandle intermediateDepthBuffer1, RTHandle intermediateColorBuffer, RTHandle intermediateUpscaleBuffer)
		{
			int threadGroupsX = (parameters.traceWidth + 7) / 8;
			int threadGroupsY = (parameters.traceHeight + 7) / 8;
			int threadGroupsX2 = (parameters.intermediateWidth + 7) / 8;
			int threadGroupsY2 = (parameters.intermediateHeight + 7) / 8;
			int threadGroupsX3 = (parameters.finalWidth + 7) / 8;
			int threadGroupsY3 = (parameters.finalHeight + 7) / 8;
			BlueNoise.BindDitheredTextureSet(cmd, parameters.commonData.ditheredTextureSet);
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", parameters.commonData.localClouds);
			ConstantBuffer.Push(cmd, in parameters.commonData.cloudsCB, parameters.commonData.volumetricCloudsCS, HDShaderIDs._ShaderVariablesClouds);
			if (parameters.commonData.localClouds)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsPrepare)))
				{
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, HDShaderIDs._DepthTexture, depthPyramid);
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, HDShaderIDs._HalfResDepthBufferRW, intermediateDepthBuffer0);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.depthDownscaleKernel, threadGroupsX2, threadGroupsY2, parameters.viewCount);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsTrace)))
			{
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", parameters.commonData.cloudsCB._PhysicallyBasedSun == 1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._MaxZMaskTexture, maxZMask);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsSourceDepth, intermediateDepthBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._Worley128RGBA, parameters.commonData.worley128RGBA);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._ErosionNoise, parameters.commonData.erosionNoise);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudMapTexture, parameters.commonData.cloudMapTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudLutTexture, parameters.commonData.cloudLutTexture);
				cmd.SetComputeBufferParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._VolumetricCloudsAmbientProbeBuffer, ambientProbeBuffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsLightingTextureRW, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, HDShaderIDs._CloudsDepthTextureRW, intermediateDepthBuffer1);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.renderKernel, threadGroupsX, threadGroupsY, parameters.viewCount);
				CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", state: false);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsPreUpscale)))
			{
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, HDShaderIDs._CloudsLightingTexture, intermediateLightingBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, HDShaderIDs._CloudsDepthTexture, intermediateDepthBuffer1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, HDShaderIDs._HalfResDepthBuffer, intermediateDepthBuffer0);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, HDShaderIDs._CloudsLightingTextureRW, intermediateLightingBuffer1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, HDShaderIDs._CloudsAdditionalTextureRW, intermediateLightingBuffer2);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.preUpscaleKernel, threadGroupsX2, threadGroupsY2, parameters.viewCount);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsUpscaleAndCombine)))
			{
				if (parameters.needExtraColorBufferCopy)
				{
					HDUtils.BlitCameraTexture(cmd, colorBuffer, intermediateColorBuffer);
				}
				int upscaleAndCombineKernel = parameters.upscaleAndCombineKernel;
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsTexture, intermediateLightingBuffer1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._DepthStatusTexture, intermediateLightingBuffer2);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._DepthTexture, depthPyramid);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._CameraColorTexture, intermediateColorBuffer);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._VBufferLighting, volumetricLightingTexture);
				if (parameters.commonData.cloudsCB._PhysicallyBasedSun == 0)
				{
					cmd.SetGlobalTexture(HDShaderIDs._AirSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._AerosolSingleScatteringTexture, scatteringFallbackTexture);
					cmd.SetGlobalTexture(HDShaderIDs._MultipleScatteringTexture, scatteringFallbackTexture);
				}
				if (parameters.needsTemporaryBuffer)
				{
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: true);
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, threadGroupsX3, threadGroupsY3, parameters.viewCount);
					parameters.cloudCombinePass.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, intermediateUpscaleBuffer);
					HDUtils.DrawFullScreen(cmd, parameters.cloudCombinePass, colorBuffer);
					CoreUtils.SetKeyword(cmd, "USE_INTERMEDIATE_BUFFER", state: false);
				}
				else
				{
					cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.upscaleAndCombineKernel, HDShaderIDs._VolumetricCloudsUpscaleTextureRW, colorBuffer);
					cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, upscaleAndCombineKernel, threadGroupsX3, threadGroupsY3, parameters.viewCount);
				}
			}
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", state: false);
		}

		private TextureHandle RenderVolumetricClouds_LowResolution(RenderGraph renderGraph, HDCamera hdCamera, TVolumetricCloudsCameraType cameraType, TextureHandle colorBuffer, TextureHandle depthPyramid, TextureHandle motionVectors, TextureHandle volumetricLighting, TextureHandle maxZMask)
		{
			VolumetricCloudsLowResolutionData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<VolumetricCloudsLowResolutionData>("Generating the rays for RTR", out passData, ProfilingSampler.Get(HDProfileId.VolumetricClouds));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				VolumetricClouds component = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
				passData.parameters = PrepareVolumetricCloudsParameters_LowResolution(hdCamera, hdCamera.actualWidth, hdCamera.actualHeight, hdCamera.viewCount, hdCamera.exposureControlFS, component, cameraType);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData = passData;
				TextureHandle input = renderGraphBuilder.WriteTexture(in colorBuffer);
				volumetricCloudsLowResolutionData.colorBuffer = renderGraphBuilder.ReadTexture(in input);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.maxZMask = (component.localClouds.value ? renderGraph.defaultResources.blackTextureXR : renderGraphBuilder.ReadTexture(in maxZMask));
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData2 = passData;
				ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(m_CloudsDynamicProbeBuffer);
				volumetricCloudsLowResolutionData2.ambientProbeBuffer = renderGraphBuilder.ReadComputeBuffer(in input2);
				passData.volumetricLighting = renderGraphBuilder.ReadTexture(in volumetricLighting);
				passData.scatteringFallbackTexture = renderGraph.defaultResources.blackTexture3DXR;
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData3 = passData;
				TextureDesc desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 0"
				};
				volumetricCloudsLowResolutionData3.intermediateLightingBuffer0 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData4 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 1 "
				};
				volumetricCloudsLowResolutionData4.intermediateLightingBuffer1 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData5 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Lighting Buffer 2 "
				};
				volumetricCloudsLowResolutionData5.intermediateLightingBuffer2 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData6 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Depth Buffer 0"
				};
				volumetricCloudsLowResolutionData6.intermediateBufferDepth0 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData7 = passData;
				desc = new TextureDesc(Vector2.one * 0.5f, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Temporary Clouds Depth Buffer 1"
				};
				volumetricCloudsLowResolutionData7.intermediateBufferDepth1 = renderGraphBuilder.CreateTransientTexture(in desc);
				VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData8 = passData;
				TextureHandle intermediateColorBufferCopy;
				if (!passData.parameters.needExtraColorBufferCopy)
				{
					intermediateColorBufferCopy = renderGraph.defaultResources.blackTextureXR;
				}
				else
				{
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GetColorBufferFormat(),
						enableRandomWrite = true,
						name = "Temporary Color Buffer"
					};
					intermediateColorBufferCopy = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				volumetricCloudsLowResolutionData8.intermediateColorBufferCopy = intermediateColorBufferCopy;
				if (passData.parameters.needsTemporaryBuffer)
				{
					VolumetricCloudsLowResolutionData volumetricCloudsLowResolutionData9 = passData;
					desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
						enableRandomWrite = true,
						name = "Temporary Clouds Upscaling Buffer"
					};
					volumetricCloudsLowResolutionData9.intermediateBufferUpscale = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					passData.intermediateBufferUpscale = renderGraph.defaultResources.blackTexture;
				}
				renderGraphBuilder.SetRenderFunc(delegate(VolumetricCloudsLowResolutionData data, RenderGraphContext ctx)
				{
					TraceVolumetricClouds_LowResolution(ctx.cmd, data.parameters, data.ambientProbeBuffer, data.colorBuffer, data.depthPyramid, data.volumetricLighting, data.scatteringFallbackTexture, data.maxZMask, data.intermediateLightingBuffer0, data.intermediateLightingBuffer1, data.intermediateLightingBuffer2, data.intermediateBufferDepth0, data.intermediateBufferDepth1, data.intermediateColorBufferCopy, data.intermediateBufferUpscale);
				});
				return renderGraph.defaultResources.whiteTextureXR;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void InitializeVolumetricCloudsMap()
		{
			ComputeShader volumetricCloudMapGeneratorCS = m_Asset.renderPipelineResources.shaders.volumetricCloudMapGeneratorCS;
			m_EvaluateCloudMapKernel = volumetricCloudMapGeneratorCS.FindKernel("EvaluateCloudMap");
			m_CloudMapHash = 0;
		}

		private void ReleaseVolumetricCloudsMap()
		{
			RTHandles.Release(m_AdvancedCloudMap);
		}

		private static int EvaluateCurrentAdvancedHash(in VolumetricClouds settings)
		{
			int textureHash = HDUtils.GetTextureHash((settings.cumulusMap.value != null) ? settings.cumulusMap.value : Texture2D.blackTexture);
			textureHash = 23 * textureHash + settings.cumulusMapMultiplier.value.GetHashCode();
			textureHash = 23 * textureHash + HDUtils.GetTextureHash((settings.altoStratusMap.value != null) ? settings.altoStratusMap.value : Texture2D.blackTexture);
			textureHash = 23 * textureHash + settings.altoStratusMapMultiplier.value.GetHashCode();
			textureHash = 23 * textureHash + HDUtils.GetTextureHash((settings.cumulonimbusMap.value != null) ? settings.cumulonimbusMap.value : Texture2D.blackTexture);
			textureHash = 23 * textureHash + settings.cumulonimbusMapMultiplier.value.GetHashCode();
			textureHash = 23 * textureHash + HDUtils.GetTextureHash((settings.rainMap.value != null) ? settings.rainMap.value : Texture2D.blackTexture);
			return 23 * textureHash + settings.cloudMapResolution.value.GetHashCode();
		}

		private bool RequiresCloudMapBaking(HDCamera hdCamera, in VolumetricClouds settings)
		{
			bool flag = HasVolumetricClouds(hdCamera, in settings) && settings.cloudControl.value == VolumetricClouds.CloudControl.Advanced;
			if (flag)
			{
				int num = EvaluateCurrentAdvancedHash(in settings);
				if (m_CloudMapHash == num)
				{
					flag = false;
				}
				else
				{
					m_CloudMapHash = num;
				}
			}
			return flag;
		}

		private void AdjustCloudMapTextureSize(in VolumetricClouds settings)
		{
			int value = (int)settings.cloudMapResolution.value;
			bool flag = m_AdvancedCloudMap == null;
			if (m_AdvancedCloudMap != null && m_AdvancedCloudMap.rt.width != value)
			{
				RTHandles.Release(m_AdvancedCloudMap);
				flag = true;
			}
			if (flag)
			{
				m_AdvancedCloudMap = RTHandles.Alloc(value, value, 1, DepthBits.None, GraphicsFormat.R8G8B8A8_UNorm, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Volumetric Clouds Map");
			}
		}

		private CloudMapGenerationParameters PrepareCloudMapGenerationParameters(in VolumetricClouds settings)
		{
			CloudMapGenerationParameters result = default(CloudMapGenerationParameters);
			result.cloudMapResolution = (int)settings.cloudMapResolution.value;
			result.generationCS = m_Asset.renderPipelineResources.shaders.volumetricCloudMapGeneratorCS;
			result.generationKernel = m_EvaluateCloudMapKernel;
			result.cumulusMap = ((settings.cumulusMap.value != null) ? settings.cumulusMap.value : Texture2D.blackTexture);
			result.cumulusMapMultiplier = settings.cumulusMapMultiplier.value;
			result.altostratusMap = ((settings.altoStratusMap.value != null) ? settings.altoStratusMap.value : Texture2D.blackTexture);
			result.altoStratusMapMultiplier = settings.altoStratusMapMultiplier.value;
			result.cumulonimbusMap = ((settings.cumulonimbusMap.value != null) ? settings.cumulonimbusMap.value : Texture2D.blackTexture);
			result.cumulonimbusMapMultiplier = settings.cumulonimbusMapMultiplier.value;
			result.rainMap = ((settings.rainMap.value != null) ? settings.rainMap.value : Texture2D.blackTexture);
			return result;
		}

		private static void EvaluateVolumetricCLoudMap(CommandBuffer cmd, CloudMapGenerationParameters parameters, RTHandle outputCloudMap)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudMapGeneration)))
			{
				int threadGroupsX = (parameters.cloudMapResolution + 7) / 8;
				int threadGroupsY = (parameters.cloudMapResolution + 7) / 8;
				cmd.SetComputeIntParam(parameters.generationCS, HDShaderIDs._CloudMapResolution, parameters.cloudMapResolution);
				cmd.SetComputeTextureParam(parameters.generationCS, parameters.generationKernel, HDShaderIDs._CumulusMap, parameters.cumulusMap);
				cmd.SetComputeFloatParam(parameters.generationCS, HDShaderIDs._CumulusMapMultiplier, parameters.cumulusMapMultiplier);
				cmd.SetComputeTextureParam(parameters.generationCS, parameters.generationKernel, HDShaderIDs._AltostratusMap, parameters.altostratusMap);
				cmd.SetComputeFloatParam(parameters.generationCS, HDShaderIDs._AltostratusMapMultiplier, parameters.altoStratusMapMultiplier);
				cmd.SetComputeTextureParam(parameters.generationCS, parameters.generationKernel, HDShaderIDs._CumulonimbusMap, parameters.cumulonimbusMap);
				cmd.SetComputeFloatParam(parameters.generationCS, HDShaderIDs._CumulonimbusMapMultiplier, parameters.cumulonimbusMapMultiplier);
				cmd.SetComputeTextureParam(parameters.generationCS, parameters.generationKernel, HDShaderIDs._RainMap, parameters.rainMap);
				cmd.SetComputeTextureParam(parameters.generationCS, parameters.generationKernel, HDShaderIDs._CloudMapTextureRW, outputCloudMap);
				cmd.DispatchCompute(parameters.generationCS, parameters.generationKernel, threadGroupsX, threadGroupsY, 1);
			}
		}

		private void PreRenderVolumetricCloudMap(RenderGraph renderGraph, HDCamera hdCamera, in VolumetricClouds settings)
		{
			if (!RequiresCloudMapBaking(hdCamera, in settings))
			{
				return;
			}
			AdjustCloudMapTextureSize(in settings);
			VolumetricCloudsMapData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<VolumetricCloudsMapData>("Volumetric cloud map generation", out passData, ProfilingSampler.Get(HDProfileId.VolumetricCloudMapGeneration));
			renderGraphBuilder.EnableAsyncCompute(value: false);
			passData.parameters = PrepareCloudMapGenerationParameters(in settings);
			passData.cloudMapTexture = renderGraph.ImportTexture(m_AdvancedCloudMap);
			renderGraphBuilder.SetRenderFunc(delegate(VolumetricCloudsMapData data, RenderGraphContext ctx)
			{
				EvaluateVolumetricCLoudMap(ctx.cmd, data.parameters, data.cloudMapTexture);
			});
		}

		private void InitializeVolumetricCloudsShadows()
		{
			ComputeShader volumetricCloudsCS = m_Asset.renderPipelineResources.shaders.volumetricCloudsCS;
			m_ComputeShadowCloudsKernel = volumetricCloudsCS.FindKernel("ComputeVolumetricCloudsShadow");
			m_FilterShadowCloudsKernel = volumetricCloudsCS.FindKernel("FilterVolumetricCloudsShadow");
		}

		private void ReleaseVolumetricCloudsShadows()
		{
			for (int i = 0; i < 5; i++)
			{
				RTHandles.Release(m_VolumetricCloudsShadowTexture[i]);
			}
			RTHandles.Release(m_VolumetricCloudsIntermediateShadowTexture);
		}

		private bool HasVolumetricCloudsShadows(HDCamera hdCamera, in VolumetricClouds settings)
		{
			if (HasVolumetricClouds(hdCamera, in settings) && GetMainLight() != null)
			{
				return settings.shadows.value;
			}
			return false;
		}

		private bool HasVolumetricCloudsShadows(HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			return HasVolumetricCloudsShadows(hdCamera, in settings);
		}

		internal bool HasVolumetricCloudsShadows_IgnoreSun(HDCamera hdCamera, in VolumetricClouds settings)
		{
			if (HasVolumetricClouds(hdCamera, in settings))
			{
				return settings.shadows.value;
			}
			return false;
		}

		internal bool HasVolumetricCloudsShadows_IgnoreSun(HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			return HasVolumetricCloudsShadows_IgnoreSun(hdCamera, in settings);
		}

		private VolumetricCloudsShadowsParameters PrepareVolumetricCloudsShadowsParameters(HDCamera hdCamera, VolumetricClouds settings)
		{
			VolumetricCloudsShadowsParameters result = default(VolumetricCloudsShadowsParameters);
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(enableExposureControl: false, settings, TVolumetricCloudsCameraType.Default, in cloudModelData, ref result.commonData);
			result.shadowsKernel = m_ComputeShadowCloudsKernel;
			result.filterShadowsKernel = m_FilterShadowCloudsKernel;
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = result.commonData.cameraType;
			cameraData.traceWidth = 1;
			cameraData.traceHeight = 1;
			cameraData.intermediateWidth = 1;
			cameraData.intermediateHeight = 1;
			cameraData.finalWidth = 1;
			cameraData.finalHeight = 1;
			cameraData.viewCount = 1;
			cameraData.enableExposureControl = false;
			cameraData.lowResolution = false;
			cameraData.enableIntegration = false;
			UpdateShaderVariableslClouds(ref result.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: true);
			return result;
		}

		private static void TraceVolumetricCloudShadow(CommandBuffer cmd, VolumetricCloudsShadowsParameters parameters, RTHandle intermediateTexture, RTHandle shadowTexture)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.VolumetricCloudsShadow)))
			{
				CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", parameters.commonData.localClouds);
				ConstantBuffer.Push(cmd, in parameters.commonData.cloudsCB, parameters.commonData.volumetricCloudsCS, HDShaderIDs._ShaderVariablesClouds);
				int threadGroupsX = (parameters.commonData.cloudsCB._ShadowCookieResolution + 7) / 8;
				int threadGroupsY = (parameters.commonData.cloudsCB._ShadowCookieResolution + 7) / 8;
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, HDShaderIDs._CloudMapTexture, parameters.commonData.cloudMapTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, HDShaderIDs._CloudLutTexture, parameters.commonData.cloudLutTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, HDShaderIDs._Worley128RGBA, parameters.commonData.worley128RGBA);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, HDShaderIDs._ErosionNoise, parameters.commonData.erosionNoise);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, HDShaderIDs._VolumetricCloudsShadowRW, shadowTexture);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.shadowsKernel, threadGroupsX, threadGroupsY, 1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, HDShaderIDs._VolumetricCloudsShadow, shadowTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, HDShaderIDs._VolumetricCloudsShadowRW, intermediateTexture);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, threadGroupsX, threadGroupsY, 1);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, HDShaderIDs._VolumetricCloudsShadow, intermediateTexture);
				cmd.SetComputeTextureParam(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, HDShaderIDs._VolumetricCloudsShadowRW, shadowTexture);
				cmd.DispatchCompute(parameters.commonData.volumetricCloudsCS, parameters.filterShadowsKernel, threadGroupsX, threadGroupsY, 1);
				shadowTexture.rt.IncrementUpdateCount();
			}
		}

		private RTHandle RequestVolumetricCloudsShadowTexture(HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			return RequestVolumetricCloudsShadowTexture(in settings);
		}

		private RTHandle RequestVolumetricCloudsShadowTexture(in VolumetricClouds settings)
		{
			int value = (int)settings.shadowResolution.value;
			int num = 0;
			switch (settings.shadowResolution.value)
			{
			case VolumetricClouds.CloudShadowResolution.VeryLow64:
				num = 0;
				break;
			case VolumetricClouds.CloudShadowResolution.Low128:
				num = 1;
				break;
			case VolumetricClouds.CloudShadowResolution.Medium256:
				num = 2;
				break;
			case VolumetricClouds.CloudShadowResolution.High512:
				num = 3;
				break;
			case VolumetricClouds.CloudShadowResolution.Ultra1024:
				num = 4;
				break;
			}
			if (m_VolumetricCloudsShadowTexture[num] == null)
			{
				m_VolumetricCloudsShadowTexture[num] = RTHandles.Alloc(value, value, 1, DepthBits.None, GraphicsFormat.B10G11R11_UFloatPack32, FilterMode.Bilinear, TextureWrapMode.Clamp, TextureDimension.Tex2D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Volumetric Clouds Shadow Texture");
			}
			return m_VolumetricCloudsShadowTexture[num];
		}

		internal CookieParameters RenderVolumetricCloudsShadows(CommandBuffer cmd, HDCamera hdCamera)
		{
			VolumetricClouds settings = hdCamera.volumeStack.GetComponent<VolumetricClouds>();
			if (!HasVolumetricCloudsShadows(hdCamera, in settings))
			{
				return default(CookieParameters);
			}
			RTHandle rTHandle = RequestVolumetricCloudsShadowTexture(in settings);
			if (m_VolumetricCloudsIntermediateShadowTexture == null)
			{
				m_VolumetricCloudsIntermediateShadowTexture = RTHandles.Alloc(1024, 1024, 1, DepthBits.None, GraphicsFormat.B10G11R11_UFloatPack32, FilterMode.Point, TextureWrapMode.Clamp, TextureDimension.Tex2D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Intermediate Volumetric Clouds Shadow Texture");
			}
			VolumetricCloudsShadowsParameters parameters = PrepareVolumetricCloudsShadowsParameters(hdCamera, settings);
			TraceVolumetricCloudShadow(cmd, parameters, m_VolumetricCloudsIntermediateShadowTexture, rTHandle);
			Light mainLight = GetMainLight();
			float num = settings.shadowDistance.value * 2f;
			float num2 = Mathf.Abs(Vector3.Dot(mainLight.transform.right, Vector3.Normalize(new Vector3(mainLight.transform.right.x, 0f, mainLight.transform.right.z))));
			float num3 = Mathf.Abs(Vector3.Dot(mainLight.transform.up, Vector3.Normalize(new Vector3(mainLight.transform.up.x, 0f, mainLight.transform.up.z))));
			Vector2 size = new Vector2(num * num2, num * num3);
			Vector3 worldSpaceCameraPos = hdCamera.mainViewConstants.worldSpaceCameraPos;
			worldSpaceCameraPos.y = settings.shadowPlaneHeightOffset.value;
			CookieParameters result = default(CookieParameters);
			result.texture = rTHandle;
			result.size = size;
			result.position = worldSpaceCameraPos;
			return result;
		}

		private TextureDesc GetVolumetricCloudsIntermediateLightingBufferDesc()
		{
			int skyReflectionSize = (int)m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
			TextureDesc result = new TextureDesc(skyReflectionSize, skyReflectionSize, dynamicResolution: false, xrReady: true);
			result.colorFormat = GraphicsFormat.R16G16B16A16_SFloat;
			result.enableRandomWrite = true;
			return result;
		}

		private TextureDesc GetVolumetricCloudsIntermediateDepthBufferDesc()
		{
			int skyReflectionSize = (int)m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
			TextureDesc result = new TextureDesc(skyReflectionSize, skyReflectionSize, dynamicResolution: false, xrReady: true);
			result.colorFormat = GraphicsFormat.R32_SFloat;
			result.enableRandomWrite = true;
			return result;
		}

		private TextureDesc GetVolumetricCloudsIntermediateCubeTextureDesc()
		{
			int skyReflectionSize = (int)m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
			TextureDesc result = new TextureDesc(skyReflectionSize, skyReflectionSize);
			result.slices = TextureXR.slices;
			result.dimension = TextureDimension.Cube;
			result.colorFormat = GraphicsFormat.R16G16B16A16_SFloat;
			result.enableRandomWrite = true;
			result.useMipMap = true;
			result.autoGenerateMips = false;
			return result;
		}

		private void PrepareVolumetricCloudsSkyLowPassData(RenderGraph renderGraph, RenderGraphBuilder builder, HDCamera hdCamera, int width, int height, Matrix4x4[] pixelCoordToViewDir, CubemapFace cubemapFace, VolumetricClouds settings, ComputeBuffer ambientProbeBuffer, VolumetricCloudsSkyLowPassData data)
		{
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(enableExposureControl: false, settings, TVolumetricCloudsCameraType.Sky, in cloudModelData, ref data.commonData);
			data.finalWidth = width;
			data.finalHeight = height;
			data.intermediateWidth = Mathf.RoundToInt(0.5f * (float)width);
			data.intermediateHeight = Mathf.RoundToInt(0.5f * (float)height);
			data.traceWidth = Mathf.RoundToInt(0.25f * (float)width);
			data.traceHeight = Mathf.RoundToInt(0.25f * (float)height);
			data.cubemapFace = cubemapFace;
			data.cloudCombinePass = m_CloudCombinePass;
			data.renderKernel = m_CloudRenderKernel;
			data.preUpscaleKernel = m_PreUpscaleCloudsSkyKernel;
			data.finalUpscaleKernel = m_UpscaleAndCombineCloudsSkyKernel;
			data.pixelCoordToViewDir = pixelCoordToViewDir;
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = data.commonData.cameraType;
			cameraData.traceWidth = data.traceWidth;
			cameraData.traceHeight = data.traceHeight;
			cameraData.intermediateWidth = data.intermediateWidth;
			cameraData.intermediateHeight = data.intermediateHeight;
			cameraData.finalWidth = data.finalWidth;
			cameraData.finalHeight = data.finalHeight;
			cameraData.viewCount = 1;
			cameraData.enableExposureControl = data.commonData.enableExposureControl;
			cameraData.lowResolution = true;
			cameraData.enableIntegration = false;
			UpdateShaderVariableslClouds(ref data.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: false);
			_ = m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
			TextureDesc desc = GetVolumetricCloudsIntermediateLightingBufferDesc();
			data.intermediateLightingBuffer = builder.CreateTransientTexture(in desc);
			desc = GetVolumetricCloudsIntermediateDepthBufferDesc();
			data.intermediateDepthBuffer = builder.CreateTransientTexture(in desc);
			desc = GetVolumetricCloudsIntermediateCubeTextureDesc();
			TextureHandle input = renderGraph.CreateTexture(in desc);
			data.output = builder.WriteTexture(in input);
			input = renderGraph.defaultResources.blackTextureXR;
			data.maxZMask = builder.ReadTexture(in input);
			ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(ambientProbeBuffer);
			data.ambientProbeBuffer = builder.ReadComputeBuffer(in input2);
		}

		private static void TraceVolumetricClouds_Sky_Low(CommandBuffer cmd, VolumetricCloudsSkyLowPassData passData, MaterialPropertyBlock mpb)
		{
			int threadGroupsX = (passData.traceWidth + 7) / 8;
			int threadGroupsY = (passData.traceHeight + 7) / 8;
			BlueNoise.BindDitheredTextureSet(cmd, passData.commonData.ditheredTextureSet);
			ConstantBuffer.Push(cmd, in passData.commonData.cloudsCB, passData.commonData.volumetricCloudsCS, HDShaderIDs._ShaderVariablesClouds);
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", state: false);
			CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", passData.commonData.cloudsCB._PhysicallyBasedSun == 1);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._MaxZMaskTexture, passData.maxZMask);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._Worley128RGBA, passData.commonData.worley128RGBA);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._ErosionNoise, passData.commonData.erosionNoise);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudMapTexture, passData.commonData.cloudMapTexture);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudLutTexture, passData.commonData.cloudLutTexture);
			cmd.SetComputeBufferParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._VolumetricCloudsAmbientProbeBuffer, passData.ambientProbeBuffer);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudsLightingTextureRW, passData.intermediateLightingBuffer);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudsDepthTextureRW, passData.intermediateDepthBuffer);
			cmd.DispatchCompute(passData.commonData.volumetricCloudsCS, passData.renderKernel, threadGroupsX, threadGroupsY, 1);
			CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", state: false);
			mpb.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, passData.intermediateLightingBuffer);
			CoreUtils.SetRenderTarget(cmd, passData.output, ClearFlag.None, 2, passData.cubemapFace);
			CoreUtils.DrawFullScreen(cmd, passData.cloudCombinePass, mpb, 3);
		}

		private void PrepareVolumetricCloudsSkyHighPassData(RenderGraph renderGraph, RenderGraphBuilder builder, HDCamera hdCamera, int width, int height, Matrix4x4[] pixelCoordToViewDir, CubemapFace cubemapFace, VolumetricClouds settings, ComputeBuffer ambientProbeBuffer, TextureHandle output, VolumetricCloudsSkyHighPassData data)
		{
			CloudModelData cloudModelData = GetCloudModelData(settings);
			FillVolumetricCloudsCommonData(enableExposureControl: false, settings, TVolumetricCloudsCameraType.Sky, in cloudModelData, ref data.commonData);
			data.finalWidth = width;
			data.finalHeight = height;
			data.cubemapFace = cubemapFace;
			data.cloudCombinePass = m_CloudCombinePass;
			data.renderKernel = m_CloudRenderKernel;
			data.combineKernel = m_CombineCloudsSkyKernel;
			data.pixelCoordToViewDir = pixelCoordToViewDir;
			VolumetricCloudsCameraData cameraData = default(VolumetricCloudsCameraData);
			cameraData.cameraType = data.commonData.cameraType;
			cameraData.traceWidth = data.finalWidth;
			cameraData.traceHeight = data.finalHeight;
			cameraData.intermediateWidth = data.finalWidth;
			cameraData.intermediateHeight = data.finalHeight;
			cameraData.finalWidth = data.finalWidth;
			cameraData.finalHeight = data.finalHeight;
			cameraData.viewCount = 1;
			cameraData.enableExposureControl = data.commonData.enableExposureControl;
			cameraData.lowResolution = false;
			cameraData.enableIntegration = false;
			UpdateShaderVariableslClouds(ref data.commonData.cloudsCB, hdCamera, settings, in cameraData, in cloudModelData, shadowPass: false);
			_ = m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
			TextureDesc desc = GetVolumetricCloudsIntermediateLightingBufferDesc();
			data.intermediateLightingBuffer0 = builder.CreateTransientTexture(in desc);
			desc = GetVolumetricCloudsIntermediateDepthBufferDesc();
			data.intermediateDepthBuffer = builder.CreateTransientTexture(in desc);
			if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal)
			{
				desc = GetVolumetricCloudsIntermediateLightingBufferDesc();
				data.intermediateLightingBuffer1 = builder.CreateTransientTexture(in desc);
				data.output = builder.ReadWriteTexture(in output);
			}
			else
			{
				data.output = builder.WriteTexture(in output);
			}
			TextureHandle input = renderGraph.defaultResources.blackTextureXR;
			data.maxZMask = builder.ReadTexture(in input);
			ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(ambientProbeBuffer);
			data.ambientProbeBuffer = builder.ReadComputeBuffer(in input2);
		}

		private static void RenderVolumetricClouds_Sky_High(CommandBuffer cmd, VolumetricCloudsSkyHighPassData passData, MaterialPropertyBlock mpb)
		{
			int threadGroupsX = (passData.finalWidth + 7) / 8;
			int threadGroupsY = (passData.finalHeight + 7) / 8;
			BlueNoise.BindDitheredTextureSet(cmd, passData.commonData.ditheredTextureSet);
			CoreUtils.SetKeyword(cmd, "LOCAL_VOLUMETRIC_CLOUDS", state: false);
			ConstantBuffer.Push(cmd, in passData.commonData.cloudsCB, passData.commonData.volumetricCloudsCS, HDShaderIDs._ShaderVariablesClouds);
			CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", passData.commonData.cloudsCB._PhysicallyBasedSun == 1);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._MaxZMaskTexture, passData.maxZMask);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._Worley128RGBA, passData.commonData.worley128RGBA);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._ErosionNoise, passData.commonData.erosionNoise);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudMapTexture, passData.commonData.cloudMapTexture);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudLutTexture, passData.commonData.cloudLutTexture);
			cmd.SetComputeBufferParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._VolumetricCloudsAmbientProbeBuffer, passData.ambientProbeBuffer);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudsLightingTextureRW, passData.intermediateLightingBuffer0);
			cmd.SetComputeTextureParam(passData.commonData.volumetricCloudsCS, passData.renderKernel, HDShaderIDs._CloudsDepthTextureRW, passData.intermediateDepthBuffer);
			cmd.DispatchCompute(passData.commonData.volumetricCloudsCS, passData.renderKernel, threadGroupsX, threadGroupsY, 1);
			CoreUtils.SetKeyword(cmd, "PHYSICALLY_BASED_SUN", state: false);
			if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal)
			{
				cmd.CopyTexture(passData.output, (int)passData.cubemapFace, 0, passData.intermediateLightingBuffer1, 0, 0);
				mpb.SetTexture(HDShaderIDs._CameraColorTexture, passData.intermediateLightingBuffer1);
				mpb.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, passData.intermediateLightingBuffer0);
				CoreUtils.SetRenderTarget(cmd, passData.output, ClearFlag.None, 0, passData.cubemapFace);
				CoreUtils.DrawFullScreen(cmd, passData.cloudCombinePass, mpb, 1);
			}
			else
			{
				mpb.SetTexture(HDShaderIDs._VolumetricCloudsUpscaleTextureRW, passData.intermediateLightingBuffer0);
				CoreUtils.SetRenderTarget(cmd, passData.output, ClearFlag.None, 0, passData.cubemapFace);
				CoreUtils.DrawFullScreen(cmd, passData.cloudCombinePass, mpb, 2);
			}
		}

		internal TextureHandle RenderVolumetricClouds_Sky(RenderGraph renderGraph, HDCamera hdCamera, Matrix4x4[] pixelCoordToViewDir, VolumetricClouds settings, int width, int height, ComputeBuffer probeBuffer, TextureHandle skyboxCubemap)
		{
			if (!HasVolumetricClouds(hdCamera, in settings))
			{
				return skyboxCubemap;
			}
			VolumetricCloudsSkyHighPassData passData;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.FullResolutionCloudsForSky))
			{
				using (RenderGraphBuilder builder = renderGraph.AddRenderPass<VolumetricCloudsSkyHighPassData>("FullResolutionCloudsForSky", out passData, ProfilingSampler.Get(HDProfileId.VolumetricCloudsTrace)))
				{
					PrepareVolumetricCloudsSkyHighPassData(renderGraph, builder, hdCamera, width, height, pixelCoordToViewDir, CubemapFace.Unknown, settings, probeBuffer, skyboxCubemap, passData);
					builder.SetRenderFunc(delegate(VolumetricCloudsSkyHighPassData data, RenderGraphContext ctx)
					{
						for (int l = 0; l < 6; l++)
						{
							data.cubemapFace = (CubemapFace)l;
							data.commonData.cloudsCB._CloudsPixelCoordToViewDirWS = data.pixelCoordToViewDir[l];
							data.commonData.cloudsCB._ValidMaxZMask = 0;
							RenderVolumetricClouds_Sky_High(ctx.cmd, data, ctx.renderGraphPool.GetTempMaterialPropertyBlock());
						}
					});
					return passData.output;
				}
			}
			VolumetricCloudsSkyLowPassData passData2;
			TextureHandle input;
			using (RenderGraphBuilder builder2 = renderGraph.AddRenderPass<VolumetricCloudsSkyLowPassData>("LowResolutionCloudsForSky", out passData2, ProfilingSampler.Get(HDProfileId.VolumetricCloudsTrace)))
			{
				PrepareVolumetricCloudsSkyLowPassData(renderGraph, builder2, hdCamera, width, height, pixelCoordToViewDir, CubemapFace.Unknown, settings, probeBuffer, passData2);
				builder2.SetRenderFunc(delegate(VolumetricCloudsSkyLowPassData data, RenderGraphContext ctx)
				{
					for (int k = 0; k < 6; k++)
					{
						data.cubemapFace = (CubemapFace)k;
						data.commonData.cloudsCB._CloudsPixelCoordToViewDirWS = data.pixelCoordToViewDir[k];
						data.commonData.cloudsCB._ValidMaxZMask = 0;
						TraceVolumetricClouds_Sky_Low(ctx.cmd, data, ctx.renderGraphPool.GetTempMaterialPropertyBlock());
					}
				});
				input = passData2.output;
			}
			VolumetricCloudsPreUpscalePassData passData3;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<VolumetricCloudsPreUpscalePassData>("VolumetricCloudsPreUpscale", out passData3, ProfilingSampler.Get(HDProfileId.VolumetricCloudsPreUpscale));
			try
			{
				_ = m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize;
				passData3.cloudCombinePass = m_CloudCombinePass;
				passData3.pixelCoordToViewDir = pixelCoordToViewDir;
				passData3.input = renderGraphBuilder.ReadTexture(in input);
				VolumetricCloudsPreUpscalePassData volumetricCloudsPreUpscalePassData = passData3;
				TextureDesc desc = GetVolumetricCloudsIntermediateCubeTextureDesc();
				TextureHandle input2 = renderGraph.CreateTexture(in desc);
				volumetricCloudsPreUpscalePassData.output = renderGraphBuilder.WriteTexture(in input2);
				renderGraphBuilder.SetRenderFunc(delegate(VolumetricCloudsPreUpscalePassData data, RenderGraphContext ctx)
				{
					for (int j = 0; j < 6; j++)
					{
						MaterialPropertyBlock tempMaterialPropertyBlock2 = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
						tempMaterialPropertyBlock2.Clear();
						tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._VolumetricCloudsTexture, data.input);
						tempMaterialPropertyBlock2.SetMatrix(HDShaderIDs._PixelCoordToViewDirWS, data.pixelCoordToViewDir[j]);
						tempMaterialPropertyBlock2.SetInt(HDShaderIDs._Mipmap, 2);
						CoreUtils.SetRenderTarget(ctx.cmd, data.output, ClearFlag.None, 1, (CubemapFace)j);
						CoreUtils.DrawFullScreen(ctx.cmd, data.cloudCombinePass, tempMaterialPropertyBlock2, 4);
					}
				});
				input = passData3.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			VolumetricCloudsUpscalePassData passData4;
			RenderGraphBuilder renderGraphBuilder2 = renderGraph.AddRenderPass<VolumetricCloudsUpscalePassData>("VolumetricCloudsUpscaleAndCombine", out passData4, ProfilingSampler.Get(HDProfileId.VolumetricCloudsUpscaleAndCombine));
			try
			{
				passData4.cloudCombinePass = m_CloudCombinePass;
				passData4.pixelCoordToViewDir = pixelCoordToViewDir;
				passData4.input = renderGraphBuilder2.ReadTexture(in input);
				if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal)
				{
					VolumetricCloudsUpscalePassData volumetricCloudsUpscalePassData = passData4;
					TextureDesc desc = GetVolumetricCloudsIntermediateLightingBufferDesc();
					volumetricCloudsUpscalePassData.intermediateBuffer = renderGraphBuilder2.CreateTransientTexture(in desc);
					passData4.output = renderGraphBuilder2.ReadWriteTexture(in skyboxCubemap);
				}
				else
				{
					passData4.output = renderGraphBuilder2.WriteTexture(in skyboxCubemap);
				}
				renderGraphBuilder2.SetRenderFunc(delegate(VolumetricCloudsUpscalePassData data, RenderGraphContext ctx)
				{
					for (int i = 0; i < 6; i++)
					{
						MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
						if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal)
						{
							ctx.cmd.CopyTexture(data.output, i, 0, data.intermediateBuffer, 0, 0);
							tempMaterialPropertyBlock.Clear();
							tempMaterialPropertyBlock.SetTexture(HDShaderIDs._CameraColorTexture, data.intermediateBuffer);
							tempMaterialPropertyBlock.SetTexture(HDShaderIDs._VolumetricCloudsTexture, data.input);
							tempMaterialPropertyBlock.SetMatrix(HDShaderIDs._PixelCoordToViewDirWS, data.pixelCoordToViewDir[i]);
							tempMaterialPropertyBlock.SetInt(HDShaderIDs._Mipmap, 1);
							CoreUtils.SetRenderTarget(ctx.cmd, data.output, ClearFlag.None, 0, (CubemapFace)i);
							CoreUtils.DrawFullScreen(ctx.cmd, data.cloudCombinePass, tempMaterialPropertyBlock, 5);
						}
						else
						{
							tempMaterialPropertyBlock.Clear();
							tempMaterialPropertyBlock.SetTexture(HDShaderIDs._VolumetricCloudsTexture, data.input);
							tempMaterialPropertyBlock.SetMatrix(HDShaderIDs._PixelCoordToViewDirWS, data.pixelCoordToViewDir[i]);
							tempMaterialPropertyBlock.SetInt(HDShaderIDs._Mipmap, 1);
							CoreUtils.SetRenderTarget(ctx.cmd, data.output, ClearFlag.None, 0, (CubemapFace)i);
							CoreUtils.DrawFullScreen(ctx.cmd, data.cloudCombinePass, tempMaterialPropertyBlock, 6);
						}
					}
				});
				return passData4.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder2).Dispose();
			}
		}

		internal static void SafeDestroy(ref RenderTexture rt)
		{
			if (rt != null)
			{
				rt.Release();
				Object.DestroyImmediate(rt);
			}
		}

		private static uint VolumetricFrameIndex(HDCamera hdCamera)
		{
			return hdCamera.GetCameraFrameCount() % 14;
		}

		private static void ComputeVolumetricFogSliceCountAndScreenFraction(Fog fog, out int sliceCount, out float screenFraction)
		{
			if (fog.fogControlMode == FogControl.Balance)
			{
				float b = (1f - fog.resolutionDepthRatio) * 43.75f + 6.25f;
				screenFraction = Mathf.Lerp(6.25f, b, fog.volumetricFogBudget) * 0.01f;
				float b2 = Mathf.Max(1f, fog.resolutionDepthRatio * 512f);
				sliceCount = (int)Mathf.Lerp(1f, b2, fog.volumetricFogBudget);
			}
			else
			{
				screenFraction = fog.screenResolutionPercentage.value * 0.01f;
				sliceCount = fog.volumeSliceCount.value;
			}
		}

		internal static Vector3Int ComputeVolumetricViewportSize(HDCamera hdCamera, ref float voxelSize)
		{
			Fog component = hdCamera.volumeStack.GetComponent<Fog>();
			int actualWidth = hdCamera.actualWidth;
			int actualHeight = hdCamera.actualHeight;
			ComputeVolumetricFogSliceCountAndScreenFraction(component, out var sliceCount, out var screenFraction);
			if (component.fogControlMode == FogControl.Balance)
			{
				voxelSize = 1f / screenFraction;
			}
			else if (component.screenResolutionPercentage.value == 12.5f)
			{
				voxelSize = 8f;
			}
			else
			{
				voxelSize = 1f / screenFraction;
			}
			int x = Mathf.RoundToInt((float)actualWidth * screenFraction);
			int y = Mathf.RoundToInt((float)actualHeight * screenFraction);
			int z = hdCamera.viewCount * Mathf.CeilToInt(sliceCount / hdCamera.viewCount);
			return new Vector3Int(x, y, z);
		}

		internal static VBufferParameters ComputeVolumetricBufferParameters(HDCamera hdCamera)
		{
			Fog component = hdCamera.volumeStack.GetComponent<Fog>();
			float voxelSize = 0f;
			return new VBufferParameters(ComputeVolumetricViewportSize(hdCamera, ref voxelSize), component.depthExtent.value, hdCamera.camera.nearClipPlane, hdCamera.camera.farClipPlane, hdCamera.camera.fieldOfView, component.sliceDistributionUniformity.value, voxelSize);
		}

		internal static void ReinitializeVolumetricBufferParams(HDCamera hdCamera)
		{
			if (!Fog.IsVolumetricFogEnabled(hdCamera))
			{
				return;
			}
			bool num = Fog.IsVolumetricFogEnabled(hdCamera);
			bool flag = hdCamera.vBufferParams != null;
			if (num ^ flag)
			{
				if (flag)
				{
					hdCamera.vBufferParams = null;
					return;
				}
				VBufferParameters vBufferParameters = ComputeVolumetricBufferParameters(hdCamera);
				hdCamera.vBufferParams = new VBufferParameters[2];
				hdCamera.vBufferParams[0] = vBufferParameters;
				hdCamera.vBufferParams[1] = vBufferParameters;
			}
		}

		internal static void UpdateVolumetricBufferParams(HDCamera hdCamera)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				VBufferParameters vBufferParameters = ComputeVolumetricBufferParameters(hdCamera);
				uint num = VolumetricFrameIndex(hdCamera);
				int num2 = (int)(num & 1);
				int num3 = (int)((num + 1) & 1);
				hdCamera.vBufferParams[num2] = vBufferParameters;
				if ((float)hdCamera.vBufferParams[num3].viewportSize.x == 0f && (float)hdCamera.vBufferParams[num3].viewportSize.y == 0f)
				{
					hdCamera.vBufferParams[num3] = vBufferParameters;
				}
				s_CurrentVolumetricBufferSize = new Vector3Int(Math.Max(s_CurrentVolumetricBufferSize.x, vBufferParameters.viewportSize.x), Math.Max(s_CurrentVolumetricBufferSize.y, vBufferParameters.viewportSize.y), Math.Max(s_CurrentVolumetricBufferSize.z, vBufferParameters.viewportSize.z));
			}
		}

		internal static void ResizeVolumetricBuffer(ref RTHandle rt, string name, int viewportWidth, int viewportHeight, int viewportDepth)
		{
			int width = rt.rt.width;
			int height = rt.rt.height;
			int volumeDepth = rt.rt.volumeDepth;
			if (width < viewportWidth || height < viewportHeight || volumeDepth < viewportDepth)
			{
				RTHandles.Release(rt);
				width = Math.Max(width, viewportWidth);
				height = Math.Max(height, viewportHeight);
				volumeDepth = Math.Max(volumeDepth, viewportDepth);
				rt = RTHandles.Alloc(width, height, volumeDepth, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex3D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, name);
			}
		}

		private TextureHandle GenerateMaxZPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthTexture, HDUtils.PackedMipChainInfo depthMipInfo)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera) || VolumetricCloudsRequireMaxZ(hdCamera))
			{
				GenerateMaxZMaskPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GenerateMaxZMaskPassData>("Generate Max Z Mask for Volumetric", out passData);
				try
				{
					passData.generateMaxZCS = defaultResources.shaders.maxZCS;
					passData.generateMaxZCS.shaderKeywords = null;
					bool state = hdCamera.camera.cameraType == CameraType.Reflection && hdCamera.parentCamera != null;
					CoreUtils.SetKeyword(passData.generateMaxZCS, "PLANAR_OBLIQUE_DEPTH", state);
					passData.maxZKernel = passData.generateMaxZCS.FindKernel("ComputeMaxZ");
					passData.maxZDownsampleKernel = passData.generateMaxZCS.FindKernel("ComputeFinalMask");
					passData.dilateMaxZKernel = passData.generateMaxZCS.FindKernel("DilateMask");
					passData.intermediateMaskSize.x = HDUtils.DivRoundUp(hdCamera.actualWidth, 8);
					passData.intermediateMaskSize.y = HDUtils.DivRoundUp(hdCamera.actualHeight, 8);
					passData.finalMaskSize.x = passData.intermediateMaskSize.x / 2;
					passData.finalMaskSize.y = passData.intermediateMaskSize.y / 2;
					passData.minDepthMipOffset.x = depthMipInfo.mipLevelOffsets[4].x;
					passData.minDepthMipOffset.y = depthMipInfo.mipLevelOffsets[4].y;
					int num = (int)(VolumetricFrameIndex(hdCamera) & 1);
					if (hdCamera.vBufferParams != null)
					{
						VBufferParameters vBufferParameters = hdCamera.vBufferParams[num];
						float num2 = (float)vBufferParameters.viewportSize.x / (float)hdCamera.actualWidth;
						passData.dilationWidth = ((num2 < 0.1f) ? 2 : ((num2 < 0.5f) ? 1 : 0));
					}
					else
					{
						passData.dilationWidth = 1f;
					}
					passData.viewCount = hdCamera.viewCount;
					passData.depthTexture = renderGraphBuilder.ReadTexture(in depthTexture);
					GenerateMaxZMaskPassData generateMaxZMaskPassData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one * 0.125f, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "MaxZ mask 8x"
					};
					generateMaxZMaskPassData.maxZ8xBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
					GenerateMaxZMaskPassData generateMaxZMaskPassData2 = passData;
					desc = new TextureDesc(Vector2.one * 0.125f, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "MaxZ mask"
					};
					generateMaxZMaskPassData2.maxZBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
					GenerateMaxZMaskPassData generateMaxZMaskPassData3 = passData;
					desc = new TextureDesc(Vector2.one / 16f, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "Dilated MaxZ mask"
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					generateMaxZMaskPassData3.dilatedMaxZBuffer = renderGraphBuilder.ReadWriteTexture(in input);
					renderGraphBuilder.SetRenderFunc(delegate(GenerateMaxZMaskPassData data, RenderGraphContext ctx)
					{
						ComputeShader generateMaxZCS = data.generateMaxZCS;
						int maxZKernel = data.maxZKernel;
						int x = data.intermediateMaskSize.x;
						int y = data.intermediateMaskSize.y;
						int threadGroupsX = x;
						int threadGroupsY = y;
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._OutputTexture, data.maxZ8xBuffer);
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._CameraDepthTexture, data.depthTexture);
						ctx.cmd.DispatchCompute(generateMaxZCS, maxZKernel, threadGroupsX, threadGroupsY, data.viewCount);
						maxZKernel = data.maxZDownsampleKernel;
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._InputTexture, data.maxZ8xBuffer);
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._OutputTexture, data.maxZBuffer);
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._CameraDepthTexture, data.depthTexture);
						Vector4 val = new Vector4(x, y, data.minDepthMipOffset.x, data.minDepthMipOffset.y);
						ctx.cmd.SetComputeVectorParam(generateMaxZCS, HDShaderIDs._SrcOffsetAndLimit, val);
						ctx.cmd.SetComputeFloatParam(generateMaxZCS, HDShaderIDs._DilationWidth, data.dilationWidth);
						int num3 = Mathf.CeilToInt((float)x / 2f);
						int num4 = Mathf.CeilToInt((float)y / 2f);
						threadGroupsX = HDUtils.DivRoundUp(num3, 8);
						threadGroupsY = HDUtils.DivRoundUp(num4, 8);
						ctx.cmd.DispatchCompute(generateMaxZCS, maxZKernel, threadGroupsX, threadGroupsY, data.viewCount);
						maxZKernel = data.dilateMaxZKernel;
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._InputTexture, data.maxZBuffer);
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._OutputTexture, data.dilatedMaxZBuffer);
						ctx.cmd.SetComputeTextureParam(generateMaxZCS, maxZKernel, HDShaderIDs._CameraDepthTexture, data.depthTexture);
						val.x = num3;
						val.y = num4;
						ctx.cmd.SetComputeVectorParam(generateMaxZCS, HDShaderIDs._SrcOffsetAndLimit, val);
						ctx.cmd.DispatchCompute(generateMaxZCS, maxZKernel, threadGroupsX, threadGroupsY, data.viewCount);
					});
					return passData.dilatedMaxZBuffer;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return TextureHandle.nullHandle;
		}

		internal static void CreateVolumetricHistoryBuffers(HDCamera hdCamera, int bufferCount)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				hdCamera.volumetricHistoryBuffers = new RTHandle[bufferCount];
				for (int i = 0; i < bufferCount; i++)
				{
					hdCamera.volumetricHistoryBuffers[i] = RTHandles.Alloc(4, 4, 4, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex3D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"VBufferHistory{i}");
				}
				hdCamera.volumetricHistoryIsValid = false;
			}
		}

		internal static void DestroyVolumetricHistoryBuffers(HDCamera hdCamera)
		{
			if (hdCamera.volumetricHistoryBuffers != null)
			{
				int num = hdCamera.volumetricHistoryBuffers.Length;
				for (int i = 0; i < num; i++)
				{
					RTHandles.Release(hdCamera.volumetricHistoryBuffers[i]);
				}
				hdCamera.volumetricHistoryBuffers = null;
				hdCamera.volumetricHistoryIsValid = false;
			}
		}

		internal static void ResizeVolumetricHistoryBuffers(HDCamera hdCamera)
		{
			if (hdCamera.IsVolumetricReprojectionEnabled())
			{
				int num = (int)(VolumetricFrameIndex(hdCamera) & 1);
				VBufferParameters vBufferParameters = hdCamera.vBufferParams[num];
				if (hdCamera.volumetricHistoryBuffers[0] == null || hdCamera.volumetricHistoryBuffers[1] == null)
				{
					DestroyVolumetricHistoryBuffers(hdCamera);
					CreateVolumetricHistoryBuffers(hdCamera, hdCamera.vBufferParams.Length);
				}
				ResizeVolumetricBuffer(ref hdCamera.volumetricHistoryBuffers[num], volumetricHistoryBufferNames[num], vBufferParameters.viewportSize.x, vBufferParameters.viewportSize.y, vBufferParameters.viewportSize.z);
			}
		}

		internal void CreateVolumetricLightingBuffers()
		{
			m_VisibleVolumeBounds = new List<OrientedBBox>();
			m_VisibleVolumeData = new List<LocalVolumetricFogEngineData>();
			m_VisibleLocalVolumetricFogVolumes = new List<LocalVolumetricFog>();
			m_VisibleVolumeBoundsBuffer = new ComputeBuffer(1024, Marshal.SizeOf(typeof(OrientedBBox)));
			int count = 2048;
			m_VolumetricMaterialDataBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Structured, count, Marshal.SizeOf(typeof(VolumetricMaterialRenderingData)));
			m_VolumetricMaterialIndexBuffer = new GraphicsBuffer(GraphicsBuffer.Target.Index, 12, 4);
			m_VolumetricFogSortKeys = new NativeArray<uint>(asset.currentPlatformRenderPipelineSettings.lightLoopSettings.maxLocalVolumetricFogOnScreen, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			m_VolumetricFogSortKeysTemp = new NativeArray<uint>(asset.currentPlatformRenderPipelineSettings.lightLoopSettings.maxLocalVolumetricFogOnScreen, Allocator.Persistent, NativeArrayOptions.UninitializedMemory);
			m_VolumetricMaterialIndexBuffer.SetData(new List<uint>
			{
				0u, 1u, 2u, 0u, 2u, 3u, 0u, 3u, 4u, 0u,
				4u, 5u
			});
			m_DefaultVolumetricFogMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaderGraphs.defaultFogVolumeShader);
		}

		internal void DestroyVolumetricLightingBuffers()
		{
			CoreUtils.SafeRelease(m_VisibleVolumeBoundsBuffer);
			CoreUtils.SafeRelease(m_VolumetricMaterialIndexBuffer);
			CoreUtils.SafeRelease(m_VolumetricMaterialDataBuffer);
			CoreUtils.Destroy(m_DefaultVolumetricFogMaterial);
			if (m_VolumetricFogSortKeys.IsCreated)
			{
				m_VolumetricFogSortKeys.Dispose();
			}
			if (m_VolumetricFogSortKeysTemp.IsCreated)
			{
				m_VolumetricFogSortKeysTemp.Dispose();
			}
			m_VisibleVolumeData = null;
			m_VisibleVolumeBounds = null;
			m_VisibleLocalVolumetricFogVolumes = null;
		}

		private void InitializeVolumetricLighting()
		{
			m_SupportVolumetrics = asset.currentPlatformRenderPipelineSettings.supportVolumetrics;
			if (m_SupportVolumetrics)
			{
				m_VolumeVoxelizationCS = defaultResources.shaders.volumeVoxelizationCS;
				m_VolumetricLightingCS = defaultResources.shaders.volumetricLightingCS;
				m_VolumetricLightingFilteringCS = defaultResources.shaders.volumetricLightingFilteringCS;
				m_PackedCoeffs = new Vector4[7];
				m_PhaseZH = default(ZonalHarmonicsL2);
				m_PhaseZH.coeffs = new float[3];
				m_xySeq = new Vector2[7];
				m_PixelCoordToViewDirWS = new Matrix4x4[ShaderConfig.s_XrMaxViews];
				CreateVolumetricLightingBuffers();
			}
		}

		private void CleanupVolumetricLighting()
		{
			DestroyVolumetricLightingBuffers();
			m_VolumeVoxelizationCS = null;
			m_VolumetricLightingCS = null;
			m_VolumetricLightingFilteringCS = null;
		}

		private static float CornetteShanksPhasePartConstant(float anisotropy)
		{
			return 3f / (8f * MathF.PI) * (1f - anisotropy * anisotropy) / (2f + anisotropy * anisotropy);
		}

		private void UpdateShaderVariablesGlobalVolumetrics(ref ShaderVariablesGlobal cb, HDCamera hdCamera)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				Fog component = hdCamera.volumeStack.GetComponent<Fog>();
				uint num = hdCamera.GetCameraFrameCount() & 1u;
				VBufferParameters vBufferParameters = hdCamera.vBufferParams[num];
				Vector3Int viewportSize = vBufferParameters.viewportSize;
				uint num2 = (uint)(viewportSize.z / hdCamera.viewCount);
				cb._VBufferViewportSize = new Vector4(viewportSize.x, viewportSize.y, 1f / (float)viewportSize.x, 1f / (float)viewportSize.y);
				cb._VBufferSliceCount = num2;
				cb._FogGIDimmer = component.globalLightProbeDimmer.value;
				cb._VBufferRcpSliceCount = 1f / (float)num2;
				cb._VBufferLightingViewportScale = vBufferParameters.ComputeViewportScale(s_CurrentVolumetricBufferSize);
				cb._VBufferLightingViewportLimit = vBufferParameters.ComputeViewportLimit(s_CurrentVolumetricBufferSize);
				cb._VBufferDistanceEncodingParams = vBufferParameters.depthEncodingParams;
				cb._VBufferDistanceDecodingParams = vBufferParameters.depthDecodingParams;
				cb._VBufferLastSliceDist = vBufferParameters.ComputeLastSliceDistance(num2);
				cb._VBufferRcpInstancedViewCount = 1f / (float)hdCamera.viewCount;
			}
		}

		private uint PackFogVolumeSortKey(LocalVolumetricFog fog, int index)
		{
			int num = 524288;
			int num2 = (Mathf.Clamp(fog.parameters.priority, -num, num) + num) & 0xFFFFF;
			uint num3 = (uint)index & 0xFFFu;
			return (uint)(num2 << 12) | num3;
		}

		private static int UnpackFogVolumeIndex(uint sortKey)
		{
			return (int)(sortKey & 0xFFF);
		}

		private void PrepareVisibleLocalVolumetricFogList(HDCamera hdCamera, CommandBuffer cmd)
		{
			if (!Fog.IsVolumetricFogEnabled(hdCamera))
			{
				return;
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.PrepareVisibleLocalVolumetricFogList)))
			{
				Vector3 position = hdCamera.camera.transform.position;
				Vector3 vector = Vector3.zero;
				if (ShaderConfig.s_CameraRelativeRendering != 0)
				{
					vector = position;
				}
				m_VisibleVolumeBounds.Clear();
				m_VisibleVolumeData.Clear();
				m_VisibleLocalVolumetricFogVolumes.Clear();
				List<LocalVolumetricFog> list = LocalVolumetricFogManager.manager.PrepareLocalVolumetricFogData(cmd, hdCamera);
				int maxLocalVolumetricFogOnScreen = asset.currentPlatformRenderPipelineSettings.lightLoopSettings.maxLocalVolumetricFogOnScreen;
				Fog component = hdCamera.volumeStack.GetComponent<Fog>();
				foreach (LocalVolumetricFog item in list)
				{
					OrientedBBox orientedBBox = new OrientedBBox(Matrix4x4.TRS(item.transform.position, item.transform.rotation, item.parameters.size));
					float num = GeometryUtils.DistanceToOBB(orientedBBox, position) - hdCamera.camera.nearClipPlane;
					if (num > item.parameters.distanceFadeEnd || num > component.depthExtent.value)
					{
						continue;
					}
					orientedBBox.center -= vector;
					if (GeometryUtils.Overlap(orientedBBox, hdCamera.frustum, 6, 8))
					{
						if (m_VisibleLocalVolumetricFogVolumes.Count >= maxLocalVolumetricFogOnScreen)
						{
							Debug.LogError($"The number of local volumetric fog in the view is above the limit: {m_VisibleLocalVolumetricFogVolumes.Count} instead of {maxLocalVolumetricFogOnScreen}. To fix this, please increase the maximum number of local volumetric fog in the view in the HDRP asset.");
							break;
						}
						m_VisibleVolumeBounds.Add(orientedBBox);
						m_VisibleVolumeData.Add(item.parameters.ConvertToEngineData());
						m_VisibleLocalVolumetricFogVolumes.Add(item);
					}
				}
				for (int i = 0; i < m_VisibleLocalVolumetricFogVolumes.Count; i++)
				{
					m_VolumetricFogSortKeys[i] = PackFogVolumeSortKey(m_VisibleLocalVolumetricFogVolumes[i], i);
				}
				CoreUnsafeUtils.MergeSort(m_VolumetricFogSortKeys, m_VisibleLocalVolumetricFogVolumes.Count, ref m_VolumetricFogSortKeysTemp);
				m_VisibleVolumeBoundsBuffer.SetData(m_VisibleVolumeBounds);
			}
		}

		private unsafe void UpdateShaderVariableslVolumetrics(ref ShaderVariablesVolumetric cb, HDCamera hdCamera, in Vector4 resolution)
		{
			Fog component = hdCamera.volumeStack.GetComponent<Fog>();
			float verticalFoV = hdCamera.camera.GetGateFittedFieldOfView() * (MathF.PI / 180f);
			float aspect = HDUtils.ProjectionMatrixAspect(in hdCamera.mainViewConstants.projMatrix);
			int num = (int)VolumetricFrameIndex(hdCamera);
			hdCamera.GetPixelCoordToViewDirWS(resolution, aspect, ref m_PixelCoordToViewDirWS);
			for (int i = 0; i < m_PixelCoordToViewDirWS.Length; i++)
			{
				for (int j = 0; j < 16; j++)
				{
					cb._VBufferCoordToViewDirWS[i * 16 + j] = m_PixelCoordToViewDirWS[i][j];
				}
			}
			cb._VBufferUnitDepthTexelSpacing = HDUtils.ComputZPlaneTexelSpacing(1f, verticalFoV, resolution.y);
			cb._NumVisibleLocalVolumetricFog = (uint)m_VisibleLocalVolumetricFogVolumes.Count;
			cb._CornetteShanksConstant = CornetteShanksPhasePartConstant(component.anisotropy.value);
			cb._VBufferHistoryIsValid = (hdCamera.volumetricHistoryIsValid ? 1u : 0u);
			GetHexagonalClosePackedSpheres7(m_xySeq);
			int num2 = num % 7;
			Vector4 vBufferSampleOffset = default(Vector4);
			vBufferSampleOffset.Set(m_xySeq[num2].x, m_xySeq[num2].y, m_zSeq[num2], num);
			cb._VBufferSampleOffset = vBufferSampleOffset;
			int num3 = num & 1;
			int num4 = (num + 1) & 1;
			VBufferParameters vBufferParameters = hdCamera.vBufferParams[num3];
			VBufferParameters vBufferParameters2 = hdCamera.vBufferParams[num4];
			Vector3Int viewportSize = vBufferParameters2.viewportSize;
			Vector3Int bufferSize = Vector3Int.zero;
			if (hdCamera.IsVolumetricReprojectionEnabled())
			{
				RTHandle rTHandle = hdCamera.volumetricHistoryBuffers[num4];
				bufferSize = new Vector3Int(rTHandle.rt.width, rTHandle.rt.height, rTHandle.rt.volumeDepth);
			}
			cb._VBufferVoxelSize = vBufferParameters.voxelSize;
			cb._VBufferPrevViewportSize = new Vector4(viewportSize.x, viewportSize.y, 1f / (float)viewportSize.x, 1f / (float)viewportSize.y);
			cb._VBufferHistoryViewportScale = vBufferParameters2.ComputeViewportScale(bufferSize);
			cb._VBufferHistoryViewportLimit = vBufferParameters2.ComputeViewportLimit(bufferSize);
			cb._VBufferPrevDistanceEncodingParams = vBufferParameters2.depthEncodingParams;
			cb._VBufferPrevDistanceDecodingParams = vBufferParameters2.depthDecodingParams;
			cb._NumTileBigTileX = (uint)GetNumTileBigTileX(hdCamera);
			cb._NumTileBigTileY = (uint)GetNumTileBigTileY(hdCamera);
		}

		private TextureHandle ClearAndHeightFogVoxelizationPass(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				int num = (int)(VolumetricFrameIndex(hdCamera) & 1);
				VBufferParameters vBufferParameters = hdCamera.vBufferParams[num];
				HeightFogVoxelizationPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<HeightFogVoxelizationPassData>("Clear and Height Fog Voxelization", out passData);
				try
				{
					renderGraphBuilder.EnableAsyncCompute(hdCamera.frameSettings.VolumeVoxelizationRunsAsync());
					passData.viewCount = hdCamera.viewCount;
					passData.voxelizationCS = m_VolumeVoxelizationCS;
					passData.voxelizationKernel = 0;
					Vector3Int viewportSize = vBufferParameters.viewportSize;
					passData.resolution = new Vector4(viewportSize.x, viewportSize.y, 1f / (float)viewportSize.x, 1f / (float)viewportSize.y);
					UpdateShaderVariableslVolumetrics(ref m_ShaderVariablesVolumetricCB, hdCamera, in passData.resolution);
					passData.volumetricCB = m_ShaderVariablesVolumetricCB;
					passData.lightListCB = m_ShaderVariablesLightListCB;
					HeightFogVoxelizationPassData heightFogVoxelizationPassData = passData;
					TextureDesc desc = new TextureDesc(s_CurrentVolumetricBufferSize.x, s_CurrentVolumetricBufferSize.y)
					{
						slices = s_CurrentVolumetricBufferSize.z,
						colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
						dimension = TextureDimension.Tex3D,
						enableRandomWrite = true,
						name = "VBufferDensity"
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					heightFogVoxelizationPassData.densityBuffer = renderGraphBuilder.WriteTexture(in input);
					passData.volumetricAmbientProbeBuffer = m_SkyManager.GetVolumetricAmbientProbeBuffer(hdCamera);
					renderGraphBuilder.SetRenderFunc(delegate(HeightFogVoxelizationPassData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeTextureParam(data.voxelizationCS, data.voxelizationKernel, HDShaderIDs._VBufferDensity, data.densityBuffer);
						ctx.cmd.SetComputeBufferParam(data.voxelizationCS, data.voxelizationKernel, HDShaderIDs._VolumeAmbientProbeBuffer, data.volumetricAmbientProbeBuffer);
						ConstantBuffer.Push(ctx.cmd, in data.volumetricCB, data.voxelizationCS, HDShaderIDs._ShaderVariablesVolumetric);
						ctx.cmd.DispatchCompute(data.voxelizationCS, data.voxelizationKernel, ((int)data.resolution.x + 7) / 8, ((int)data.resolution.y + 7) / 8, data.viewCount);
					});
					return passData.densityBuffer;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return TextureHandle.nullHandle;
		}

		private TextureHandle FogVolumeVoxelizationPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle densityBuffer, ComputeBuffer visibleVolumeBoundsBuffer)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				if (!SystemInfo.supportsRenderTargetArrayIndexFromVertexShader)
				{
					Debug.LogError("Hardware not supported for Volumetric Materials");
					return densityBuffer;
				}
				if (m_VisibleLocalVolumetricFogVolumes.Count == 0)
				{
					return densityBuffer;
				}
				int maxLocalVolumetricFogOnScreen = asset.currentPlatformRenderPipelineSettings.lightLoopSettings.maxLocalVolumetricFogOnScreen;
				ComputeBufferDesc desc = new ComputeBufferDesc(hdCamera.viewCount * 5 * maxLocalVolumetricFogOnScreen, 4, ComputeBufferType.DrawIndirect)
				{
					name = "FogVolumeIndirectArguments"
				};
				ComputeBufferHandle input = renderGraph.CreateComputeBuffer(in desc);
				TextureHandle input2 = TextureHandle.nullHandle;
				bool flag = m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled() && m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.LocalVolumetricFogOverdraw;
				int num = (int)(VolumetricFrameIndex(hdCamera) & 1);
				VBufferParameters vBufferParameters = hdCamera.vBufferParams[num];
				LocalVolumetricFogMaterialVoxelizationPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<LocalVolumetricFogMaterialVoxelizationPassData>("Fog Volume Voxelization", out passData);
				try
				{
					passData.fog = hdCamera.volumeStack.GetComponent<Fog>();
					passData.densityBuffer = renderGraphBuilder.WriteTexture(in densityBuffer);
					passData.hdCamera = hdCamera;
					passData.volumetricMaterialCS = defaultResources.shaders.volumetricMaterialCS;
					passData.computeRenderingParametersKernel = passData.volumetricMaterialCS.FindKernel("ComputeVolumetricMaterialRenderingParameters");
					passData.visibleVolumeBoundsBuffer = visibleVolumeBoundsBuffer;
					passData.viewportSize = vBufferParameters.viewportSize;
					passData.volumetricFogs = m_VisibleLocalVolumetricFogVolumes;
					passData.materialDataBuffer = m_VolumetricMaterialDataBuffer;
					passData.defaultVolumetricMaterial = m_DefaultVolumetricFogMaterial;
					passData.visibleVolumeData = m_VisibleVolumeData;
					passData.visibleVolumeBounds = m_VisibleVolumeBounds;
					passData.triangleFanIndexBuffer = m_VolumetricMaterialIndexBuffer;
					passData.fogVolumeSortKeys = m_VolumetricFogSortKeys;
					if (flag)
					{
						LocalVolumetricFogMaterialVoxelizationPassData localVolumetricFogMaterialVoxelizationPassData = passData;
						TextureDesc desc2 = new TextureDesc(vBufferParameters.viewportSize.x, vBufferParameters.viewportSize.y, dynamicResolution: true, xrReady: true)
						{
							name = "Local Volumetric Fog Overdraw",
							colorFormat = GetColorBufferFormat(),
							clearBuffer = true,
							clearColor = Color.black
						};
						TextureHandle input3 = renderGraph.CreateTexture(in desc2);
						input2 = (localVolumetricFogMaterialVoxelizationPassData.fogOverdrawOutput = renderGraphBuilder.UseColorBuffer(in input3, 0));
					}
					passData.fogOverdrawDebugEnabled = flag;
					ComputeVolumetricFogSliceCountAndScreenFraction(passData.fog, out passData.maxSliceCount, out var _);
					passData.indirectArgumentBuffer = renderGraphBuilder.WriteComputeBuffer(in input);
					renderGraphBuilder.SetRenderFunc(delegate(LocalVolumetricFogMaterialVoxelizationPassData data, RenderGraphContext ctx)
					{
						int count = data.volumetricFogs.Count;
						ctx.cmd.SetComputeBufferParam(data.volumetricMaterialCS, data.computeRenderingParametersKernel, HDShaderIDs._VolumeBounds, data.visibleVolumeBoundsBuffer);
						ctx.cmd.SetComputeBufferParam(data.volumetricMaterialCS, data.computeRenderingParametersKernel, HDShaderIDs._VolumetricIndirectBufferArguments, data.indirectArgumentBuffer);
						ctx.cmd.SetComputeBufferParam(data.volumetricMaterialCS, data.computeRenderingParametersKernel, HDShaderIDs._VolumetricMaterialData, data.materialDataBuffer);
						ctx.cmd.SetComputeIntParam(data.volumetricMaterialCS, HDShaderIDs._VolumeCount, count);
						ctx.cmd.SetComputeIntParam(data.volumetricMaterialCS, HDShaderIDs._MaxSliceCount, data.maxSliceCount);
						ctx.cmd.SetComputeIntParam(data.volumetricMaterialCS, HDShaderIDs._VolumetricViewCount, data.hdCamera.viewCount);
						int threadGroupsX = Mathf.Max(1, Mathf.CeilToInt((float)(count * data.hdCamera.viewCount) / 32f));
						ctx.cmd.DispatchCompute(data.volumetricMaterialCS, data.computeRenderingParametersKernel, threadGroupsX, 1, 1);
						int num2 = count * 20;
						MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
						bool flag2 = GeometryUtils.IsProjectionMatrixOblique(data.hdCamera.camera.projectionMatrix);
						if (flag2)
						{
							Matrix4x4 matrix4x = GL.GetGPUProjectionMatrix(data.hdCamera.nonObliqueProjMatrix, renderIntoTexture: true) * data.hdCamera.mainViewConstants.viewMatrix;
							tempMaterialPropertyBlock.SetMatrix(HDShaderIDs._CameraInverseViewProjection_NO, matrix4x.inverse);
						}
						tempMaterialPropertyBlock.SetInt(HDShaderIDs._IsObliqueProjectionMatrix, flag2 ? 1 : 0);
						tempMaterialPropertyBlock.SetVector(HDShaderIDs._CameraRight, data.hdCamera.camera.transform.right);
						tempMaterialPropertyBlock.SetBuffer(HDShaderIDs._VolumetricMaterialData, data.materialDataBuffer);
						CoreUtils.SetRenderTarget(ctx.cmd, data.densityBuffer);
						ctx.cmd.SetViewport(new Rect(0f, 0f, data.viewportSize.x, data.viewportSize.y));
						for (int i = 0; i < count; i++)
						{
							int num3 = UnpackFogVolumeIndex(data.fogVolumeSortKeys[i]);
							if (num3 < data.volumetricFogs.Count)
							{
								LocalVolumetricFog localVolumetricFog = data.volumetricFogs[num3];
								Material material = localVolumetricFog.parameters.materialMask;
								if (localVolumetricFog.parameters.maskMode == LocalVolumetricFogMaskMode.Texture)
								{
									material = data.defaultVolumetricMaterial;
									bool flag3 = false;
									if (localVolumetricFog.parameters.volumeMask != null)
									{
										tempMaterialPropertyBlock.SetTexture(HDShaderIDs._VolumetricMask, localVolumetricFog.parameters.volumeMask);
										ctx.cmd.EnableShaderKeyword("_ENABLE_VOLUMETRIC_FOG_MASK");
										if (localVolumetricFog.parameters.volumeMask is Texture3D texture3D)
										{
											flag3 = texture3D.format == TextureFormat.Alpha8;
										}
									}
									else
									{
										ctx.cmd.DisableShaderKeyword("_ENABLE_VOLUMETRIC_FOG_MASK");
									}
									tempMaterialPropertyBlock.SetVector(HDShaderIDs._VolumetricScrollSpeed, localVolumetricFog.parameters.textureScrollingSpeed);
									tempMaterialPropertyBlock.SetVector(HDShaderIDs._VolumetricTiling, localVolumetricFog.parameters.textureTiling);
									tempMaterialPropertyBlock.SetFloat(HDShaderIDs._AlphaOnlyTexture, flag3 ? 1 : 0);
								}
								if (!(material == null))
								{
									int passIndexFromBlendingMode = FogVolumeAPI.GetPassIndexFromBlendingMode(localVolumetricFog.parameters.blendingMode);
									int shaderPass = (data.fogOverdrawDebugEnabled ? material.FindPass("OverdrawDebug") : 0);
									LocalVolumetricFogEngineData localVolumetricFogEngineData = data.visibleVolumeData[num3];
									OrientedBBox orientedBBox = data.visibleVolumeBounds[num3];
									VolumetricMaterialDataCBuffer data2 = default(VolumetricMaterialDataCBuffer);
									data2._VolumetricMaterialObbRight = orientedBBox.right;
									data2._VolumetricMaterialObbUp = orientedBBox.up;
									data2._VolumetricMaterialObbExtents = new Vector3(orientedBBox.extentX, orientedBBox.extentY, orientedBBox.extentZ);
									data2._VolumetricMaterialObbCenter = orientedBBox.center;
									data2._VolumetricMaterialAlbedo = localVolumetricFogEngineData.albedo;
									data2._VolumetricMaterialExtinction = VolumeRenderingUtils.ExtinctionFromMeanFreePath(localVolumetricFog.parameters.meanFreePath);
									data2._VolumetricMaterialRcpPosFaceFade = localVolumetricFogEngineData.rcpPosFaceFade;
									data2._VolumetricMaterialRcpNegFaceFade = localVolumetricFogEngineData.rcpNegFaceFade;
									data2._VolumetricMaterialInvertFade = localVolumetricFogEngineData.invertFade;
									data2._VolumetricMaterialRcpDistFadeLen = localVolumetricFogEngineData.rcpDistFadeLen;
									data2._VolumetricMaterialEndTimesRcpDistFadeLen = localVolumetricFogEngineData.endTimesRcpDistFadeLen;
									data2._VolumetricMaterialFalloffMode = (float)localVolumetricFogEngineData.falloffMode;
									ConstantBuffer.PushGlobal(ctx.cmd, in data2, HDShaderIDs._VolumetricMaterialDataCBuffer);
									for (int j = 0; j < data.hdCamera.viewCount; j++)
									{
										tempMaterialPropertyBlock.SetInt(HDShaderIDs._VolumeMaterialDataIndex, num3 + j * count);
										int num4 = num2 * j;
										tempMaterialPropertyBlock.SetInt(HDShaderIDs._VolumetricViewIndex, j);
										ctx.cmd.DrawProceduralIndirect(data.triangleFanIndexBuffer, localVolumetricFog.transform.localToWorldMatrix, material, passIndexFromBlendingMode, MeshTopology.Triangles, data.indirectArgumentBuffer, 20 * num3 + num4, tempMaterialPropertyBlock);
										if (data.fogOverdrawDebugEnabled)
										{
											CoreUtils.SetRenderTarget(ctx.cmd, data.fogOverdrawOutput, ClearFlag.None, 0, CubemapFace.Unknown, j);
											ctx.cmd.DrawProceduralIndirect(data.triangleFanIndexBuffer, localVolumetricFog.transform.localToWorldMatrix, material, shaderPass, MeshTopology.Triangles, data.indirectArgumentBuffer, 20 * num3 + num4, tempMaterialPropertyBlock);
											CoreUtils.SetRenderTarget(ctx.cmd, data.densityBuffer);
										}
									}
								}
							}
						}
					});
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				if (flag)
				{
					PushFullScreenDebugTexture(renderGraph, input2, FullScreenDebugMode.LocalVolumetricFogOverdraw);
				}
				return densityBuffer;
			}
			return TextureHandle.nullHandle;
		}

		private static void GetHexagonalClosePackedSpheres7(Vector2[] coords)
		{
			float num = 0.17054069f;
			float num2 = 2f * num;
			float num3 = num * Mathf.Sqrt(3f);
			coords[0] = new Vector2(0f, 0f);
			coords[1] = new Vector2(0f - num2, 0f);
			coords[2] = new Vector2(num2, 0f);
			coords[3] = new Vector2(0f - num, 0f - num3);
			coords[4] = new Vector2(num, num3);
			coords[5] = new Vector2(num, 0f - num3);
			coords[6] = new Vector2(0f - num, num3);
			for (int i = 0; i < 7; i++)
			{
				Vector2 vector = coords[i];
				coords[i].x = vector.x * 0.9659258f - vector.y * 0.25881904f;
				coords[i].y = vector.x * 0.25881904f + vector.y * 0.9659258f;
			}
		}

		private TextureHandle VolumetricLightingPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthTexture, TextureHandle densityBuffer, TextureHandle maxZBuffer, ComputeBufferHandle bigTileLightListBuffer, ShadowResult shadowResult)
		{
			if (Fog.IsVolumetricFogEnabled(hdCamera))
			{
				VolumetricLightingPassData passData;
				RenderGraphBuilder builder = renderGraph.AddRenderPass<VolumetricLightingPassData>("Volumetric Lighting", out passData);
				TextureHandle input;
				try
				{
					uint num = VolumetricFrameIndex(hdCamera);
					int num2 = (int)(num & 1);
					int num3 = (int)((num + 1) & 1);
					VBufferParameters vBufferParameters = hdCamera.vBufferParams[num2];
					Fog component = hdCamera.volumeStack.GetComponent<Fog>();
					passData.tiledLighting = hdCamera.frameSettings.IsEnabled(FrameSettingsField.BigTilePrepass);
					bool flag = (component.denoisingMode.value & FogDenoisingMode.Reprojection) != 0;
					passData.enableReprojection = hdCamera.IsVolumetricReprojectionEnabled() && flag;
					bool state = component.anisotropy.value != 0f;
					bool state2 = vBufferParameters.voxelSize == 8f;
					passData.volumetricLightingCS = m_VolumetricLightingCS;
					passData.volumetricLightingFilteringCS = m_VolumetricLightingFilteringCS;
					passData.volumetricLightingCS.shaderKeywords = null;
					passData.volumetricLightingFilteringCS.shaderKeywords = null;
					CoreUtils.SetKeyword(passData.volumetricLightingCS, "LIGHTLOOP_DISABLE_TILE_AND_CLUSTER", !passData.tiledLighting);
					CoreUtils.SetKeyword(passData.volumetricLightingCS, "ENABLE_REPROJECTION", passData.enableReprojection);
					CoreUtils.SetKeyword(passData.volumetricLightingCS, "ENABLE_ANISOTROPY", state);
					CoreUtils.SetKeyword(passData.volumetricLightingCS, "VL_PRESET_OPTIMAL", state2);
					CoreUtils.SetKeyword(passData.volumetricLightingCS, "SUPPORT_LOCAL_LIGHTS", !component.directionalLightsOnly.value);
					passData.volumetricLightingKernel = passData.volumetricLightingCS.FindKernel("VolumetricLighting");
					passData.volumetricFilteringKernel = passData.volumetricLightingFilteringCS.FindKernel("FilterVolumetricLighting");
					Vector3Int viewportSize = vBufferParameters.viewportSize;
					passData.resolution = new Vector4(viewportSize.x, viewportSize.y, 1f / (float)viewportSize.x, 1f / (float)viewportSize.y);
					passData.viewCount = hdCamera.viewCount;
					passData.filterVolume = (component.denoisingMode.value & FogDenoisingMode.Gaussian) != 0;
					passData.sliceCount = viewportSize.z;
					passData.filteringNeedsExtraBuffer = !SystemInfo.IsFormatSupported(GraphicsFormat.R16G16B16A16_SFloat, FormatUsage.LoadStore);
					UpdateShaderVariableslVolumetrics(ref m_ShaderVariablesVolumetricCB, hdCamera, in passData.resolution);
					passData.volumetricCB = m_ShaderVariablesVolumetricCB;
					passData.lightListCB = m_ShaderVariablesLightListCB;
					if (passData.tiledLighting)
					{
						passData.bigTileLightListBuffer = builder.ReadComputeBuffer(in bigTileLightListBuffer);
					}
					passData.densityBuffer = builder.ReadTexture(in densityBuffer);
					passData.depthTexture = builder.ReadTexture(in depthTexture);
					passData.maxZBuffer = builder.ReadTexture(in maxZBuffer);
					VolumetricLightingPassData volumetricLightingPassData = passData;
					TextureDesc desc = new TextureDesc(s_CurrentVolumetricBufferSize.x, s_CurrentVolumetricBufferSize.y)
					{
						slices = s_CurrentVolumetricBufferSize.z,
						colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
						dimension = TextureDimension.Tex3D,
						enableRandomWrite = true,
						name = "VBufferLighting"
					};
					input = renderGraph.CreateTexture(in desc);
					volumetricLightingPassData.lightingBuffer = builder.WriteTexture(in input);
					if (passData.filterVolume && passData.filteringNeedsExtraBuffer)
					{
						VolumetricLightingPassData volumetricLightingPassData2 = passData;
						desc = new TextureDesc(s_CurrentVolumetricBufferSize.x, s_CurrentVolumetricBufferSize.y)
						{
							slices = s_CurrentVolumetricBufferSize.z,
							colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
							dimension = TextureDimension.Tex3D,
							enableRandomWrite = true,
							name = "VBufferLightingFiltered"
						};
						input = renderGraph.CreateTexture(in desc);
						volumetricLightingPassData2.filteringOutputBuffer = builder.WriteTexture(in input);
						CoreUtils.SetKeyword(passData.volumetricLightingFilteringCS, "NEED_SEPARATE_OUTPUT", passData.filteringNeedsExtraBuffer);
					}
					if (passData.enableReprojection)
					{
						VolumetricLightingPassData volumetricLightingPassData3 = passData;
						input = renderGraph.ImportTexture(hdCamera.volumetricHistoryBuffers[num2]);
						volumetricLightingPassData3.feedbackBuffer = builder.WriteTexture(in input);
						VolumetricLightingPassData volumetricLightingPassData4 = passData;
						input = renderGraph.ImportTexture(hdCamera.volumetricHistoryBuffers[num3]);
						volumetricLightingPassData4.historyBuffer = builder.ReadTexture(in input);
					}
					passData.volumetricAmbientProbeBuffer = m_SkyManager.GetVolumetricAmbientProbeBuffer(hdCamera);
					HDShadowManager.ReadShadowResult(in shadowResult, builder);
					builder.SetRenderFunc(delegate(VolumetricLightingPassData data, RenderGraphContext ctx)
					{
						if (data.tiledLighting)
						{
							ctx.cmd.SetComputeBufferParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs.g_vBigTileLightList, data.bigTileLightListBuffer);
						}
						ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._MaxZMaskTexture, data.maxZBuffer);
						ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._CameraDepthTexture, data.depthTexture);
						ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._VBufferDensity, data.densityBuffer);
						ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._VBufferLighting, data.lightingBuffer);
						ctx.cmd.SetComputeBufferParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._VolumeAmbientProbeBuffer, data.volumetricAmbientProbeBuffer);
						if (data.enableReprojection)
						{
							ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._VBufferHistory, data.historyBuffer);
							ctx.cmd.SetComputeTextureParam(data.volumetricLightingCS, data.volumetricLightingKernel, HDShaderIDs._VBufferFeedback, data.feedbackBuffer);
						}
						ConstantBuffer.Push(ctx.cmd, in data.volumetricCB, data.volumetricLightingCS, HDShaderIDs._ShaderVariablesVolumetric);
						ConstantBuffer.Set<ShaderVariablesLightList>(ctx.cmd, data.volumetricLightingCS, HDShaderIDs._ShaderVariablesLightList);
						ctx.cmd.DispatchCompute(data.volumetricLightingCS, data.volumetricLightingKernel, ((int)data.resolution.x + 7) / 8, ((int)data.resolution.y + 7) / 8, data.viewCount);
						if (data.filterVolume)
						{
							ConstantBuffer.Push(ctx.cmd, in data.volumetricCB, data.volumetricLightingFilteringCS, HDShaderIDs._ShaderVariablesVolumetric);
							ctx.cmd.SetComputeTextureParam(data.volumetricLightingFilteringCS, data.volumetricFilteringKernel, HDShaderIDs._VBufferLighting, data.lightingBuffer);
							if (data.filteringNeedsExtraBuffer)
							{
								ctx.cmd.SetComputeTextureParam(data.volumetricLightingFilteringCS, data.volumetricFilteringKernel, HDShaderIDs._VBufferLightingFiltered, data.filteringOutputBuffer);
							}
							ctx.cmd.DispatchCompute(data.volumetricLightingFilteringCS, data.volumetricFilteringKernel, HDUtils.DivRoundUp((int)data.resolution.x, 8), HDUtils.DivRoundUp((int)data.resolution.y, 8), data.sliceCount);
						}
					});
					if (passData.enableReprojection && hdCamera.volumetricValidFrames > 1)
					{
						hdCamera.volumetricHistoryIsValid = true;
					}
					else
					{
						hdCamera.volumetricValidFrames++;
					}
					input = ((!passData.filterVolume || !passData.filteringNeedsExtraBuffer) ? passData.lightingBuffer : passData.filteringOutputBuffer);
				}
				finally
				{
					((IDisposable)builder).Dispose();
				}
				return input;
			}
			return renderGraph.ImportTexture(HDUtils.clearTexture3DRTH);
		}

		private void RenderDenoisePass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle outputTexture)
		{
		}

		public void BeginRecording(int samples, float shutterInterval, float shutterFullyOpen = 0f, float shutterBeginsClosing = 1f)
		{
			m_SubFrameManager.BeginRecording(samples, shutterInterval, shutterFullyOpen, shutterBeginsClosing);
		}

		public void BeginRecording(int samples, float shutterInterval, AnimationCurve shutterProfile)
		{
			m_SubFrameManager.BeginRecording(samples, shutterInterval, shutterProfile);
		}

		public void EndRecording()
		{
			m_SubFrameManager.EndRecording();
		}

		public void PrepareNewSubFrame()
		{
			m_SubFrameManager.PrepareNewSubFrame();
		}

		public bool IsFrameCompleted(HDCamera hdCamera)
		{
			int instanceID = hdCamera.camera.GetInstanceID();
			return m_SubFrameManager.GetCameraData(instanceID).currentIteration >= m_SubFrameManager.subFrameCount;
		}

		private void RenderAccumulation(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle inputTexture, TextureHandle outputTexture, List<Tuple<TextureHandle, HDCameraFrameHistoryType>> AOVs, bool needExposure)
		{
			int instanceID = hdCamera.camera.GetInstanceID();
			Vector4 frameWeights = m_SubFrameManager.ComputeFrameWeights(instanceID);
			if (AOVs != null)
			{
				foreach (Tuple<TextureHandle, HDCameraFrameHistoryType> AOV in AOVs)
				{
					if (!m_SubFrameManager.isRecording || m_SubFrameManager.shutterInterval != 0f || AOV.Item2 != HDCameraFrameHistoryType.MotionVectorAOV || m_SubFrameManager.GetCameraData(instanceID).currentIteration == 0)
					{
						RenderAccumulation(renderGraph, hdCamera, AOV.Item1, TextureHandle.nullHandle, AOV.Item2, frameWeights, needExposure);
					}
				}
			}
			RenderAccumulation(renderGraph, hdCamera, inputTexture, outputTexture, HDCameraFrameHistoryType.PathTracing, frameWeights, needExposure);
		}

		private void RenderAccumulation(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle inputTexture, TextureHandle outputTexture, HDCameraFrameHistoryType historyType, Vector4 frameWeights, bool needExposure)
		{
			RenderAccumulationPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderAccumulationPassData>("Render Accumulation", out passData);
			bool useInputTexture = !inputTexture.Equals(outputTexture);
			passData.accumulationCS = m_Asset.renderPipelineResources.shaders.accumulationCS;
			passData.accumulationKernel = passData.accumulationCS.FindKernel("KMain");
			passData.subFrameManager = m_SubFrameManager;
			passData.needExposure = needExposure;
			passData.hdCamera = hdCamera;
			passData.inputKeyword = new LocalKeyword(passData.accumulationCS, "INPUT_FROM_FRAME_TEXTURE");
			passData.outputKeyword = new LocalKeyword(passData.accumulationCS, "WRITE_TO_OUTPUT_TEXTURE");
			passData.frameWeights = frameWeights;
			TextureHandle input = renderGraph.ImportTexture(hdCamera.GetCurrentFrameRT((int)historyType) ?? hdCamera.AllocHistoryFrameRT((int)historyType, PathTracingHistoryBufferAllocatorFunction, 1));
			passData.input = renderGraphBuilder.ReadTexture(in inputTexture);
			passData.history = renderGraphBuilder.ReadWriteTexture(in input);
			passData.useOutputTexture = outputTexture.IsValid();
			passData.useInputTexture = useInputTexture;
			if (outputTexture.IsValid())
			{
				passData.output = renderGraphBuilder.ReadWriteTexture(in outputTexture);
			}
			renderGraphBuilder.SetRenderFunc(delegate(RenderAccumulationPassData data, RenderGraphContext ctx)
			{
				ComputeShader accumulationCS = data.accumulationCS;
				if ((bool)accumulationCS)
				{
					accumulationCS.shaderKeywords = null;
					if (data.useInputTexture)
					{
						ctx.cmd.EnableKeyword(accumulationCS, in passData.inputKeyword);
					}
					else
					{
						ctx.cmd.DisableKeyword(accumulationCS, in passData.inputKeyword);
					}
					if (data.useOutputTexture)
					{
						ctx.cmd.EnableKeyword(accumulationCS, in passData.outputKeyword);
					}
					else
					{
						ctx.cmd.DisableKeyword(accumulationCS, in passData.outputKeyword);
					}
					int instanceID = data.hdCamera.camera.GetInstanceID();
					CameraData cameraData = data.subFrameManager.GetCameraData(instanceID);
					ctx.cmd.SetComputeIntParam(accumulationCS, HDShaderIDs._AccumulationFrameIndex, (int)cameraData.currentIteration);
					ctx.cmd.SetComputeIntParam(accumulationCS, HDShaderIDs._AccumulationNumSamples, (int)data.subFrameManager.subFrameCount);
					ctx.cmd.SetComputeTextureParam(accumulationCS, data.accumulationKernel, HDShaderIDs._AccumulatedFrameTexture, data.history);
					if (data.useOutputTexture)
					{
						ctx.cmd.SetComputeTextureParam(accumulationCS, data.accumulationKernel, HDShaderIDs._CameraColorTextureRW, data.output);
					}
					if (data.useInputTexture)
					{
						ctx.cmd.SetComputeTextureParam(accumulationCS, data.accumulationKernel, HDShaderIDs._FrameTexture, data.input);
					}
					ctx.cmd.SetComputeVectorParam(accumulationCS, HDShaderIDs._AccumulationWeights, data.frameWeights);
					ctx.cmd.SetComputeIntParam(accumulationCS, HDShaderIDs._AccumulationNeedsExposure, data.needExposure ? 1 : 0);
					ctx.cmd.DispatchCompute(accumulationCS, data.accumulationKernel, (data.hdCamera.actualWidth + 7) / 8, (data.hdCamera.actualHeight + 7) / 8, data.hdCamera.viewCount);
					if (data.useOutputTexture && cameraData.currentIteration < data.subFrameManager.subFrameCount)
					{
						cameraData.currentIteration++;
						data.subFrameManager.SetCameraData(instanceID, cameraData);
					}
				}
			});
		}

		public bool IsCloudBackgroundUsable()
		{
			if (currentAsset != null)
			{
				return true;
			}
			return false;
		}

		public uint GetRaysPerFrame(RayCountValues rayValues)
		{
			if (m_RayCountManager == null)
			{
				return 0u;
			}
			return m_RayCountManager.GetRaysPerFrame(rayValues);
		}

		internal ShaderVariablesGlobal GetShaderVariablesGlobalCB()
		{
			return m_ShaderVariablesGlobalCB;
		}

		internal GraphicsFormat GetColorBufferFormat()
		{
			if (CoreUtils.IsSceneFilteringEnabled())
			{
				return GraphicsFormat.R16G16B16A16_SFloat;
			}
			if (!m_ShouldOverrideColorBufferFormat)
			{
				return (GraphicsFormat)m_Asset.currentPlatformRenderPipelineSettings.colorBufferFormat;
			}
			return m_AOVGraphicsFormat;
		}

		private GraphicsFormat GetCustomBufferFormat()
		{
			return (GraphicsFormat)m_Asset.currentPlatformRenderPipelineSettings.customBufferFormat;
		}

		internal int GetDecalAtlasMipCount()
		{
			return Mathf.FloorToInt(Mathf.Log(Math.Max(currentPlatformRenderPipelineSettings.decalSettings.atlasWidth, currentPlatformRenderPipelineSettings.decalSettings.atlasHeight), 2f)) + 1;
		}

		internal int GetCookieAtlasMipCount()
		{
			return Mathf.FloorToInt(Mathf.Log((float)currentPlatformRenderPipelineSettings.lightLoopSettings.cookieAtlasSize, 2f)) + 1;
		}

		internal int GetReflectionProbeMipCount()
		{
			Vector2Int reflectionProbeTextureCacheDim = GlobalLightLoopSettings.GetReflectionProbeTextureCacheDim(currentPlatformRenderPipelineSettings.lightLoopSettings.reflectionProbeTexCacheSize);
			return Mathf.FloorToInt(Mathf.Log(Math.Max(reflectionProbeTextureCacheDim.x, reflectionProbeTextureCacheDim.y), 2f)) + 1;
		}

		internal int GetReflectionProbeArraySize()
		{
			if (!currentPlatformRenderPipelineSettings.lightLoopSettings.supportFabricConvolution)
			{
				return 1;
			}
			return 2;
		}

		internal int GetMaxScreenSpaceShadows()
		{
			if (!currentPlatformRenderPipelineSettings.hdShadowInitParams.supportScreenSpaceShadows)
			{
				return 0;
			}
			return currentPlatformRenderPipelineSettings.hdShadowInitParams.maxScreenSpaceShadowSlots;
		}

		private static bool HDROutputActiveForCameraType(CameraType cameraType)
		{
			if (HDROutputIsActive())
			{
				return cameraType == CameraType.Game;
			}
			return false;
		}

		internal static bool HDROutputIsActive()
		{
			if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.Metal && SystemInfo.hdrDisplaySupportFlags.HasFlag(HDRDisplaySupportFlags.Supported))
			{
				return HDROutputSettings.main.active;
			}
			return false;
		}

		private void SetHDRState(HDCamera camera)
		{
			if (camera.camera.cameraType == CameraType.Reflection)
			{
				return;
			}
			if (true && HDROutputSettings.main.available)
			{
				if (camera.camera.cameraType != CameraType.Game || SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal)
				{
					HDROutputSettings.main.RequestHDRModeChange(enabled: false);
				}
				else
				{
					HDROutputSettings.main.RequestHDRModeChange(enabled: true);
				}
			}
			if (HDROutputSettings.main.active)
			{
				HDROutputSettings.main.automaticHDRTonemapping = false;
			}
		}

		internal Material GetMSAAColorResolveMaterial()
		{
			return m_ColorResolveMaterial;
		}

		public HDRenderPipeline(HDRenderPipelineAsset asset, HDRenderPipelineAsset obsolete_defaultAsset)
			: this(asset)
		{
		}

		public HDRenderPipeline(HDRenderPipelineAsset asset)
		{
			HDRenderPipeline hDRenderPipeline = this;
			if (!CheckAPIValidity())
			{
				m_ValidAPI = false;
				return;
			}
			m_GlobalSettings = HDRenderPipelineGlobalSettings.instance;
			m_Asset = asset;
			HDProbeSystem.Parameters = asset.reflectionSystemParameters;
			DebugManager.instance.RefreshEditor();
			m_ValidAPI = true;
			SetRenderingFeatures();
			QualitySettings.lodBias = m_GlobalSettings.GetDefaultFrameSettings(FrameSettingsRenderType.Camera).GetResolvedLODBias(m_Asset);
			QualitySettings.maximumLODLevel = m_GlobalSettings.GetDefaultFrameSettings(FrameSettingsRenderType.Camera).GetResolvedMaximumLODLevel(m_Asset);
			bool flag = PipelineSupportsRayTracing(m_Asset.currentPlatformRenderPipelineSettings);
			m_RayTracingSupported = flag && m_GlobalSettings.renderPipelineRayTracingResources != null;
			if (flag && !m_RayTracingSupported)
			{
				Debug.LogWarning("The asset supports ray tracing but the ray tracing resources are not included in the build. This can happen if the asset currently in use was not included in any quality setting for the current platform.");
				m_Asset.TurnOffRayTracing();
			}
			m_AssetSupportsRayTracing = m_Asset.currentPlatformRenderPipelineSettings.supportRayTracing;
			CheckResourcesValidity();
			colorMaskTransparentVel = HDShaderIDs._ColorMaskTransparentVelOne;
			colorMaskAdditionalTarget = HDShaderIDs._ColorMaskTransparentVelTwo;
			RTHandles.Initialize(Screen.width, Screen.height);
			XRSystem.Initialize(XRPass.CreateDefault, asset.renderPipelineResources.shaders.xrOcclusionMeshPS, asset.renderPipelineResources.shaders.xrMirrorViewPS);
			m_MipGenerator = new MipGenerator(defaultResources);
			m_BlueNoise = new BlueNoise(defaultResources);
			EncodeBC6H.DefaultInstance = EncodeBC6H.DefaultInstance ?? new EncodeBC6H(defaultResources.shaders.encodeBC6HCS);
			m_MaterialList = HDUtils.GetRenderPipelineMaterialList();
			InitializePostProcess();
			m_SsrTracingKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsTracing");
			m_SsrReprojectionKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsReprojection");
			m_SsrAccumulateNoWorldSpeedRejectionBothKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionBoth");
			m_SsrAccumulateNoWorldSpeedRejectionSurfaceKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionSourceOnly");
			m_SsrAccumulateNoWorldSpeedRejectionHitKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionTargetOnly");
			m_SsrAccumulateHardThresholdSpeedRejectionBothKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionBoth");
			m_SsrAccumulateHardThresholdSpeedRejectionSurfaceKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionSourceOnly");
			m_SsrAccumulateHardThresholdSpeedRejectionHitKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionTargetOnly");
			m_SsrAccumulateSmoothSpeedRejectionBothKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionBoth");
			m_SsrAccumulateSmoothSpeedRejectionSurfaceKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionSourceOnly");
			m_SsrAccumulateSmoothSpeedRejectionHitKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionTargetOnly");
			m_SsrAccumulateNoWorldSpeedRejectionBothDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionBothDebug");
			m_SsrAccumulateNoWorldSpeedRejectionSurfaceDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionSourceOnlyDebug");
			m_SsrAccumulateNoWorldSpeedRejectionHitDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateNoWorldSpeedRejectionTargetOnlyDebug");
			m_SsrAccumulateHardThresholdSpeedRejectionBothDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionBothDebug");
			m_SsrAccumulateHardThresholdSpeedRejectionSurfaceDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionSourceOnlyDebug");
			m_SsrAccumulateHardThresholdSpeedRejectionHitDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateHardThresholdSpeedRejectionTargetOnlyDebug");
			m_SsrAccumulateSmoothSpeedRejectionBothDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionBothDebug");
			m_SsrAccumulateSmoothSpeedRejectionSurfaceDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionSourceOnlyDebug");
			m_SsrAccumulateSmoothSpeedRejectionHitDebugKernel = m_ScreenSpaceReflectionsCS.FindKernel("ScreenSpaceReflectionsAccumulateSmoothSpeedRejectionTargetOnlyDebug");
			m_ClearBuffer2DKernel = m_ClearBuffer2DCS.FindKernel("ClearBuffer2DMain");
			m_CopyDepth = CoreUtils.CreateEngineMaterial(defaultResources.shaders.copyDepthBufferPS);
			m_UpsampleTransparency = CoreUtils.CreateEngineMaterial(defaultResources.shaders.upsampleTransparentPS);
			m_ApplyDistortionMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.applyDistortionPS);
			m_FinalBlitWithOETF = CoreUtils.CreateEngineMaterial(defaultResources.shaders.compositeUIAndOETFApplyPS);
			m_ClearStencilBufferMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.clearStencilBufferPS);
			InitializeDebug();
			Blitter.Initialize(defaultResources.shaders.blitPS, defaultResources.shaders.blitColorAndDepthPS);
			m_ErrorMaterial = CoreUtils.CreateEngineMaterial("Hidden/InternalErrorShader");
			m_MaterialList.ForEach(delegate(RenderPipelineMaterial material)
			{
				material.Build(asset, hDRenderPipeline.defaultResources);
			});
			if (m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.supportFabricConvolution)
			{
				m_IBLFilterArray = new IBLFilterBSDF[2];
				m_IBLFilterArray[0] = new IBLFilterGGX(defaultResources, m_MipGenerator);
				m_IBLFilterArray[1] = new IBLFilterCharlie(defaultResources, m_MipGenerator);
			}
			else
			{
				m_IBLFilterArray = new IBLFilterBSDF[1];
				m_IBLFilterArray[0] = new IBLFilterGGX(defaultResources, m_MipGenerator);
			}
			InitializeLightLoop(m_IBLFilterArray);
			bool flag2 = IsAPVEnabled();
			SupportedRenderingFeatures.active.overridesLightProbeSystem = flag2;
			if (flag2)
			{
				_ = ProbeReferenceVolume.instance;
				ProbeReferenceVolume instance = ProbeReferenceVolume.instance;
				ProbeVolumeSystemParameters parameters = new ProbeVolumeSystemParameters
				{
					memoryBudget = m_Asset.currentPlatformRenderPipelineSettings.probeVolumeMemoryBudget,
					blendingMemoryBudget = m_Asset.currentPlatformRenderPipelineSettings.probeVolumeBlendingMemoryBudget,
					probeDebugMesh = defaultResources.assets.probeDebugSphere,
					probeDebugShader = defaultResources.shaders.probeVolumeDebugShader,
					offsetDebugMesh = defaultResources.assets.pyramidMesh,
					offsetDebugShader = defaultResources.shaders.probeVolumeOffsetDebugShader,
					scenarioBlendingShader = defaultResources.shaders.probeVolumeBlendStatesCS,
					sceneData = m_GlobalSettings.GetOrCreateAPVSceneData(),
					shBands = m_Asset.currentPlatformRenderPipelineSettings.probeVolumeSHBands,
					supportsRuntimeDebug = (Application.isEditor || m_GlobalSettings.supportRuntimeDebugDisplay),
					supportStreaming = m_Asset.currentPlatformRenderPipelineSettings.supportProbeVolumeStreaming
				};
				instance.Initialize(in parameters);
				RegisterRetrieveOfProbeVolumeExtraDataAction();
				SupportedRenderingFeatures.active.overridesLightProbeSystemWarningMessage = "This Light Probe system is not active because the pipeline uses Probe Volumes and the systems cannot co-exist.\nTo disable Probe Volumes make sure the feature is disabled in the lighting section of the active HDRP Asset.";
			}
			m_SkyManager.Build(asset, defaultResources, m_IBLFilterArray);
			InitializeVolumetricLighting();
			InitializeVolumetricClouds();
			InitializeSubsurfaceScattering();
			InitializeWaterSystem();
			m_DebugDisplaySettings.RegisterDebug();
			m_DebugDisplaySettingsUI.RegisterDebug(DebugDisplaySettings<HDDebugDisplaySettings>.Instance);
			m_DepthPyramidMipLevelOffsetsBuffer = new ComputeBuffer(15, 8);
			m_CustomPassColorBuffer = new Lazy<RTHandle>(() => RTHandles.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, dimension: TextureXR.dimension, colorFormat: hDRenderPipeline.GetCustomBufferFormat(), filterMode: FilterMode.Point, wrapMode: TextureWrapMode.Repeat, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, anisoLevel: 1, mipMapBias: 0f, msaaSamples: MSAASamples.None, bindTextureMS: false, useDynamicScale: true, memoryless: RenderTextureMemoryless.None, vrUsage: VRTextureUsage.None, name: "CustomPassColorBuffer"));
			m_CustomPassDepthBuffer = new Lazy<RTHandle>(() => RTHandles.Alloc(Vector2.one, TextureXR.slices, DepthBits.Depth32, GraphicsFormat.R32_UInt, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: false, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, "CustomPassDepthBuffer"));
			MousePositionDebug.instance.Build();
			InitializeRenderStateBlocks();
			if (m_RayTracingSupported)
			{
				InitRayTracingManager();
				InitRayTracedReflections();
				InitRayTracedIndirectDiffuse();
				InitRaytracingDeferred();
				InitRecursiveRenderer();
				InitPathTracing();
				InitRayTracingAmbientOcclusion();
			}
			InitScreenSpaceGlobalIllumination();
			InitializeScreenSpaceShadows();
			CameraCaptureBridge.enabled = true;
			InitializePrepass(m_Asset);
			m_ColorResolveMaterial = CoreUtils.CreateEngineMaterial(m_GlobalSettings.renderPipelineResources.shaders.colorResolvePS);
			m_MotionVectorResolve = CoreUtils.CreateEngineMaterial(m_GlobalSettings.renderPipelineResources.shaders.resolveMotionVecPS);
			CustomPassUtils.Initialize();
			LensFlareCommonSRP.Initialize();
			Hammersley.Initialize();
		}

		public void ResetRTHandleReferenceSize(int width, int height)
		{
			RTHandles.ResetReferenceSize(width, height);
			HDCamera.ResetAllHistoryRTHandleSystems(width, height);
		}

		private void SetRenderingFeatures()
		{
			Shader.globalRenderPipeline = "HDRenderPipeline";
			m_PreviousLightsUseLinearIntensity = GraphicsSettings.lightsUseLinearIntensity;
			GraphicsSettings.lightsUseLinearIntensity = true;
			m_PreviousLightsUseColorTemperature = GraphicsSettings.lightsUseColorTemperature;
			GraphicsSettings.lightsUseColorTemperature = true;
			m_PreviousSRPBatcher = GraphicsSettings.useScriptableRenderPipelineBatching;
			GraphicsSettings.useScriptableRenderPipelineBatching = m_Asset.enableSRPBatcher;
			m_PreviousDefaultRenderingLayerMask = GraphicsSettings.defaultRenderingLayerMask;
			GraphicsSettings.defaultRenderingLayerMask = 257u;
			m_PreviousShadowMaskMode = QualitySettings.shadowmaskMode;
			QualitySettings.shadowmaskMode = ShadowmaskMode.DistanceShadowmask;
			SupportedRenderingFeatures.active = new SupportedRenderingFeatures
			{
				reflectionProbeModes = SupportedRenderingFeatures.ReflectionProbeModes.Rotation,
				defaultMixedLightingModes = SupportedRenderingFeatures.LightmapMixedBakeModes.IndirectOnly,
				mixedLightingModes = (SupportedRenderingFeatures.LightmapMixedBakeModes.IndirectOnly | (m_Asset.currentPlatformRenderPipelineSettings.supportShadowMask ? SupportedRenderingFeatures.LightmapMixedBakeModes.Shadowmask : SupportedRenderingFeatures.LightmapMixedBakeModes.None)),
				lightmapBakeTypes = (LightmapBakeType.Realtime | LightmapBakeType.Baked | LightmapBakeType.Mixed),
				lightmapsModes = LightmapsMode.CombinedDirectional,
				lightProbeProxyVolumes = true,
				motionVectors = true,
				receiveShadows = false,
				reflectionProbes = false,
				rendererPriority = true,
				overridesFog = true,
				overridesOtherLightingSettings = true,
				editableMaterialRenderQueue = false,
				enlighten = true,
				overridesLODBias = true,
				overridesMaximumLODLevel = true,
				overridesShadowmask = true,
				overridesRealtimeReflectionProbes = true,
				autoAmbientProbeBaking = false,
				autoDefaultReflectionProbeBaking = false,
				enlightenLightmapper = false,
				rendersUIOverlay = true,
				supportsHDR = true
			};
			Lightmapping.SetDelegate(GlobalIlluminationUtils.hdLightsDelegate);
			m_DebugDisplaySettings.nvidiaDebugView.Reset();
			SetupDLSSFeature(m_GlobalSettings);
		}

		internal static void SetupDLSSFeature(HDRenderPipelineGlobalSettings globalSettings)
		{
			if (globalSettings == null)
			{
				Debug.LogError("Tried to setup DLSS with a null globalSettings object.");
			}
			else if (DLSSPass.SetupFeature(globalSettings))
			{
				HDDynamicResolutionPlatformCapabilities.ActivateDLSS();
			}
		}

		private bool CheckAPIValidity()
		{
			if (!IsSupportedPlatformAndDevice(out var unsupportedGraphicDevice))
			{
				HDUtils.DisplayMessageNotification(HDUtils.GetUnsupportedAPIMessage(unsupportedGraphicDevice.ToString()));
				return false;
			}
			return true;
		}

		private bool CheckResourcesValidity()
		{
			if ((!(defaultResources?.shaders.defaultPS?.isSupported)) ?? false)
			{
				HDUtils.DisplayMessageNotification("Unable to compile Default Material based on Lit.shader. Either there is a compile error in Lit.shader or the current platform / API isn't compatible.");
				return false;
			}
			return true;
		}

		private bool IsSupportedPlatformAndDevice(out GraphicsDeviceType unsupportedGraphicDevice)
		{
			unsupportedGraphicDevice = SystemInfo.graphicsDeviceType;
			if (!SystemInfo.supportsComputeShaders)
			{
				HDUtils.DisplayMessageNotification("Current platform / API don't support ComputeShaders which is a requirement.");
				return false;
			}
			if (HDUtils.IsSupportedGraphicDevice(SystemInfo.graphicsDeviceType))
			{
				return HDUtils.IsOperatingSystemSupported(SystemInfo.operatingSystem);
			}
			return false;
		}

		private void UnsetRenderingFeatures()
		{
			Shader.globalRenderPipeline = string.Empty;
			GraphicsSettings.lightsUseLinearIntensity = m_PreviousLightsUseLinearIntensity;
			GraphicsSettings.lightsUseColorTemperature = m_PreviousLightsUseColorTemperature;
			GraphicsSettings.useScriptableRenderPipelineBatching = m_PreviousSRPBatcher;
			GraphicsSettings.defaultRenderingLayerMask = m_PreviousDefaultRenderingLayerMask;
			QualitySettings.shadowmaskMode = m_PreviousShadowMaskMode;
			SupportedRenderingFeatures.active = new SupportedRenderingFeatures();
			Lightmapping.ResetDelegate();
		}

		private void CleanupRenderGraph()
		{
			m_RenderGraph.Cleanup();
			m_RenderGraph = null;
		}

		private void InitializeRenderStateBlocks()
		{
			m_DepthStateOpaque = new RenderStateBlock
			{
				depthState = new DepthState(writeEnabled: true, CompareFunction.LessEqual),
				mask = RenderStateMask.Depth
			};
			m_DepthStateNoWrite = new RenderStateBlock
			{
				depthState = new DepthState(writeEnabled: false, CompareFunction.LessEqual),
				mask = RenderStateMask.Depth
			};
			m_AlphaToMaskBlock = new RenderStateBlock
			{
				blendState = new BlendState(separateMRTBlend: true),
				mask = RenderStateMask.Blend
			};
		}

		private void DisposeProbeCameraPool()
		{
			m_ProbeCameraCache.Dispose();
			m_ProbeCameraCache = null;
		}

		protected override void Dispose(bool disposing)
		{
			Graphics.ClearRandomWriteTargets();
			Graphics.SetRenderTarget(null);
			DisposeProbeCameraPool();
			UnsetRenderingFeatures();
			if (m_ValidAPI)
			{
				base.Dispose(disposing);
				HDLightRenderDatabase.instance.Cleanup();
				ReleaseScreenSpaceShadows();
				if (m_RayTracingSupported)
				{
					ReleaseRayTracingDeferred();
					ReleaseRayTracedIndirectDiffuse();
					ReleasePathTracing();
				}
				ReleaseRayTracingManager();
				m_DebugDisplaySettingsUI.UnregisterDebug();
				m_DebugDisplaySettings.UnregisterDebug();
				CleanupLightLoop();
				ReleaseVolumetricClouds();
				CleanupSubsurfaceScattering();
				ReleaseWaterSystem();
				MousePositionDebug.instance.Cleanup();
				DecalSystem.instance.Cleanup();
				CoreUtils.SafeRelease(m_EmptyIndexBuffer);
				m_EmptyIndexBuffer = null;
				m_MaterialList.ForEach(delegate(RenderPipelineMaterial material)
				{
					material.Cleanup();
				});
				CleanupDebug();
				Blitter.Cleanup();
				CoreUtils.Destroy(m_CopyDepth);
				CoreUtils.Destroy(m_ErrorMaterial);
				CoreUtils.Destroy(m_UpsampleTransparency);
				CoreUtils.Destroy(m_ApplyDistortionMaterial);
				CoreUtils.Destroy(m_ClearStencilBufferMaterial);
				CoreUtils.Destroy(m_FinalBlitWithOETF);
				XRSystem.Dispose();
				m_SkyManager.Cleanup();
				CleanupVolumetricLighting();
				for (int i = 0; i < m_IBLFilterArray.Length; i++)
				{
					m_IBLFilterArray[i].Cleanup();
				}
				CleanupPostProcess();
				m_BlueNoise.Cleanup();
				HDCamera.ClearAll();
				m_MipGenerator.Release();
				if (m_CustomPassColorBuffer.IsValueCreated)
				{
					RTHandles.Release(m_CustomPassColorBuffer.Value);
				}
				if (m_CustomPassDepthBuffer.IsValueCreated)
				{
					RTHandles.Release(m_CustomPassDepthBuffer.Value);
				}
				CullingGroupManager.instance.Cleanup();
				CoreUtils.SafeRelease(m_DepthPyramidMipLevelOffsetsBuffer);
				CustomPassVolume.Cleanup();
				CustomPostProcessVolumeComponent.CleanupAllCustomPostProcesses();
				CleanupPrepass();
				CoreUtils.Destroy(m_ColorResolveMaterial);
				CoreUtils.Destroy(m_MotionVectorResolve);
				LensFlareCommonSRP.Dispose();
				CustomPassUtils.Cleanup();
				if (IsAPVEnabled())
				{
					ProbeReferenceVolume.instance.Cleanup();
				}
				CleanupRenderGraph();
				ConstantBuffer.ReleaseAll();
				CameraCaptureBridge.enabled = false;
				if (!m_Asset.isInOnValidateCall)
				{
					HDUtils.ReleaseComponentSingletons();
				}
			}
		}

		private void Resize(HDCamera hdCamera)
		{
			if (hdCamera.actualWidth > m_MaxCameraWidth || hdCamera.actualHeight > m_MaxCameraHeight || hdCamera.viewCount > m_MaxViewCount)
			{
				m_MaxCameraWidth = Mathf.Max(m_MaxCameraWidth, hdCamera.actualWidth);
				m_MaxCameraHeight = Mathf.Max(m_MaxCameraHeight, hdCamera.actualHeight);
				m_MaxViewCount = Math.Max(m_MaxViewCount, hdCamera.viewCount);
				if (m_MaxCameraWidth > 0 && m_MaxCameraHeight > 0)
				{
					LightLoopReleaseResolutionDependentBuffers();
				}
				LightLoopAllocResolutionDependentBuffers(hdCamera, m_MaxCameraWidth, m_MaxCameraHeight);
			}
		}

		private void UpdateGlobalConstantBuffers(HDCamera hdCamera, CommandBuffer cmd)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.UpdateGlobalConstantBuffers)))
			{
				UpdateShaderVariablesGlobalCB(hdCamera, cmd);
				UpdateShaderVariablesXRCB(hdCamera, cmd);
				UpdateShaderVariablesRaytracingCB(hdCamera, cmd);
				cmd.SetGlobalInt(colorMaskTransparentVel, 15);
				cmd.SetGlobalInt(colorMaskAdditionalTarget, 15);
			}
		}

		private void UpdateShaderVariablesGlobalCB(HDCamera hdCamera, CommandBuffer cmd)
		{
			hdCamera.UpdateShaderVariablesGlobalCB(ref m_ShaderVariablesGlobalCB);
			Fog.UpdateShaderVariablesGlobalCB(ref m_ShaderVariablesGlobalCB, hdCamera);
			UpdateShaderVariablesGlobalSubsurface(ref m_ShaderVariablesGlobalCB, hdCamera);
			UpdateShaderVariablesGlobalDecal(ref m_ShaderVariablesGlobalCB, hdCamera);
			UpdateShaderVariablesGlobalVolumetrics(ref m_ShaderVariablesGlobalCB, hdCamera);
			m_ShadowManager.UpdateShaderVariablesGlobalCB(ref m_ShaderVariablesGlobalCB);
			UpdateShaderVariablesGlobalLightLoop(ref m_ShaderVariablesGlobalCB, hdCamera);
			UpdateShaderVariablesProbeVolumes(ref m_ShaderVariablesGlobalCB, hdCamera, cmd);
			UpdateShaderVariableGlobalAmbientOcclusion(ref m_ShaderVariablesGlobalCB, hdCamera);
			MicroShadowing component = hdCamera.volumeStack.GetComponent<MicroShadowing>();
			m_ShaderVariablesGlobalCB._MicroShadowOpacity = (component.enable.value ? component.opacity.value : 0f);
			HDShadowSettings component2 = hdCamera.volumeStack.GetComponent<HDShadowSettings>();
			m_ShaderVariablesGlobalCB._DirectionalTransmissionMultiplier = component2.directionalTransmissionMultiplier.value;
			ScreenSpaceRefraction component3 = hdCamera.volumeStack.GetComponent<ScreenSpaceRefraction>();
			m_ShaderVariablesGlobalCB._SSRefractionInvScreenWeightDistance = 1f / component3.screenFadeDistance.value;
			IndirectLightingController component4 = hdCamera.volumeStack.GetComponent<IndirectLightingController>();
			m_ShaderVariablesGlobalCB._IndirectDiffuseLightingMultiplier = component4.indirectDiffuseLightingMultiplier.value;
			m_ShaderVariablesGlobalCB._IndirectDiffuseLightingLayers = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers) ? component4.GetIndirectDiffuseLightingLayers() : uint.MaxValue);
			m_ShaderVariablesGlobalCB._ReflectionLightingMultiplier = component4.reflectionLightingMultiplier.value;
			m_ShaderVariablesGlobalCB._ReflectionLightingLayers = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers) ? component4.GetReflectionLightingLayers() : uint.MaxValue);
			m_ShaderVariablesGlobalCB._OffScreenRendering = 0u;
			m_ShaderVariablesGlobalCB._OffScreenDownsampleFactor = 1f;
			m_ShaderVariablesGlobalCB._ReplaceDiffuseForIndirect = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.ReplaceDiffuseForIndirect) ? 1f : 0f);
			m_ShaderVariablesGlobalCB._EnableSkyReflection = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SkyReflection) ? 1u : 0u);
			m_ShaderVariablesGlobalCB._ContactShadowOpacity = m_ContactShadows.opacity.value;
			int num = HDUtils.DivRoundUp(hdCamera.actualWidth, 8);
			int num2 = HDUtils.DivRoundUp(hdCamera.actualHeight, 8);
			m_ShaderVariablesGlobalCB._CoarseStencilBufferSize = new Vector4(num, num2, 1f / (float)num, 1f / (float)num2);
			m_ShaderVariablesGlobalCB._RaytracingFrameIndex = RayTracingFrameIndex(hdCamera);
			m_ShaderVariablesGlobalCB._IndirectDiffuseMode = (int)GetIndirectDiffuseMode(hdCamera);
			m_ShaderVariablesGlobalCB._ReflectionsMode = (int)GetReflectionsMode(hdCamera);
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
			{
				ScreenSpaceReflection component5 = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
				bool flag = hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && ScreenSpaceReflection.RayTracingActive(component5);
				m_ShaderVariablesGlobalCB._EnableRayTracedReflections = (flag ? 1 : 0);
				RecursiveRendering component6 = hdCamera.volumeStack.GetComponent<RecursiveRendering>();
				m_ShaderVariablesGlobalCB._EnableRecursiveRayTracing = ((component6.enable.value && GetRayTracingState()) ? 1u : 0u);
				m_ShaderVariablesGlobalCB._SpecularOcclusionBlend = EvaluateSpecularOcclusionFlag(hdCamera);
			}
			else
			{
				m_ShaderVariablesGlobalCB._EnableRayTracedReflections = 0;
				m_ShaderVariablesGlobalCB._EnableRecursiveRayTracing = 0u;
				m_ShaderVariablesGlobalCB._SpecularOcclusionBlend = 1f;
			}
			ConstantBuffer.PushGlobal(cmd, in m_ShaderVariablesGlobalCB, HDShaderIDs._ShaderVariablesGlobal);
		}

		private void UpdateShaderVariablesXRCB(HDCamera hdCamera, CommandBuffer cmd)
		{
			hdCamera.PushBuiltinShaderConstantsXR(cmd);
			hdCamera.UpdateShaderVariablesXRCB(ref m_ShaderVariablesXRCB);
			ConstantBuffer.PushGlobal(cmd, in m_ShaderVariablesXRCB, HDShaderIDs._ShaderVariablesXR);
		}

		private void UpdateShaderVariablesRaytracingCB(HDCamera hdCamera, CommandBuffer cmd)
		{
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
			{
				RayTracingSettings component = hdCamera.volumeStack.GetComponent<RayTracingSettings>();
				ScreenSpaceReflection component2 = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
				m_ShaderVariablesRayTracingCB._RayTracingRayBias = component.rayBias.value;
				m_ShaderVariablesRayTracingCB._RayTracingDistantRayBias = component.distantRayBias.value;
				m_ShaderVariablesRayTracingCB._RayCountEnabled = m_RayCountManager.RayCountIsEnabled();
				m_ShaderVariablesRayTracingCB._RaytracingCameraNearPlane = hdCamera.camera.nearClipPlane;
				m_ShaderVariablesRayTracingCB._RaytracingPixelSpreadAngle = GetPixelSpreadAngle(hdCamera.camera.fieldOfView, hdCamera.actualWidth, hdCamera.actualHeight);
				m_ShaderVariablesRayTracingCB._RaytracingReflectionMinSmoothness = component2.minSmoothness;
				m_ShaderVariablesRayTracingCB._RaytracingReflectionSmoothnessFadeStart = component2.smoothnessFadeStart;
				m_ShaderVariablesRayTracingCB._DirectionalShadowFallbackIntensity = component.directionalShadowFallbackIntensity.value;
				m_ShaderVariablesRayTracingCB._RayTracingLodBias = 0f;
				ConstantBuffer.PushGlobal(cmd, in m_ShaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
			}
		}

		private void ConfigureKeywords(bool enableBakeShadowMask, HDCamera hdCamera, CommandBuffer cmd)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.ConfigureKeywords)))
			{
				bool flag = IsAPVEnabled();
				CoreUtils.SetKeyword(cmd, "SHADOWS_SHADOWMASK", enableBakeShadowMask);
				m_CurrentRendererConfigurationBakedLighting = HDUtils.GetRendererConfiguration(flag, enableBakeShadowMask);
				m_currentDebugViewMaterialGBuffer = (enableBakeShadowMask ? m_DebugViewMaterialGBufferShadowMask : m_DebugViewMaterialGBuffer);
				CoreUtils.SetKeyword(cmd, "LIGHT_LAYERS", hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers));
				if (m_Asset.currentPlatformRenderPipelineSettings.supportDecals)
				{
					CoreUtils.SetKeyword(cmd, "DECALS_OFF", state: false);
					CoreUtils.SetKeyword(cmd, "DECALS_3RT", !m_Asset.currentPlatformRenderPipelineSettings.decalSettings.perChannelMask);
					CoreUtils.SetKeyword(cmd, "DECALS_4RT", m_Asset.currentPlatformRenderPipelineSettings.decalSettings.perChannelMask);
				}
				else
				{
					CoreUtils.SetKeyword(cmd, "DECALS_OFF", state: true);
					CoreUtils.SetKeyword(cmd, "DECALS_3RT", state: false);
					CoreUtils.SetKeyword(cmd, "DECALS_4RT", state: false);
				}
				CoreUtils.SetKeyword(cmd, "PROBE_VOLUMES_OFF", !flag);
				CoreUtils.SetKeyword(cmd, "PROBE_VOLUMES_L1", flag && m_Asset.currentPlatformRenderPipelineSettings.probeVolumeSHBands == ProbeVolumeSHBands.SphericalHarmonicsL1);
				CoreUtils.SetKeyword(cmd, "PROBE_VOLUMES_L2", flag && m_Asset.currentPlatformRenderPipelineSettings.probeVolumeSHBands == ProbeVolumeSHBands.SphericalHarmonicsL2);
				CoreUtils.SetKeyword(cmd, "WRITE_NORMAL_BUFFER", hdCamera.frameSettings.litShaderMode == LitShaderMode.Forward);
				CoreUtils.SetKeyword(cmd, "WRITE_DECAL_BUFFER", hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers));
				CoreUtils.SetKeyword(cmd, "WRITE_MSAA_DEPTH", hdCamera.msaaEnabled);
				CoreUtils.SetKeyword(cmd, "SCREEN_COORD_OVERRIDE", hdCamera.frameSettings.IsEnabled(FrameSettingsField.ScreenCoordOverride));
			}
		}

		private void SetupDLSSForCameraDataAndDynamicResHandler(in HDAdditionalCameraData hdCam, Camera camera, XRPass xrPass, bool cameraRequestedDynamicRes, ref GlobalDynamicResolutionSettings outDrsSettings)
		{
			if (!(hdCam == null))
			{
				hdCam.cameraCanRenderDLSS = cameraRequestedDynamicRes && HDDynamicResolutionPlatformCapabilities.DLSSDetected && hdCam.allowDeepLearningSuperSampling && m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.enableDLSS && m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.enabled;
				if (m_DLSSPass != null && hdCam.cameraCanRenderDLSS)
				{
					bool enableAutomaticSettings = (hdCam.deepLearningSuperSamplingUseCustomAttributes ? hdCam.deepLearningSuperSamplingUseOptimalSettings : m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.DLSSUseOptimalSettings);
					m_DLSSPass.SetupDRSScaling(enableAutomaticSettings, camera, xrPass, ref outDrsSettings);
				}
			}
		}

		private void VisitRenderRequestRecursive(List<RenderRequest> requests, List<int> visitStatus, int requestIndex, List<int> renderIndices)
		{
			if (visitStatus[requestIndex] == 1)
			{
				throw new Exception("Cycle in render request dependencies!");
			}
			if (visitStatus[requestIndex] != 0)
			{
				return;
			}
			visitStatus[requestIndex] = 1;
			foreach (int dependsOnRenderRequestIndex in requests[requestIndex].dependsOnRenderRequestIndices)
			{
				VisitRenderRequestRecursive(requests, visitStatus, dependsOnRenderRequestIndex, renderIndices);
			}
			visitStatus[requestIndex] = 2;
			renderIndices.Add(requestIndex);
		}

		private void FlattenRenderRequestGraph(List<RenderRequest> requests, List<int> renderIndices)
		{
			List<int> value;
			using (ListPool<int>.Get(out value))
			{
				for (int i = 0; i < requests.Count; i++)
				{
					value.Add(0);
				}
				for (int j = 0; j < requests.Count; j++)
				{
					VisitRenderRequestRecursive(requests, value, j, renderIndices);
				}
			}
		}

		private bool PrepareAndCullCamera(Camera camera, XRPass xrPass, bool cameraRequestedDynamicRes, List<RenderRequest> renderRequests, ScriptableRenderContext renderContext, out RenderRequest renderRequest, CubemapFace cubemapFace = CubemapFace.Unknown)
		{
			renderRequest = default(RenderRequest);
			HDAdditionalCameraData additionalCameraData;
			HDCamera hdCamera;
			ScriptableCullingParameters cullingParams;
			bool flag = !TryCalculateFrameParameters(camera, xrPass, out additionalCameraData, out hdCamera, out cullingParams);
			HDCullingResults cullingResults = m_CullingResultsPool.Get();
			bool cullingResultIsShared = false;
			if (!flag)
			{
				VFXCameraXRSettings camXRSettings = default(VFXCameraXRSettings);
				camXRSettings.viewTotal = ((!hdCamera.xr.enabled) ? 1u : 2u);
				camXRSettings.viewCount = (uint)hdCamera.viewCount;
				camXRSettings.viewOffset = (uint)hdCamera.xr.multipassId;
				VFXManager.PrepareCamera(camera, camXRSettings);
				bool flag2 = true;
				if (xrPass.multipassId > 0)
				{
					foreach (RenderRequest renderRequest2 in renderRequests)
					{
						if (camera == renderRequest2.hdCamera.camera && renderRequest2.hdCamera.xr.cullingPassId == xrPass.cullingPassId)
						{
							m_CullingResultsPool.Release(cullingResults);
							cullingResults = renderRequest2.cullingResults;
							cullingResultIsShared = true;
							flag2 = false;
							m_SkyManager.UpdateCurrentSkySettings(hdCamera);
						}
					}
				}
				if (flag2)
				{
					flag = !TryCull(camera, hdCamera, renderContext, m_SkyManager, cullingParams, m_Asset, ref cullingResults);
				}
			}
			if (additionalCameraData.hasCustomRender && additionalCameraData.fullscreenPassthrough)
			{
				Debug.LogWarning("HDRP Camera custom render is not supported when Fullscreen Passthrough is enabled. Please either disable Fullscreen Passthrough in the camera settings or remove all customRender callbacks attached to this camera.");
				return false;
			}
			if (additionalCameraData != null && additionalCameraData.hasCustomRender)
			{
				flag = true;
				hdCamera.UpdateShaderVariablesGlobalCB(ref m_ShaderVariablesGlobalCB);
				ConstantBuffer.PushGlobal(in m_ShaderVariablesGlobalCB, HDShaderIDs._ShaderVariablesGlobal);
				RenderPipeline.BeginCameraRendering(renderContext, camera);
				additionalCameraData.ExecuteCustomRender(renderContext, hdCamera);
			}
			if (flag)
			{
				renderContext.Submit();
				m_CullingResultsPool.Release(cullingResults);
				RenderPipeline.EndCameraRendering(renderContext, camera);
				return false;
			}
			RenderTexture targetTexture = camera.targetTexture;
			RenderTargetIdentifier id = (((object)targetTexture != null) ? ((RenderTargetIdentifier)targetTexture) : new RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget));
			if (camera.targetTexture != null)
			{
				camera.targetTexture.IncrementUpdateCount();
			}
			if (hdCamera.xr.enabled)
			{
				id = hdCamera.xr.renderTarget;
			}
			hdCamera.RequestDynamicResolution(cameraRequestedDynamicRes, DynamicResolutionHandler.instance);
			renderRequest = new RenderRequest
			{
				hdCamera = hdCamera,
				cullingResults = cullingResults,
				target = new RenderRequest.Target
				{
					id = id,
					face = cubemapFace
				},
				dependsOnRenderRequestIndices = ListPool<int>.Get(),
				index = renderRequests.Count,
				cameraSettings = CameraSettings.From(hdCamera),
				viewDependentProbesData = ListPool<(HDProbe.RenderData, HDProbe)>.Get(),
				cullingResultIsShared = cullingResultIsShared
			};
			renderRequests.Add(renderRequest);
			return true;
		}

		private void DetermineVisibleProbesForRequest(in RenderRequest request, Dictionary<HDProbe, List<(int index, float weight)>> renderRequestIndicesWhereTheProbeIsVisible)
		{
			HDCullingResults cullingResults = request.cullingResults;
			for (int i = 0; i < cullingResults.cullingResults.visibleReflectionProbes.Length; i++)
			{
				VisibleReflectionProbe visibleReflectionProbe = cullingResults.cullingResults.visibleReflectionProbes[i];
				if (!visibleReflectionProbe.Equals(null) && !(visibleReflectionProbe.reflectionProbe == null) && !visibleReflectionProbe.reflectionProbe.Equals(null))
				{
					if (!visibleReflectionProbe.reflectionProbe.TryGetComponent<HDAdditionalReflectionData>(out var component))
					{
						component = visibleReflectionProbe.reflectionProbe.gameObject.AddComponent<HDAdditionalReflectionData>();
					}
					AddVisibleProbeVisibleIndexIfUpdateIsRequired(component, in request, renderRequestIndicesWhereTheProbeIsVisible);
				}
			}
			for (int j = 0; j < cullingResults.hdProbeCullingResults.visibleProbes.Count; j++)
			{
				AddVisibleProbeVisibleIndexIfUpdateIsRequired(cullingResults.hdProbeCullingResults.visibleProbes[j], in request, renderRequestIndicesWhereTheProbeIsVisible);
			}
		}

		private void AddVisibleProbeVisibleIndexIfUpdateIsRequired(HDProbe probe, in RenderRequest request, Dictionary<HDProbe, List<(int index, float weight)>> renderRequestIndicesWhereTheProbeIsVisible)
		{
			if (probe.requiresRealtimeUpdate)
			{
				Transform transform = request.hdCamera.camera.transform;
				float num = HDUtils.ComputeWeightedLinearFadeDistance(probe.transform.position, transform.position, probe.weight, probe.fadeDistance);
				if (num > 0f)
				{
					probe.SetIsRendered();
				}
				if (!renderRequestIndicesWhereTheProbeIsVisible.TryGetValue(probe, out List<(int, float)> value))
				{
					value = ListPool<(int, float)>.Get();
					renderRequestIndicesWhereTheProbeIsVisible.Add(probe, value);
				}
				if (!value.Contains((request.index, num)))
				{
					value.Add((request.index, num));
				}
			}
		}

		private void AddHDProbeRenderRequests(HDProbe visibleProbe, Transform viewerTransform, List<(int index, float weight)> visibilities, ulong overrideSceneCullingMask, HDCamera hdParentCamera, float referenceFieldOfView, float referenceAspect, ref List<HDProbe.RenderData> renderDatas, List<CameraSettings> cameraSettings, List<CameraPositionSettings> cameraPositionSettings, List<CubemapFace> cameraCubemapFaces, List<RenderRequest> renderRequests, ScriptableRenderContext renderContext)
		{
			ProbeRenderSteps probeRenderSteps = visibleProbe.NextRenderSteps();
			ProbeCapturePositionSettings position = ProbeCapturePositionSettings.ComputeFrom(visibleProbe, viewerTransform);
			cameraSettings.Clear();
			cameraPositionSettings.Clear();
			cameraCubemapFaces.Clear();
			HDRenderUtilities.GenerateRenderingSettingsFor(visibleProbe.settings, position, cameraSettings, cameraPositionSettings, cameraCubemapFaces, overrideSceneCullingMask, probeRenderSteps, forceFlipY: false, referenceFieldOfView, referenceAspect);
			GraphicsFormat reflectionProbeFormat = (GraphicsFormat)m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.reflectionProbeFormat;
			switch (visibleProbe.type)
			{
			case ProbeSettings.ProbeType.ReflectionProbe:
			{
				int cubeResolution = (int)visibleProbe.cubeResolution;
				_ = ((HDRenderPipeline)RenderPipelineManager.currentPipeline).currentPlatformRenderPipelineSettings;
				if (visibleProbe.realtimeTextureRTH == null || visibleProbe.realtimeTextureRTH.rt.width != cubeResolution || visibleProbe.realtimeTextureRTH.rt.graphicsFormat != reflectionProbeFormat)
				{
					visibleProbe.SetTexture(ProbeSettings.Mode.Realtime, HDRenderUtilities.CreateReflectionProbeRenderTarget(cubeResolution, reflectionProbeFormat));
				}
				break;
			}
			case ProbeSettings.ProbeType.PlanarProbe:
			{
				int resolution = (int)visibleProbe.resolution;
				if (visibleProbe.realtimeTextureRTH == null || visibleProbe.realtimeTextureRTH.rt.width != resolution || visibleProbe.realtimeTextureRTH.rt.graphicsFormat != reflectionProbeFormat)
				{
					visibleProbe.SetTexture(ProbeSettings.Mode.Realtime, HDRenderUtilities.CreatePlanarProbeRenderTarget(resolution, reflectionProbeFormat));
				}
				if (visibleProbe.realtimeDepthTextureRTH == null || visibleProbe.realtimeDepthTextureRTH.rt.width != resolution)
				{
					visibleProbe.SetDepthTexture(ProbeSettings.Mode.Realtime, HDRenderUtilities.CreatePlanarProbeDepthRenderTarget(resolution));
				}
				for (int i = 0; i < cameraSettings.Count; i++)
				{
					CameraSettings value = cameraSettings[i];
					if (value.volumes.anchorOverride == null)
					{
						value.volumes.anchorOverride = viewerTransform;
						cameraSettings[i] = value;
					}
				}
				break;
			}
			}
			ProbeRenderSteps probeRenderSteps2 = ProbeRenderSteps.None;
			for (int j = 0; j < cameraSettings.Count; j++)
			{
				CubemapFace cubemapFace = cameraCubemapFaces[j];
				Camera orCreate = m_ProbeCameraCache.GetOrCreate((viewerTransform, visibleProbe, cubemapFace), Time.frameCount, CameraType.Reflection);
				GlobalDynamicResolutionSettings dynamicResolutionSettings = m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings;
				dynamicResolutionSettings.forcedPercentage = 100f;
				dynamicResolutionSettings.forceResolution = true;
				DynamicResolutionHandler.UpdateAndUseCamera(orCreate, dynamicResolutionSettings);
				foreach (Terrain activeTerrain in m_ActiveTerrains)
				{
					activeTerrain.SetKeepUnusedCameraRenderingResources(orCreate.GetInstanceID(), keepUnused: true);
				}
				if (!orCreate.TryGetComponent<HDAdditionalCameraData>(out var component))
				{
					component = orCreate.gameObject.AddComponent<HDAdditionalCameraData>();
				}
				component.hasPersistentHistory = true;
				orCreate.targetTexture = visibleProbe.realtimeTexture;
				orCreate.gameObject.hideFlags = HideFlags.HideAndDontSave;
				orCreate.gameObject.SetActive(value: false);
				orCreate.name = visibleProbe.probeName[j];
				orCreate.ApplySettings(cameraSettings[j]);
				orCreate.ApplySettings(cameraPositionSettings[j]);
				orCreate.cameraType = CameraType.Reflection;
				orCreate.pixelRect = new Rect(0f, 0f, visibleProbe.realtimeTexture.width, visibleProbe.realtimeTexture.height);
				component.clearDepth = true;
				HDCullingResults cullingResults = m_CullingResultsPool.Get();
				cullingResults.Reset();
				if (!TryCalculateFrameParameters(orCreate, XRSystem.emptyPass, out var _, out var hdCamera, out var cullingParams) || !TryCull(orCreate, hdCamera, renderContext, m_SkyManager, cullingParams, m_Asset, ref cullingResults))
				{
					m_CullingResultsPool.Release(cullingResults);
					probeRenderSteps2 |= ProbeRenderStepsExt.FromCubeFace(cubemapFace);
					continue;
				}
				bool useGpuFetchedExposure = false;
				float num = 1f;
				if (visibleProbe.type == ProbeSettings.ProbeType.PlanarProbe)
				{
					visibleProbe.ExposureControlEnabled = hdCamera.exposureControlFS;
					if (visibleProbe.ExposureControlEnabled)
					{
						RTHandle exposureTexture = GetExposureTexture(hdParentCamera);
						hdParentCamera.RequestGpuExposureValue(exposureTexture);
						num = hdParentCamera.GpuExposureValue();
						visibleProbe.SetProbeExposureValue(num);
						component.deExposureMultiplier = 1f;
						component.backgroundColorHDR *= visibleProbe.ProbeExposureValue();
					}
					else
					{
						hdParentCamera.RequestGpuDeExposureValue(GetExposureTextureHandle(hdParentCamera.currentExposureTextures.previous));
						visibleProbe.SetProbeExposureValue(num);
						component.deExposureMultiplier = 1f / hdParentCamera.GpuDeExposureValue();
					}
					useGpuFetchedExposure = true;
				}
				else
				{
					hdCamera.realtimeReflectionProbe = visibleProbe.mode == ProbeSettings.Mode.Realtime;
				}
				hdCamera.SetParentCamera(hdParentCamera, useGpuFetchedExposure, num);
				orCreate.TryGetComponent<HDAdditionalCameraData>(out var component2);
				component2.flipYMode = ((visibleProbe.type == ProbeSettings.ProbeType.ReflectionProbe) ? HDAdditionalCameraData.FlipYMode.ForceFlipY : HDAdditionalCameraData.FlipYMode.Automatic);
				if (!visibleProbe.realtimeTexture.IsCreated())
				{
					visibleProbe.realtimeTexture.Create();
				}
				HDProbe.RenderData renderData = new HDProbe.RenderData(orCreate.worldToCameraMatrix, orCreate.projectionMatrix, orCreate.transform.position, orCreate.transform.rotation, cameraSettings[j].frustum.fieldOfView, cameraSettings[j].frustum.aspect);
				renderDatas.Add(renderData);
				visibleProbe.SetRenderData(ProbeSettings.Mode.Realtime, renderData);
				RenderRequest renderRequest = default(RenderRequest);
				renderRequest.hdCamera = hdCamera;
				renderRequest.cullingResults = cullingResults;
				renderRequest.clearCameraSettings = true;
				renderRequest.dependsOnRenderRequestIndices = ListPool<int>.Get();
				renderRequest.index = renderRequests.Count;
				renderRequest.cameraSettings = cameraSettings[j];
				renderRequest.viewDependentProbesData = ListPool<(HDProbe.RenderData, HDProbe)>.Get();
				RenderRequest item = renderRequest;
				if (cubemapFace != CubemapFace.Unknown)
				{
					item.target = new RenderRequest.Target
					{
						id = visibleProbe.realtimeTextureRTH,
						face = cubemapFace
					};
				}
				else
				{
					item.target = new RenderRequest.Target
					{
						id = visibleProbe.realtimeTextureRTH,
						targetDepth = visibleProbe.realtimeDepthTextureRTH,
						face = CubemapFace.Unknown
					};
				}
				if (!m_SkyManager.HasSetValidAmbientProbe(hdCamera))
				{
					probeRenderSteps2 |= ProbeRenderStepsExt.FromCubeFace(cubemapFace);
				}
				renderRequests.Add(item);
				foreach (var visibility in visibilities)
				{
					renderRequests[visibility.index].dependsOnRenderRequestIndices.Add(item.index);
				}
			}
			if (m_FrameCount <= 1)
			{
				probeRenderSteps2 = probeRenderSteps;
			}
			if (probeRenderSteps.HasFlag(ProbeRenderSteps.IncrementRenderCount))
			{
				if (probeRenderSteps2.IsNone())
				{
					visibleProbe.IncrementRealtimeRenderCount();
				}
				else
				{
					probeRenderSteps2 |= ProbeRenderSteps.IncrementRenderCount;
				}
			}
			visibleProbe.RepeatRenderSteps(probeRenderSteps2);
		}

		private void GenerateProbeRenderRequests(Dictionary<HDProbe, List<(int index, float weight)>> renderRequestIndicesWhereTheProbeIsVisible, List<RenderRequest> renderRequests, List<CameraSettings> cameraSettings, List<CameraPositionSettings> cameraPositionSettings, List<CubemapFace> cameraCubemapFaces, ScriptableRenderContext renderContext)
		{
			foreach (KeyValuePair<HDProbe, List<(int, float)>> item3 in renderRequestIndicesWhereTheProbeIsVisible)
			{
				HDProbe key = item3.Key;
				List<(int, float)> value = item3.Value;
				HDCamera hdCamera;
				if (key.type == ProbeSettings.ProbeType.PlanarProbe)
				{
					for (int i = 0; i < value.Count; i++)
					{
						(int, float) item = value[i];
						if (item.Item2 <= 0f)
						{
							continue;
						}
						int item2 = item.Item1;
						RenderRequest renderRequest = renderRequests[item2];
						Transform transform = renderRequest.hdCamera.camera.transform;
						hdCamera = renderRequest.hdCamera;
						List<HDProbe.RenderData> renderDatas = ListPool<HDProbe.RenderData>.Get();
						s_TempGenerateProbeRenderRequestsList.Clear();
						s_TempGenerateProbeRenderRequestsList.Add(item);
						AddHDProbeRenderRequests(key, transform, s_TempGenerateProbeRenderRequestsList, HDUtils.GetSceneCullingMaskFromCamera(renderRequest.hdCamera.camera), hdCamera, renderRequest.hdCamera.camera.fieldOfView, renderRequest.hdCamera.camera.aspect, ref renderDatas, cameraSettings, cameraPositionSettings, cameraCubemapFaces, renderRequests, renderContext);
						foreach (HDProbe.RenderData item4 in renderDatas)
						{
							renderRequest.viewDependentProbesData.Add((item4, key));
						}
						ListPool<HDProbe.RenderData>.Release(renderDatas);
					}
					continue;
				}
				hdCamera = null;
				bool flag = false;
				for (int j = 0; j < value.Count; j++)
				{
					if (flag)
					{
						break;
					}
					if (value[j].Item2 > 0f)
					{
						flag = true;
					}
				}
				if (flag)
				{
					List<HDProbe.RenderData> renderDatas2 = ListPool<HDProbe.RenderData>.Get();
					AddHDProbeRenderRequests(key, null, value, 0uL, hdCamera, 90f, 1f, ref renderDatas2, cameraSettings, cameraPositionSettings, cameraCubemapFaces, renderRequests, renderContext);
					ListPool<HDProbe.RenderData>.Release(renderDatas2);
				}
			}
		}

		private void ExecuteAOVRenderRequests(in RenderRequest renderRequest, CommandBuffer cmd, ScriptableRenderContext renderContext)
		{
			foreach (AOVRequestData aovRequest in renderRequest.hdCamera.aovRequests)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.HDRenderPipelineRenderAOV)))
				{
					BufferedRTHandleSystem historyRTHandleSystem = renderRequest.hdCamera.GetHistoryRTHandleSystem(aovRequest);
					renderRequest.hdCamera.BindHistoryRTHandleSystem(historyRTHandleSystem);
					cmd.SetInvertCulling(renderRequest.cameraSettings.invertFaceCulling);
					ExecuteRenderRequest(renderRequest, renderContext, cmd, aovRequest);
					cmd.SetInvertCulling(invertCulling: false);
				}
				renderContext.ExecuteCommandBuffer(cmd);
				renderContext.Submit();
				cmd.Clear();
			}
		}

		private void EndRenderRequest(in RenderRequest renderRequest, CommandBuffer cmd)
		{
			if (renderRequest.clearCameraSettings)
			{
				renderRequest.hdCamera.camera.targetTexture = null;
			}
			ListPool<int>.Release(renderRequest.dependsOnRenderRequestIndices);
			ListPool<(HDProbe.RenderData, HDProbe)>.Release(renderRequest.viewDependentProbesData);
			if (!renderRequest.cullingResultIsShared)
			{
				renderRequest.cullingResults.decalCullResults?.Clear();
				m_CullingResultsPool.Release(renderRequest.cullingResults);
			}
		}

		protected override void Render(ScriptableRenderContext renderContext, Camera[] cameras)
		{
			Render(renderContext, new List<Camera>(cameras));
		}

		internal void InternalRender(ScriptableRenderContext renderContext, List<Camera> cameras)
		{
			Render(renderContext, cameras);
		}

		protected override void Render(ScriptableRenderContext renderContext, List<Camera> cameras)
		{
			SupportedRenderingFeatures.active.rendersUIOverlay = HDROutputIsActive();
			if (!m_ValidAPI || cameras.Count == 0)
			{
				return;
			}
			m_GlobalSettings.GetOrCreateDefaultVolume();
			if (m_GlobalSettings.lensAttenuationMode == LensAttenuationMode.ImperfectLens)
			{
				ColorUtils.s_LensAttenuation = 0.65f;
			}
			else if (m_GlobalSettings.lensAttenuationMode == LensAttenuationMode.PerfectLens)
			{
				ColorUtils.s_LensAttenuation = 0.78f;
			}
			DecalSystem.instance.StartDecalUpdateJobs();
			LightLoopNewRender();
			RenderPipeline.BeginContextRendering(renderContext, cameras);
			m_FrameSettingsHistoryEnabled = FrameSettingsHistory.enabled;
			int frameCount = Time.frameCount;
			if (frameCount != m_FrameCount)
			{
				m_FrameCount = frameCount;
				m_ProbeCameraCache.ReleaseCamerasUnusedFor(2, Time.frameCount);
				HDCamera.CleanUnused();
			}
			if (m_Asset.currentPlatformRenderPipelineSettings.supportWater)
			{
				CommandBuffer commandBuffer = CommandBufferPool.Get("");
				UpdateWaterSurfaces(commandBuffer);
				renderContext.ExecuteCommandBuffer(commandBuffer);
				renderContext.Submit();
				commandBuffer.Clear();
				CommandBufferPool.Release(commandBuffer);
			}
			Terrain.GetActiveTerrains(m_ActiveTerrains);
			XRSystem.singlePassAllowed = m_Asset.currentPlatformRenderPipelineSettings.xrSettings.singlePass;
			XRLayout xRLayout = XRSystem.NewLayout();
			List<RenderRequest> value;
			using (ListPool<RenderRequest>.Get(out value))
			{
				Dictionary<HDProbe, List<(int, float)>> value2;
				using (DictionaryPool<HDProbe, List<(int, float)>>.Get(out value2))
				{
					List<CameraSettings> value3;
					using (ListPool<CameraSettings>.Get(out value3))
					{
						List<CameraPositionSettings> value4;
						using (ListPool<CameraPositionSettings>.Get(out value4))
						{
							List<CubemapFace> value5;
							using (ListPool<CubemapFace>.Get(out value5))
							{
								foreach (Camera camera2 in cameras)
								{
									xRLayout.AddCamera(camera2, HDUtils.TryGetAdditionalCameraDataOrDefault(camera2).xrRendering);
								}
								RTHandles.SetHardwareDynamicResolutionState(m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.dynResType == DynamicResolutionType.Hardware);
								foreach (var (camera, xrPass) in xRLayout.GetActivePasses())
								{
									if (!(camera == null))
									{
										bool flag = false;
										HDAdditionalCameraData component = null;
										GlobalDynamicResolutionSettings outDrsSettings = m_Asset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings;
										DynamicResolutionHandler.SetActiveDynamicScalerSlot(DynamicResScalerSlot.User);
										if (camera.TryGetComponent<HDAdditionalCameraData>(out component))
										{
											flag = component.allowDynamicResolution && camera.cameraType == CameraType.Game;
											flag &= !HDCamera.GetOrCreate(camera).IsPathTracingEnabled();
										}
										SetupDLSSForCameraDataAndDynamicResHandler(in component, camera, xrPass, flag, ref outDrsSettings);
										DynamicResolutionHandler.UpdateAndUseCamera(camera);
										DynamicResolutionHandler instance = DynamicResolutionHandler.instance;
										if (component != null && outDrsSettings.dynResType == DynamicResolutionType.Hardware && flag && !camera.allowDynamicResolution)
										{
											instance.ForceSoftwareFallback();
										}
										instance.SetCurrentCameraRequest(flag);
										instance.runUpscalerFilterOnFullResolution = (component != null && component.cameraCanRenderDLSS) || DynamicResolutionHandler.instance.filter == DynamicResUpscaleFilter.TAAU;
										instance.Update(outDrsSettings);
										if (PrepareAndCullCamera(camera, xrPass, flag, value, renderContext, out var renderRequest))
										{
											DetermineVisibleProbesForRequest(in renderRequest, value2);
										}
									}
								}
								GenerateProbeRenderRequests(value2, value, value3, value4, value5, renderContext);
								foreach (KeyValuePair<HDProbe, List<(int, float)>> item2 in value2)
								{
									ListPool<(int, float)>.Release(item2.Value);
								}
								value2.Clear();
								List<int> value6;
								using (ListPool<int>.Get(out value6))
								{
									FlattenRenderRequestGraph(value, value6);
									using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.HDRenderPipelineAllRenderRequest)))
									{
										Vector2Int vector2Int = new Vector2Int(1, 1);
										for (int i = 0; i < value6.Count; i++)
										{
											int index = value6[i];
											HDCamera hdCamera = value[index].hdCamera;
											vector2Int.x = Math.Max((int)hdCamera.finalViewport.size.x, vector2Int.x);
											vector2Int.y = Math.Max((int)hdCamera.finalViewport.size.y, vector2Int.y);
										}
										RTHandles.SetReferenceSize(vector2Int.x, vector2Int.y);
										for (int j = 0; j < value6.Count; j++)
										{
											bool flag2 = j == value6.Count - 1;
											int index2 = value6[j];
											RenderRequest renderRequest2 = value[index2];
											CommandBuffer commandBuffer2 = CommandBufferPool.Get("");
											foreach (var viewDependentProbesDatum in renderRequest2.viewDependentProbesData)
											{
												HDProbe item = viewDependentProbesDatum.Item2;
												var (renderData, _) = viewDependentProbesDatum;
												item.SetRenderData(ProbeSettings.Mode.Realtime, renderData);
											}
											BufferedRTHandleSystem historyRTHandleSystem = renderRequest2.hdCamera.GetHistoryRTHandleSystem();
											ExecuteAOVRenderRequests(in renderRequest2, commandBuffer2, renderContext);
											renderRequest2.hdCamera.BindHistoryRTHandleSystem(historyRTHandleSystem);
											using (new ProfilingScope(commandBuffer2, renderRequest2.hdCamera.profilingSampler))
											{
												commandBuffer2.SetInvertCulling(renderRequest2.cameraSettings.invertFaceCulling);
												ExecuteRenderRequest(renderRequest2, renderContext, commandBuffer2, AOVRequestData.defaultAOVRequestDataNonAlloc);
												commandBuffer2.SetInvertCulling(invertCulling: false);
											}
											RenderPipeline.EndCameraRendering(renderContext, renderRequest2.hdCamera.camera);
											EndRenderRequest(in renderRequest2, commandBuffer2);
											if (flag2 && renderRequest2.hdCamera.camera.cameraType == CameraType.Game && renderRequest2.hdCamera.camera.targetTexture == null && HDUtils.TryGetAdditionalCameraDataOrDefault(renderRequest2.hdCamera.camera).xrRendering)
											{
												XRSystem.RenderMirrorView(commandBuffer2, renderRequest2.hdCamera.camera);
											}
											CollectScreenSpaceShadowData();
											renderContext.ExecuteCommandBuffer(commandBuffer2);
											CommandBufferPool.Release(commandBuffer2);
											renderContext.Submit();
										}
									}
								}
							}
						}
					}
				}
			}
			PropagateScreenSpaceShadowData();
			DynamicResolutionHandler.ClearSelectedCamera();
			m_RenderGraph.EndFrame();
			XRSystem.EndLayout();
			RenderPipeline.EndContextRendering(renderContext, cameras);
		}

		private void CollectScreenSpaceShadowData()
		{
			ScreenSpaceShadowData[] currentScreenSpaceShadowData = m_CurrentScreenSpaceShadowData;
			for (int i = 0; i < currentScreenSpaceShadowData.Length; i++)
			{
				ScreenSpaceShadowData screenSpaceShadowData = currentScreenSpaceShadowData[i];
				if (screenSpaceShadowData.valid)
				{
					HDAdditionalLightData additionalLightData = screenSpaceShadowData.additionalLightData;
					m_ScreenSpaceShadowsUnion.Add(additionalLightData);
				}
			}
			if (m_CurrentSunLightAdditionalLightData != null)
			{
				m_ScreenSpaceShadowsUnion.Add(m_CurrentSunLightAdditionalLightData);
			}
		}

		private void PropagateScreenSpaceShadowData()
		{
			foreach (HDAdditionalLightData item in m_ScreenSpaceShadowsUnion)
			{
				item.previousTransform = item.transform.localToWorldMatrix;
			}
		}

		private void ExecuteRenderRequest(RenderRequest renderRequest, ScriptableRenderContext renderContext, CommandBuffer cmd, AOVRequestData aovRequest)
		{
			DynamicResolutionHandler.UpdateAndUseCamera(renderRequest.hdCamera.camera);
			InitializeGlobalResources(renderContext);
			HDCamera hdCamera = renderRequest.hdCamera;
			Camera camera = hdCamera.camera;
			CullingResults cullingResults = renderRequest.cullingResults.cullingResults;
			CullingResults? customPassCullingResults = renderRequest.cullingResults.customPassCullingResults;
			if (customPassCullingResults.HasValue)
			{
				customPassCullingResults.GetValueOrDefault();
			}
			_ = renderRequest.cullingResults.uiCullingResults;
			HDProbeCullingResults hdProbeCullingResults = renderRequest.cullingResults.hdProbeCullingResults;
			DecalSystem.CullResult decalCullResults = renderRequest.cullingResults.decalCullResults;
			RenderRequest.Target target = renderRequest.target;
			m_FullScreenDebugPushed = false;
			hdCamera.BeginRender(cmd);
			SetHDRState(hdCamera);
			if (m_RayTracingSupported)
			{
				using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.RaytracingBuildAccelerationStructure)))
				{
					BuildRayTracingAccelerationStructure(hdCamera);
				}
				CullForRayTracing(cmd, hdCamera);
			}
			List<RTHandle> value;
			using (ListPool<RTHandle>.Get(out value))
			{
				List<RTHandle> value2;
				using (ListPool<RTHandle>.Get(out value2))
				{
					aovRequest.AllocateTargetTexturesIfRequired(ref value, ref value2);
					if (camera.cameraType == CameraType.Reflection || camera.cameraType == CameraType.Preview)
					{
						m_CurrentDebugDisplaySettings = s_NeutralDebugDisplaySettings;
					}
					else
					{
						m_CurrentDebugDisplaySettings = m_DebugDisplaySettings;
					}
					aovRequest.SetupDebugData(ref m_CurrentDebugDisplaySettings);
					if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals))
					{
						using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DBufferPrepareDrawData)))
						{
							DecalSystem.instance.CurrentCamera = hdCamera.camera;
							DecalSystem.instance.LoadCullResults(decalCullResults);
							DecalSystem.instance.UpdateCachedMaterialData();
							DecalSystem.instance.CreateDrawData();
							DecalSystem.instance.UpdateTextureAtlas(cmd);
						}
					}
					if (m_DebugDisplaySettings.IsDebugDisplayRemovePostprocess())
					{
						using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.CustomPassBufferClearDebug)))
						{
							if (m_CustomPassColorBuffer.IsValueCreated && m_CustomPassDepthBuffer.IsValueCreated)
							{
								CoreUtils.SetRenderTarget(cmd, m_CustomPassColorBuffer.Value, m_CustomPassDepthBuffer.Value, ClearFlag.All);
							}
							else if (m_CustomPassColorBuffer.IsValueCreated)
							{
								CoreUtils.SetRenderTarget(cmd, m_CustomPassColorBuffer.Value, ClearFlag.Color);
							}
							else if (m_CustomPassDepthBuffer.IsValueCreated)
							{
								CoreUtils.SetRenderTarget(cmd, m_CustomPassDepthBuffer.Value, ClearFlag.Depth);
							}
						}
					}
					if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.CustomPass))
					{
						using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.CustomPassVolumeUpdate)))
						{
							CustomPassVolume.Update(hdCamera);
						}
					}
					LightLoopNewFrame(cmd, hdCamera);
					cmd.DisableScissorRect();
					Resize(hdCamera);
					BeginPostProcessFrame(cmd, hdCamera, this);
					ApplyDebugDisplaySettings(hdCamera, cmd, aovRequest.isValid);
					if (DebugManager.instance.isAnyDebugUIActive)
					{
						m_CurrentDebugDisplaySettings.UpdateAveragedProfilerTimings();
					}
					SetupCameraProperties(hdCamera, renderContext, cmd);
					foreach (RenderPipelineMaterial material in m_MaterialList)
					{
						material.Bind(cmd);
					}
					PrepareVisibleLocalVolumetricFogList(hdCamera, cmd);
					BindAPVRuntimeResources(cmd, hdCamera);
					bool enableBakeShadowMask = PrepareLightsForGPU(cmd, hdCamera, cullingResults, hdProbeCullingResults, m_CurrentDebugDisplaySettings, aovRequest);
					UpdateGlobalConstantBuffers(hdCamera, cmd);
					if (m_RayTracingSupported)
					{
						m_RayCountManager.SetRayCountEnabled(m_CurrentDebugDisplaySettings.data.countRays);
						BuildRayTracingLightData(cmd, hdCamera, m_CurrentDebugDisplaySettings);
					}
					ConfigureKeywords(enableBakeShadowMask, hdCamera, cmd);
					VFXCameraXRSettings camXRSettings = default(VFXCameraXRSettings);
					camXRSettings.viewTotal = ((!hdCamera.xr.enabled) ? 1u : 2u);
					camXRSettings.viewCount = (uint)hdCamera.viewCount;
					camXRSettings.viewOffset = (uint)hdCamera.xr.multipassId;
					VFXManager.ProcessCameraCommand(camera, cmd, camXRSettings, cullingResults);
					if (GL.wireframe)
					{
						RenderWireFrame(cullingResults, hdCamera, target.id, renderContext, cmd);
						return;
					}
					try
					{
						ExecuteWithRenderGraph(renderRequest, aovRequest, value, value2, renderContext, cmd);
					}
					catch (Exception exception)
					{
						Debug.LogError("Error while building Render Graph.");
						Debug.LogException(exception);
					}
				}
			}
			renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		private void SetupCameraProperties(HDCamera hdCamera, ScriptableRenderContext renderContext, CommandBuffer cmd)
		{
			renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
			renderContext.SetupCameraProperties(hdCamera.camera, hdCamera.xr.enabled);
		}

		private void InitializeGlobalResources(ScriptableRenderContext renderContext)
		{
			CommandBuffer commandBuffer = CommandBufferPool.Get("");
			for (int i = 0; i < m_IBLFilterArray.Length; i++)
			{
				if (!m_IBLFilterArray[i].IsInitialized())
				{
					m_IBLFilterArray[i].Initialize(commandBuffer);
				}
			}
			foreach (RenderPipelineMaterial material in m_MaterialList)
			{
				material.RenderInit(commandBuffer);
			}
			TextureXR.Initialize(commandBuffer, defaultResources.shaders.clearUIntTextureCS);
			renderContext.ExecuteCommandBuffer(commandBuffer);
			CommandBufferPool.Release(commandBuffer);
		}

		private bool TryCalculateFrameParameters(Camera camera, XRPass xrPass, out HDAdditionalCameraData additionalCameraData, out HDCamera hdCamera, out ScriptableCullingParameters cullingParams)
		{
			additionalCameraData = HDUtils.TryGetAdditionalCameraDataOrDefault(camera);
			hdCamera = null;
			cullingParams = default(ScriptableCullingParameters);
			FrameSettings aggregatedFrameSettings = default(FrameSettings);
			if (m_FrameSettingsHistoryEnabled && camera.cameraType != CameraType.Preview && camera.cameraType != CameraType.Reflection)
			{
				FrameSettingsHistory.AggregateFrameSettings(ref aggregatedFrameSettings, camera, additionalCameraData, m_Asset, null);
			}
			else
			{
				FrameSettings.AggregateFrameSettings(ref aggregatedFrameSettings, camera, additionalCameraData, m_Asset);
			}
			aggregatedFrameSettings.sssResolvedSampleBudget = aggregatedFrameSettings.GetResolvedSssSampleBudget(m_Asset);
			aggregatedFrameSettings.SetEnabled(FrameSettingsField.RayTracing, aggregatedFrameSettings.IsEnabled(FrameSettingsField.RayTracing) && m_RayTracingSupported);
			if (additionalCameraData.fullscreenPassthrough)
			{
				return false;
			}
			DebugDisplaySettings debugDisplaySettings = ((camera.cameraType == CameraType.Reflection || camera.cameraType == CameraType.Preview) ? s_NeutralDebugDisplaySettings : m_DebugDisplaySettings);
			if (debugDisplaySettings.IsDebugDisplayEnabled())
			{
				if (debugDisplaySettings.IsDebugDisplayRemovePostprocess())
				{
					aggregatedFrameSettings.SetEnabled(FrameSettingsField.Postprocess, value: false);
					aggregatedFrameSettings.SetEnabled(FrameSettingsField.CustomPass, value: false);
				}
				if (!debugDisplaySettings.DebugNeedsExposure())
				{
					aggregatedFrameSettings.SetEnabled(FrameSettingsField.ExposureControl, value: false);
				}
				if (debugDisplaySettings.data.lightingDebugSettings.debugLightingMode == DebugLightingMode.LuxMeter)
				{
					aggregatedFrameSettings.SetEnabled(FrameSettingsField.SubsurfaceScattering, value: false);
				}
			}
			if (CoreUtils.IsSceneLightingDisabled(camera))
			{
				aggregatedFrameSettings.SetEnabled(FrameSettingsField.ExposureControl, value: false);
			}
			if (camera.cameraType != CameraType.Game)
			{
				aggregatedFrameSettings.SetEnabled(FrameSettingsField.ObjectMotionVectors, value: false);
				aggregatedFrameSettings.SetEnabled(FrameSettingsField.TransparentsWriteMotionVector, value: false);
			}
			hdCamera = HDCamera.GetOrCreate(camera, xrPass.multipassId);
			if (additionalCameraData != null)
			{
				aggregatedFrameSettings.SetEnabled(FrameSettingsField.Antialiasing, aggregatedFrameSettings.IsEnabled(FrameSettingsField.Antialiasing) && !additionalCameraData.cameraCanRenderDLSS);
			}
			hdCamera.Update(aggregatedFrameSettings, this, xrPass);
			if (additionalCameraData != null && additionalCameraData.hasCustomRender)
			{
				return false;
			}
			if (hdCamera.xr.enabled)
			{
				cullingParams = hdCamera.xr.cullingParams;
				if (!camera.usePhysicalProperties && !XRGraphicsAutomatedTests.enabled)
				{
					camera.fieldOfView = 57.29578f * Mathf.Atan(1f / cullingParams.stereoProjectionMatrix.m11) * 2f;
				}
			}
			else if (!camera.TryGetCullingParameters(camera.stereoEnabled, out cullingParams))
			{
				return false;
			}
			if (m_DebugDisplaySettings.IsCameraFreezeEnabled())
			{
				if (m_DebugDisplaySettings.IsCameraFrozen(camera))
				{
					if (!frozenCullingParamAvailable)
					{
						frozenCullingParams = cullingParams;
						frozenCullingParamAvailable = true;
					}
					cullingParams = frozenCullingParams;
				}
			}
			else
			{
				frozenCullingParamAvailable = false;
			}
			LightLoopUpdateCullingParameters(ref cullingParams, hdCamera);
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.ReflectionProbe))
			{
				cullingParams.cullingOptions |= CullingOptions.NeedsReflectionProbes;
			}
			else
			{
				cullingParams.cullingOptions &= ~CullingOptions.NeedsReflectionProbes;
			}
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.ShadowMaps) || currentAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxShadowRequests == 0)
			{
				cullingParams.cullingOptions &= ~CullingOptions.ShadowCasters;
			}
			return true;
		}

		private static void OverrideCullingForRayTracing(HDCamera hdCamera, Camera camera, ref ScriptableCullingParameters cullingParams)
		{
			RayTracingSettings component = hdCamera.volumeStack.GetComponent<RayTracingSettings>();
			if (component.extendShadowCulling.value || component.extendCameraCulling.value)
			{
				Plane plane = default(Plane);
				CameraProperties cameraProperties = cullingParams.cameraProperties;
				plane.SetNormalAndPosition(camera.transform.right, camera.transform.position - camera.transform.right * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(0, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(0, plane);
				}
				plane.SetNormalAndPosition(-camera.transform.right, camera.transform.position + camera.transform.right * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(1, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(1, plane);
				}
				plane.SetNormalAndPosition(camera.transform.up, camera.transform.position - camera.transform.up * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(2, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(2, plane);
				}
				plane.SetNormalAndPosition(-camera.transform.up, camera.transform.position + camera.transform.up * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(3, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(3, plane);
				}
				plane.SetNormalAndPosition(camera.transform.forward, camera.transform.position - camera.transform.forward * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(4, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(4, plane);
				}
				plane.SetNormalAndPosition(-camera.transform.forward, camera.transform.position + camera.transform.forward * camera.farClipPlane);
				if (component.extendShadowCulling.value)
				{
					cameraProperties.SetShadowCullingPlane(5, plane);
				}
				if (component.extendCameraCulling.value)
				{
					cullingParams.SetCullingPlane(5, plane);
				}
				cullingParams.cameraProperties = cameraProperties;
			}
		}

		private static bool TryCull(Camera camera, HDCamera hdCamera, ScriptableRenderContext renderContext, SkyManager skyManager, ScriptableCullingParameters cullingParams, HDRenderPipelineAsset hdrp, ref HDCullingResults cullingResults)
		{
			if (camera.cameraType == CameraType.Reflection || camera.cameraType == CameraType.Preview)
			{
				ScriptableRenderContext.EmitGeometryForCamera(camera);
			}
			ProbeReferenceVolume.instance.RenderDebug(hdCamera.camera);
			float lodBias = QualitySettings.lodBias;
			int maximumLODLevel = QualitySettings.maximumLODLevel;
			try
			{
				QualitySettings.SetLODSettings(hdCamera.frameSettings.GetResolvedLODBias(hdrp), hdCamera.frameSettings.GetResolvedMaximumLODLevel(hdrp), setDirty: false);
				RenderPipeline.BeginCameraRendering(renderContext, camera);
				DecalSystem.CullRequest cullRequest = null;
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals))
				{
					cullRequest = GenericPool<DecalSystem.CullRequest>.Get();
					DecalSystem.instance.CurrentCamera = camera;
					DecalSystem.instance.BeginCull(cullRequest);
				}
				HDProbeCullState state = default(HDProbeCullState);
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.PlanarProbe))
				{
					state = HDProbeSystem.PrepareCull(camera);
				}
				skyManager.UpdateCurrentSkySettings(hdCamera);
				skyManager.SetupAmbientProbe(hdCamera);
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
				{
					OverrideCullingForRayTracing(hdCamera, camera, ref cullingParams);
				}
				using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.CullResultsCull)))
				{
					cullingResults.cullingResults = renderContext.Cull(ref cullingParams);
				}
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.CustomPass))
				{
					using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.CustomPassCullResultsCull)))
					{
						cullingResults.customPassCullingResults = CustomPassVolume.Cull(renderContext, hdCamera);
					}
				}
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.PlanarProbe) && state.cullingGroup != null)
				{
					HDProbeSystem.QueryCullResults(state, ref cullingResults.hdProbeCullingResults);
				}
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals))
				{
					using (new ProfilingScope(null, ProfilingSampler.Get(HDProfileId.DBufferPrepareDrawData)))
					{
						DecalSystem.instance.EndCull(cullRequest, cullingResults.decalCullResults);
					}
				}
				if (cullRequest != null)
				{
					cullRequest.Clear();
					GenericPool<DecalSystem.CullRequest>.Release(cullRequest);
				}
				return true;
			}
			finally
			{
				QualitySettings.SetLODSettings(lodBias, maximumLODLevel, setDirty: false);
			}
		}

		private static RendererListDesc CreateOpaqueRendererListDesc(CullingResults cull, Camera camera, ShaderTagId passName, PerObjectData rendererConfiguration = PerObjectData.None, RenderQueueRange? renderQueueRange = null, RenderStateBlock? stateBlock = null, Material overrideMaterial = null, bool excludeObjectMotionVectors = false)
		{
			RendererListDesc result = new RendererListDesc(passName, cull, camera);
			result.rendererConfiguration = rendererConfiguration;
			result.renderQueueRange = (renderQueueRange.HasValue ? renderQueueRange.Value : HDRenderQueue.k_RenderQueue_AllOpaque);
			result.sortingCriteria = SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.OptimizeStateChanges | SortingCriteria.CanvasOrder;
			result.stateBlock = stateBlock;
			result.overrideMaterial = overrideMaterial;
			result.excludeObjectMotionVectors = excludeObjectMotionVectors;
			return result;
		}

		private static RendererListDesc CreateOpaqueRendererListDesc(CullingResults cull, Camera camera, ShaderTagId[] passNames, PerObjectData rendererConfiguration = PerObjectData.None, RenderQueueRange? renderQueueRange = null, RenderStateBlock? stateBlock = null, Material overrideMaterial = null, bool excludeObjectMotionVectors = false)
		{
			RendererListDesc result = new RendererListDesc(passNames, cull, camera);
			result.rendererConfiguration = rendererConfiguration;
			result.renderQueueRange = (renderQueueRange.HasValue ? renderQueueRange.Value : HDRenderQueue.k_RenderQueue_AllOpaque);
			result.sortingCriteria = SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.OptimizeStateChanges | SortingCriteria.CanvasOrder;
			result.stateBlock = stateBlock;
			result.overrideMaterial = overrideMaterial;
			result.excludeObjectMotionVectors = excludeObjectMotionVectors;
			return result;
		}

		private static RendererListDesc CreateTransparentRendererListDesc(CullingResults cull, Camera camera, ShaderTagId passName, PerObjectData rendererConfiguration = PerObjectData.None, RenderQueueRange? renderQueueRange = null, RenderStateBlock? stateBlock = null, Material overrideMaterial = null, bool excludeObjectMotionVectors = false)
		{
			RendererListDesc result = new RendererListDesc(passName, cull, camera);
			result.rendererConfiguration = rendererConfiguration;
			result.renderQueueRange = (renderQueueRange.HasValue ? renderQueueRange.Value : HDRenderQueue.k_RenderQueue_AllTransparent);
			result.sortingCriteria = SortingCriteria.CommonTransparent | SortingCriteria.RendererPriority;
			result.stateBlock = stateBlock;
			result.overrideMaterial = overrideMaterial;
			result.excludeObjectMotionVectors = excludeObjectMotionVectors;
			return result;
		}

		private static RendererListDesc CreateTransparentRendererListDesc(CullingResults cull, Camera camera, ShaderTagId[] passNames, PerObjectData rendererConfiguration = PerObjectData.None, RenderQueueRange? renderQueueRange = null, RenderStateBlock? stateBlock = null, Material overrideMaterial = null, bool excludeObjectMotionVectors = false)
		{
			RendererListDesc result = new RendererListDesc(passNames, cull, camera);
			result.rendererConfiguration = rendererConfiguration;
			result.renderQueueRange = (renderQueueRange.HasValue ? renderQueueRange.Value : HDRenderQueue.k_RenderQueue_AllTransparent);
			result.sortingCriteria = SortingCriteria.CommonTransparent | SortingCriteria.RendererPriority;
			result.stateBlock = stateBlock;
			result.overrideMaterial = overrideMaterial;
			result.excludeObjectMotionVectors = excludeObjectMotionVectors;
			return result;
		}

		private static void DrawOpaqueRendererList(in ScriptableRenderContext renderContext, CommandBuffer cmd, in FrameSettings frameSettings, RendererList rendererList)
		{
			if (frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				CoreUtils.DrawRendererList(renderContext, cmd, rendererList);
			}
		}

		private static void DrawTransparentRendererList(in ScriptableRenderContext renderContext, CommandBuffer cmd, in FrameSettings frameSettings, RendererList rendererList)
		{
			if (frameSettings.IsEnabled(FrameSettingsField.TransparentObjects))
			{
				CoreUtils.DrawRendererList(renderContext, cmd, rendererList);
			}
		}

		private void UpdateShaderVariablesGlobalDecal(ref ShaderVariablesGlobal cb, HDCamera hdCamera)
		{
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals))
			{
				cb._EnableDecals = 1u;
				cb._DecalAtlasResolution = new Vector2(HDUtils.hdrpSettings.decalSettings.atlasWidth, HDUtils.hdrpSettings.decalSettings.atlasHeight);
			}
			else
			{
				cb._EnableDecals = 0u;
			}
		}

		private void RenderWireFrame(CullingResults cull, HDCamera hdCamera, RenderTargetIdentifier backbuffer, ScriptableRenderContext renderContext, CommandBuffer cmd)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.RenderWireFrame)))
			{
				CoreUtils.SetRenderTarget(cmd, backbuffer, ClearFlag.Color, GetColorBufferClearColor(hdCamera));
				RenderWaterAsWireFrame(cmd, hdCamera);
				RendererList rendererList = renderContext.CreateRendererList(CreateOpaqueRendererListDesc(cull, hdCamera.camera, m_AllForwardOpaquePassNames));
				FrameSettings frameSettings = hdCamera.frameSettings;
				DrawOpaqueRendererList(in renderContext, cmd, in frameSettings, rendererList);
				RendererList rendererList2 = renderContext.CreateRendererList(CreateTransparentRendererListDesc(cull, hdCamera.camera, m_AllTransparentPassNames));
				frameSettings = hdCamera.frameSettings;
				DrawTransparentRendererList(in renderContext, cmd, in frameSettings, rendererList2);
				renderContext.ExecuteCommandBuffer(cmd);
				cmd.Clear();
			}
		}

		public void RequestSkyEnvironmentUpdate()
		{
			m_SkyManager.RequestEnvironmentUpdate();
		}

		internal void RequestStaticSkyUpdate()
		{
			m_SkyManager.RequestStaticEnvironmentUpdate();
		}

		public Texture2D ExportSkyToTexture(Camera camera)
		{
			return m_SkyManager.ExportSkyToTexture(camera);
		}

		private static bool NeedMotionVectorForTransparent(FrameSettings frameSettings)
		{
			return frameSettings.IsEnabled(FrameSettingsField.MotionVectors);
		}

		public void ReleasePersistentShadowAtlases()
		{
			m_ShadowManager.ReleaseSharedShadowAtlases(m_RenderGraph);
		}

		private void InitializeDebug()
		{
			m_DebugViewMaterialGBuffer = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugViewMaterialGBufferPS);
			m_DebugViewMaterialGBufferShadowMask = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugViewMaterialGBufferPS);
			m_DebugViewMaterialGBufferShadowMask.EnableKeyword("SHADOWS_SHADOWMASK");
			m_DebugDisplayLatlong = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugDisplayLatlongPS);
			m_DebugFullScreen = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugFullScreenPS);
			m_DebugColorPicker = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugColorPickerPS);
			m_DebugExposure = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugExposurePS);
			m_DebugHDROutput = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugHDRPS);
			m_DebugViewTilesMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugViewTilesPS);
			m_DebugHDShadowMapMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugHDShadowMapPS);
			m_DebugLocalVolumetricFogMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugLocalVolumetricFogAtlasPS);
			m_DebugBlitMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugBlitQuad);
			m_DebugWaveform = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugWaveformPS);
			m_DebugVectorscope = CoreUtils.CreateEngineMaterial(defaultResources.shaders.debugVectorscopePS);
			m_ClearFullScreenBufferCS = defaultResources.shaders.clearDebugBufferCS;
			m_ClearFullScreenBufferKernel = m_ClearFullScreenBufferCS.FindKernel("clearMain");
		}

		private void CleanupDebug()
		{
			CoreUtils.Destroy(m_DebugViewMaterialGBuffer);
			CoreUtils.Destroy(m_DebugViewMaterialGBufferShadowMask);
			CoreUtils.Destroy(m_DebugDisplayLatlong);
			CoreUtils.Destroy(m_DebugFullScreen);
			CoreUtils.Destroy(m_DebugColorPicker);
			CoreUtils.Destroy(m_DebugExposure);
			CoreUtils.Destroy(m_DebugHDROutput);
			CoreUtils.Destroy(m_DebugViewTilesMaterial);
			CoreUtils.Destroy(m_DebugHDShadowMapMaterial);
			CoreUtils.Destroy(m_DebugLocalVolumetricFogMaterial);
			CoreUtils.Destroy(m_DebugBlitMaterial);
			CoreUtils.Destroy(m_DebugWaveform);
			CoreUtils.Destroy(m_DebugVectorscope);
		}

		private bool NeedColorPickerDebug(DebugDisplaySettings debugSettings)
		{
			if (debugSettings.data.colorPickerDebugSettings.colorPickerMode == ColorPickerDebugMode.None && !debugSettings.data.falseColorDebugSettings.falseColor)
			{
				return debugSettings.data.lightingDebugSettings.debugLightingMode == DebugLightingMode.LuminanceMeter;
			}
			return true;
		}

		private bool NeedExposureDebugMode(DebugDisplaySettings debugSettings)
		{
			return debugSettings.data.lightingDebugSettings.exposureDebugMode != ExposureDebugMode.None;
		}

		private bool NeedHDRDebugMode(DebugDisplaySettings debugSettings)
		{
			return debugSettings.data.lightingDebugSettings.hdrDebugMode != HDRDebugMode.None;
		}

		private bool NeedsFullScreenDebugMode()
		{
			bool num = m_CurrentDebugDisplaySettings.data.fullScreenDebugMode != FullScreenDebugMode.None;
			bool flag = m_CurrentDebugDisplaySettings.data.lightingDebugSettings.shadowDebugMode == ShadowMapDebugMode.SingleShadow;
			return num || flag;
		}

		private unsafe void ApplyDebugDisplaySettings(HDCamera hdCamera, CommandBuffer cmd, bool aovOutput)
		{
			bool flag = m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled() || CoreUtils.IsSceneLightingDisabled(hdCamera.camera);
			CoreUtils.SetKeyword(cmd, "DEBUG_DISPLAY", flag);
			cmd.SetGlobalTexture(HDShaderIDs._DebugMatCapTexture, defaultResources.textures.matcapTex);
			m_ShaderVariablesGlobalCB._GlobalTessellationFactorMultiplier = ((m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.QuadOverdraw) ? 0f : 1f);
			if (!flag && m_CurrentDebugDisplaySettings.data.colorPickerDebugSettings.colorPickerMode == ColorPickerDebugMode.None && !m_CurrentDebugDisplaySettings.IsDebugExposureModeEnabled())
			{
				return;
			}
			m_CurrentDebugDisplaySettings.UpdateMaterials();
			LightingDebugSettings lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
			MaterialDebugSettings materialDebugSettings = m_CurrentDebugDisplaySettings.data.materialDebugSettings;
			Color linear = lightingDebugSettings.overrideAlbedoValue.linear;
			Color linear2 = lightingDebugSettings.overrideSpecularColorValue.linear;
			Vector4 debugLightingAlbedo = new Vector4(lightingDebugSettings.overrideAlbedo ? 1f : 0f, linear.r, linear.g, linear.b);
			Vector4 debugLightingSmoothness = new Vector4(lightingDebugSettings.overrideSmoothness ? 1f : 0f, lightingDebugSettings.overrideSmoothnessValue, 0f, 0f);
			Vector4 debugLightingNormal = new Vector4(lightingDebugSettings.overrideNormal ? 1f : 0f, 0f, 0f, 0f);
			Vector4 debugLightingAmbientOcclusion = new Vector4(lightingDebugSettings.overrideAmbientOcclusion ? 1f : 0f, lightingDebugSettings.overrideAmbientOcclusionValue, 0f, 0f);
			Vector4 debugLightingSpecularColor = new Vector4(lightingDebugSettings.overrideSpecularColor ? 1f : 0f, linear2.r, linear2.g, linear2.b);
			Vector4 debugLightingEmissiveColor = new Vector4(lightingDebugSettings.overrideEmissiveColor ? 1f : 0f, lightingDebugSettings.overrideEmissiveColorValue.r, lightingDebugSettings.overrideEmissiveColorValue.g, lightingDebugSettings.overrideEmissiveColorValue.b);
			Vector4 debugLightingMaterialValidatePureMetalColor = new Vector4(materialDebugSettings.materialValidateTrueMetal ? 1f : 0f, materialDebugSettings.materialValidateTrueMetalColor.r, materialDebugSettings.materialValidateTrueMetalColor.g, materialDebugSettings.materialValidateTrueMetalColor.b);
			DebugLightingMode debugLightingMode = m_CurrentDebugDisplaySettings.GetDebugLightingMode();
			if (CoreUtils.IsSceneLightingDisabled(hdCamera.camera))
			{
				debugLightingMode = DebugLightingMode.MatcapView;
			}
			ref ShaderVariablesDebugDisplay shaderVariablesDebugDisplayCB = ref m_ShaderVariablesDebugDisplayCB;
			float[] debugMaterialIndexes = m_CurrentDebugDisplaySettings.GetDebugMaterialIndexes();
			for (int i = 0; i < 11; i++)
			{
				shaderVariablesDebugDisplayCB._DebugViewMaterialArray[i * 4] = (uint)debugMaterialIndexes[i];
			}
			for (int j = 0; j < 32; j++)
			{
				for (int k = 0; k < 4; k++)
				{
					shaderVariablesDebugDisplayCB._DebugRenderingLayersColors[j * 4 + k] = m_CurrentDebugDisplaySettings.data.lightingDebugSettings.debugRenderingLayersColors[j][k];
				}
			}
			if (IsAPVEnabled())
			{
				Color[] subdivisionDebugColors = ProbeReferenceVolume.instance.subdivisionDebugColors;
				for (int l = 0; l < 7; l++)
				{
					for (int m = 0; m < 4; m++)
					{
						shaderVariablesDebugDisplayCB._DebugAPVSubdivColors[l * 4 + m] = subdivisionDebugColors[l][m];
					}
				}
			}
			shaderVariablesDebugDisplayCB._DebugLightingMode = (int)debugLightingMode;
			shaderVariablesDebugDisplayCB._DebugLightLayersMask = (int)m_CurrentDebugDisplaySettings.GetDebugLightLayersMask();
			shaderVariablesDebugDisplayCB._DebugShadowMapMode = (int)m_CurrentDebugDisplaySettings.GetDebugShadowMapMode();
			shaderVariablesDebugDisplayCB._DebugMipMapMode = (int)m_CurrentDebugDisplaySettings.GetDebugMipMapMode();
			shaderVariablesDebugDisplayCB._DebugIsLitShaderModeDeferred = ((hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred) ? 1 : 0);
			shaderVariablesDebugDisplayCB._DebugMipMapModeTerrainTexture = (int)m_CurrentDebugDisplaySettings.GetDebugMipMapModeTerrainTexture();
			shaderVariablesDebugDisplayCB._ColorPickerMode = (int)m_CurrentDebugDisplaySettings.GetDebugColorPickerMode();
			shaderVariablesDebugDisplayCB._DebugFullScreenMode = (int)m_CurrentDebugDisplaySettings.data.fullScreenDebugMode;
			shaderVariablesDebugDisplayCB._MatcapMixAlbedo = 0;
			shaderVariablesDebugDisplayCB._MatcapViewScale = 1f;
			shaderVariablesDebugDisplayCB._DebugViewportSize = hdCamera.screenSize;
			shaderVariablesDebugDisplayCB._DebugLightingAlbedo = debugLightingAlbedo;
			shaderVariablesDebugDisplayCB._DebugLightingSmoothness = debugLightingSmoothness;
			shaderVariablesDebugDisplayCB._DebugLightingNormal = debugLightingNormal;
			shaderVariablesDebugDisplayCB._DebugLightingAmbientOcclusion = debugLightingAmbientOcclusion;
			shaderVariablesDebugDisplayCB._DebugLightingSpecularColor = debugLightingSpecularColor;
			shaderVariablesDebugDisplayCB._DebugLightingEmissiveColor = debugLightingEmissiveColor;
			shaderVariablesDebugDisplayCB._DebugLightingMaterialValidateHighColor = materialDebugSettings.materialValidateHighColor;
			shaderVariablesDebugDisplayCB._DebugLightingMaterialValidateLowColor = materialDebugSettings.materialValidateLowColor;
			shaderVariablesDebugDisplayCB._DebugLightingMaterialValidatePureMetalColor = debugLightingMaterialValidatePureMetalColor;
			shaderVariablesDebugDisplayCB._MousePixelCoord = HDUtils.GetMouseCoordinates(hdCamera);
			shaderVariablesDebugDisplayCB._MouseClickPixelCoord = HDUtils.GetMouseClickCoordinates(hdCamera);
			shaderVariablesDebugDisplayCB._DebugSingleShadowIndex = (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.shadowDebugUseSelection ? m_DebugSelectedLightShadowIndex : ((int)m_CurrentDebugDisplaySettings.data.lightingDebugSettings.shadowMapIndex));
			shaderVariablesDebugDisplayCB._DebugAOVOutput = (aovOutput ? 1 : 0);
			ConstantBuffer.PushGlobal(cmd, in m_ShaderVariablesDebugDisplayCB, HDShaderIDs._ShaderVariablesDebugDisplay);
			cmd.SetGlobalTexture(HDShaderIDs._DebugFont, defaultResources.textures.debugFontTex);
		}

		private void RenderMonitorsOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, HDCamera hdCamera)
		{
			MonitorsDebugSettings monitorsDebugSettings = m_CurrentDebugDisplaySettings.data.monitorsDebugSettings;
			if (!monitorsDebugSettings.vectorscopeToggle && !monitorsDebugSettings.waveformToggle)
			{
				return;
			}
			MonitorsPassData passData2;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<MonitorsPassData>("Monitors overlay", out passData2);
			try
			{
				passData2.runtimeDebugPannelWidth = HDUtils.GetRuntimeDebugPanelWidth(hdCamera);
				passData2.blitMaterial = m_DebugBlitMaterial;
				passData2.sizeRatio = monitorsDebugSettings.monitorsSize;
				passData2.colorTexture = builder.ReadWriteTexture(in colorBuffer);
				passData2.settings = m_CurrentDebugDisplaySettings.data.monitorsDebugSettings;
				passData2.inputSize = new Vector2Int(hdCamera.actualWidth, hdCamera.actualHeight);
				passData2.downsampledSize = new Vector2Int(hdCamera.actualWidth / 2, hdCamera.actualHeight / 2);
				MonitorsPassData monitorsPassData = passData2;
				TextureDesc desc = new TextureDesc(passData2.downsampledSize.x, passData2.downsampledSize.y)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_UNorm,
					name = "Downsampled color buffer"
				};
				monitorsPassData.downsampledInput = builder.CreateTransientTexture(in desc);
				FillWaveformData(passData2, builder);
				FillVectorscopeData(passData2, (int)((float)hdCamera.actualHeight * passData2.sizeRatio), builder);
				builder.SetRenderFunc(delegate(MonitorsPassData passData, RenderGraphContext ctx)
				{
					HDUtils.BlitCameraTexture(ctx.cmd, passData.colorTexture, passData.downsampledInput, 0f, bilinear: true);
					if (passData.settings.waveformToggle)
					{
						RenderWaveformDebug(passData, ctx);
					}
					if (passData.settings.vectorscopeToggle)
					{
						RenderVectorScopeDebug(passData, ctx);
					}
					int num = passData.runtimeDebugPannelWidth + 5;
					if (passData.settings.vectorscopeToggle)
					{
						ctx.cmd.SetGlobalTexture(HDShaderIDs._InputTexture, passData.vectorscopeTexture);
						ctx.cmd.SetRenderTarget(passData.colorTexture);
						ctx.cmd.SetViewport(new Rect(num, 5f, passData.vectorscopeSize.x, passData.vectorscopeSize.y));
						ctx.cmd.DrawProcedural(Matrix4x4.identity, passData.blitMaterial, 0, MeshTopology.Triangles, 3, 1, null);
						num += passData.vectorscopeSize.x + 5;
					}
					if (passData.settings.waveformToggle)
					{
						ctx.cmd.SetGlobalTexture(HDShaderIDs._InputTexture, passData.waveformTexture);
						ctx.cmd.SetRenderTarget(passData.colorTexture);
						ctx.cmd.SetViewport(new Rect(num, 5f, (float)passData.inputSize.x * passData.sizeRatio, (float)passData.inputSize.y * passData.sizeRatio));
						ctx.cmd.DrawProcedural(Matrix4x4.identity, passData.blitMaterial, 0, MeshTopology.Triangles, 3, 1, null);
					}
				});
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private void FillWaveformData(MonitorsPassData data, RenderGraphBuilder builder)
		{
			data.waveformCS = defaultResources.shaders.debugWaveformCS;
			data.waveformMaterial = m_DebugWaveform;
			data.waveformClearKernel = data.waveformCS.FindKernel("KWaveformClear");
			data.waveformGatherKernel = data.waveformCS.FindKernel("KWaveformGather");
			ComputeBufferDesc desc = new ComputeBufferDesc(data.downsampledSize.x * data.downsampledSize.y, 16)
			{
				name = "Waveform Debug Buffer"
			};
			data.waveformBuffer = builder.CreateTransientComputeBuffer(in desc);
			TextureDesc desc2 = new TextureDesc(data.downsampledSize.x, data.downsampledSize.y)
			{
				enableRandomWrite = true,
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				name = "Waveform Debug Texture"
			};
			data.waveformTexture = builder.CreateTransientTexture(in desc2);
		}

		private void FillVectorscopeData(MonitorsPassData data, int size, RenderGraphBuilder builder)
		{
			data.vectorscopeCS = defaultResources.shaders.debugVectorscopeCS;
			data.vectorscopeSize = new Vector2Int(size, size);
			data.vectorscopeMaterial = m_DebugVectorscope;
			data.vectorscopeBufferSize = data.vectorscopeSize.x * data.vectorscopeSize.x;
			data.vectorscopeClearKernel = data.vectorscopeCS.FindKernel("KVectorscopeClear");
			data.vectorscopeGatherKernel = data.vectorscopeCS.FindKernel("KVectorscopeGather");
			TextureDesc desc = new TextureDesc(data.vectorscopeSize.x, data.vectorscopeSize.y)
			{
				enableRandomWrite = true,
				colorFormat = GetColorBufferFormat(),
				name = "Vectorscope Debug Texture"
			};
			data.vectorscopeTexture = builder.CreateTransientTexture(in desc);
			ComputeBufferDesc desc2 = new ComputeBufferDesc(data.vectorscopeBufferSize, 16)
			{
				name = "Vectorscope Debug Buffer"
			};
			data.vectorscopeBuffer = builder.CreateTransientComputeBuffer(in desc2);
		}

		private static void RenderVectorScopeDebug(MonitorsPassData data, RenderGraphContext ctx)
		{
			Vector4 value = new Vector4(data.vectorscopeSize.x, data.vectorscopeSize.y, data.settings.vectorscopeExposure);
			ctx.cmd.SetComputeBufferParam(data.vectorscopeCS, data.vectorscopeClearKernel, HDShaderIDs._VectorscopeBuffer, data.vectorscopeBuffer);
			ctx.cmd.SetComputeIntParam(data.vectorscopeCS, HDShaderIDs._BufferSize, data.vectorscopeSize.x);
			ctx.cmd.DispatchCompute(data.vectorscopeCS, data.vectorscopeClearKernel, Mathf.CeilToInt((float)data.vectorscopeSize.x / 16f), Mathf.CeilToInt((float)data.vectorscopeSize.y / 16f), 1);
			ctx.cmd.SetComputeBufferParam(data.vectorscopeCS, data.vectorscopeGatherKernel, HDShaderIDs._VectorscopeBuffer, data.vectorscopeBuffer);
			ctx.cmd.SetComputeTextureParam(data.vectorscopeCS, data.vectorscopeGatherKernel, HDShaderIDs._Source, data.downsampledInput);
			ctx.cmd.DispatchCompute(data.vectorscopeCS, data.vectorscopeGatherKernel, Mathf.CeilToInt((float)data.downsampledSize.x / 16f), Mathf.CeilToInt((float)data.downsampledSize.y / 16f), 1);
			data.vectorscopeMaterial.SetBuffer(HDShaderIDs._VectorscopeBuffer, data.vectorscopeBuffer);
			data.vectorscopeMaterial.SetVector(HDShaderIDs._VectorscopeParameters, value);
			ctx.cmd.SetRenderTarget(data.vectorscopeTexture);
			ctx.cmd.DrawProcedural(Matrix4x4.identity, data.vectorscopeMaterial, 0, MeshTopology.Triangles, 3, 1, null);
		}

		private static void RenderWaveformDebug(MonitorsPassData data, RenderGraphContext ctx)
		{
			Vector4 vector = new Vector4(data.downsampledSize.x, data.downsampledSize.y, data.settings.waveformExposure, data.settings.waveformParade ? 1f : 0f);
			ctx.cmd.SetComputeBufferParam(data.waveformCS, data.waveformClearKernel, HDShaderIDs._WaveformBuffer, data.waveformBuffer);
			ctx.cmd.SetComputeVectorParam(data.waveformCS, HDShaderIDs._Params, vector);
			ctx.cmd.DispatchCompute(data.waveformCS, data.waveformClearKernel, Mathf.CeilToInt((float)data.downsampledSize.x / 16f), Mathf.CeilToInt((float)data.downsampledSize.y / 16f), 1);
			ctx.cmd.SetComputeTextureParam(data.waveformCS, data.waveformGatherKernel, HDShaderIDs._Source, data.downsampledInput);
			ctx.cmd.SetComputeBufferParam(data.waveformCS, data.waveformGatherKernel, HDShaderIDs._WaveformBuffer, data.waveformBuffer);
			ctx.cmd.DispatchCompute(data.waveformCS, data.waveformGatherKernel, Mathf.CeilToInt((float)data.downsampledSize.x / 16f), Mathf.CeilToInt((float)data.downsampledSize.y / 16f), 1);
			data.waveformMaterial.SetBuffer(HDShaderIDs._WaveformBuffer, data.waveformBuffer);
			data.waveformMaterial.SetVector(HDShaderIDs._WaveformParameters, vector);
			ctx.cmd.SetRenderTarget(data.waveformTexture);
			ctx.cmd.DrawProcedural(Matrix4x4.identity, data.waveformMaterial, 0, MeshTopology.Triangles, 3, 1, null);
		}

		private void RenderTransparencyOverdraw(RenderGraph renderGraph, TextureHandle depthBuffer, CullingResults cull, HDCamera hdCamera)
		{
			if (!m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled() || m_CurrentDebugDisplaySettings.data.fullScreenDebugMode != FullScreenDebugMode.TransparencyOverdraw)
			{
				return;
			}
			TextureHandle input = TextureHandle.nullHandle;
			TransparencyOverdrawPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TransparencyOverdrawPassData>("Transparency Overdraw", out passData);
			try
			{
				ShaderTagId[] passNames = (m_Asset.currentPlatformRenderPipelineSettings.supportTransparentBackface ? m_AllTransparentPassNames : m_TransparentNoBackfaceNames);
				RenderStateBlock renderStateBlock = default(RenderStateBlock);
				renderStateBlock.mask = RenderStateMask.Blend;
				renderStateBlock.blendState = new BlendState
				{
					blendState0 = new RenderTargetBlendState
					{
						destinationColorBlendMode = BlendMode.One,
						sourceColorBlendMode = BlendMode.One,
						destinationAlphaBlendMode = BlendMode.One,
						sourceAlphaBlendMode = BlendMode.One,
						colorBlendOperation = BlendOp.Add,
						alphaBlendOperation = BlendOp.Add,
						writeMask = ColorWriteMask.All
					}
				};
				RenderStateBlock value = renderStateBlock;
				passData.frameSettings = hdCamera.frameSettings;
				passData.constantBuffer = m_ShaderVariablesDebugDisplayCB;
				renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				TransparencyOverdrawPassData transparencyOverdrawPassData = passData;
				Camera camera = hdCamera.camera;
				RenderStateBlock? stateBlock = value;
				RendererListDesc desc = CreateTransparentRendererListDesc(cull, camera, passNames, PerObjectData.None, null, stateBlock);
				RendererListHandle input2 = renderGraph.CreateRendererList(in desc);
				transparencyOverdrawPassData.transparencyRL = renderGraphBuilder.UseRendererList(in input2);
				TransparencyOverdrawPassData transparencyOverdrawPassData2 = passData;
				desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, passNames, PerObjectData.None, HDRenderQueue.k_RenderQueue_AfterPostProcessTransparent, value);
				input2 = renderGraph.CreateRendererList(in desc);
				transparencyOverdrawPassData2.transparencyAfterPostRL = renderGraphBuilder.UseRendererList(in input2);
				TransparencyOverdrawPassData transparencyOverdrawPassData3 = passData;
				desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, passNames, PerObjectData.None, HDRenderQueue.k_RenderQueue_LowTransparent, value);
				input2 = renderGraph.CreateRendererList(in desc);
				transparencyOverdrawPassData3.transparencyLowResRL = renderGraphBuilder.UseRendererList(in input2);
				TextureDesc desc2 = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					name = "Transparency Overdraw",
					colorFormat = GetColorBufferFormat(),
					clearBuffer = true,
					clearColor = Color.black
				};
				TextureHandle input3 = renderGraph.CreateTexture(in desc2);
				input = renderGraphBuilder.UseColorBuffer(in input3, 0);
				renderGraphBuilder.SetRenderFunc(delegate(TransparencyOverdrawPassData data, RenderGraphContext ctx)
				{
					data.constantBuffer._DebugTransparencyOverdrawWeight = 1f;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.constantBuffer, HDShaderIDs._ShaderVariablesDebugDisplay);
					DrawTransparentRendererList(in ctx.renderContext, ctx.cmd, in data.frameSettings, data.transparencyRL);
					DrawTransparentRendererList(in ctx.renderContext, ctx.cmd, in data.frameSettings, data.transparencyAfterPostRL);
					data.constantBuffer._DebugTransparencyOverdrawWeight = 0.25f;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.constantBuffer, HDShaderIDs._ShaderVariablesDebugDisplay);
					DrawTransparentRendererList(in ctx.renderContext, ctx.cmd, in data.frameSettings, data.transparencyLowResRL);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			PushFullScreenDebugTexture(renderGraph, input, FullScreenDebugMode.TransparencyOverdraw);
		}

		private void RenderFullScreenDebug(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, CullingResults cull, HDCamera hdCamera)
		{
			FullScreenDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<FullScreenDebugPassData>("FullScreen Debug", out passData);
			try
			{
				renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
				renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				ComputeBufferDesc desc = new ComputeBufferDesc(hdCamera.actualWidth * hdCamera.actualHeight * hdCamera.viewCount, 4);
				m_DebugFullScreenComputeBuffer = renderGraph.CreateComputeBuffer(in desc);
				passData.frameSettings = hdCamera.frameSettings;
				passData.debugBuffer = renderGraphBuilder.WriteComputeBuffer(in m_DebugFullScreenComputeBuffer);
				FullScreenDebugPassData fullScreenDebugPassData = passData;
				RendererListDesc desc2 = CreateOpaqueRendererListDesc(cull, hdCamera.camera, m_FullScreenDebugPassNames, PerObjectData.None, RenderQueueRange.all);
				RendererListHandle input = renderGraph.CreateRendererList(in desc2);
				fullScreenDebugPassData.rendererList = renderGraphBuilder.UseRendererList(in input);
				passData.clearBufferCS = m_ClearFullScreenBufferCS;
				passData.clearBufferCSKernel = m_ClearFullScreenBufferKernel;
				passData.width = hdCamera.actualWidth;
				passData.height = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				renderGraphBuilder.SetRenderFunc(delegate(FullScreenDebugPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeVectorParam(data.clearBufferCS, HDShaderIDs._QuadOverdrawClearBuffParams, new Vector4(data.width, data.height, 0f, 0f));
					ctx.cmd.SetComputeBufferParam(data.clearBufferCS, data.clearBufferCSKernel, HDShaderIDs._FullScreenDebugBuffer, data.debugBuffer);
					ctx.cmd.DispatchCompute(data.clearBufferCS, data.clearBufferCSKernel, HDUtils.DivRoundUp(data.width, 16), HDUtils.DivRoundUp(data.height, 16), data.viewCount);
					ctx.cmd.SetRandomWriteTarget(1, data.debugBuffer);
					CoreUtils.DrawRendererList(ctx.renderContext, ctx.cmd, data.rendererList);
					ctx.cmd.ClearRandomWriteTargets();
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			PushFullScreenDebugTexture(renderGraph, ResolveMSAAColor(renderGraph, hdCamera, colorBuffer));
		}

		private TextureHandle ResolveFullScreenDebug(RenderGraph renderGraph, TextureHandle inputFullScreenDebug, TextureHandle depthPyramid, HDCamera hdCamera, GraphicsFormat rtFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			ResolveFullScreenDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolveFullScreenDebugPassData>("ResolveFullScreenDebug", out passData);
			try
			{
				passData.hdCamera = hdCamera;
				passData.debugDisplaySettings = m_CurrentDebugDisplaySettings;
				passData.debugFullScreenMaterial = m_DebugFullScreen;
				passData.input = renderGraphBuilder.ReadTexture(in inputFullScreenDebug);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.depthPyramidMip = (int)(m_CurrentDebugDisplaySettings.data.fullscreenDebugMip * (float)hdCamera.depthBufferMipChainInfo.mipLevelCount);
				passData.depthPyramidOffsets = hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer);
				if (m_DebugFullScreenComputeBuffer.IsValid())
				{
					passData.fullscreenBuffer = renderGraphBuilder.ReadComputeBuffer(in m_DebugFullScreenComputeBuffer);
				}
				else
				{
					ResolveFullScreenDebugPassData resolveFullScreenDebugPassData = passData;
					ComputeBufferDesc desc = new ComputeBufferDesc(4, 4);
					resolveFullScreenDebugPassData.fullscreenBuffer = renderGraphBuilder.CreateTransientComputeBuffer(in desc);
				}
				ResolveFullScreenDebugPassData resolveFullScreenDebugPassData2 = passData;
				TextureDesc desc2 = new TextureDesc(Vector2.one, dynamicResolution: false, xrReady: true)
				{
					colorFormat = rtFormat,
					name = "ResolveFullScreenDebug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc2);
				resolveFullScreenDebugPassData2.output = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ResolveFullScreenDebugPassData data, RenderGraphContext ctx)
				{
					MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
					ComputeVolumetricFogSliceCountAndScreenFraction(data.hdCamera.volumeStack.GetComponent<Fog>(), out var sliceCount, out var _);
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._DebugFullScreenTexture, data.input);
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._CameraDepthTexture, data.depthPyramid);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._FullScreenDebugMode, (float)data.debugDisplaySettings.data.fullScreenDebugMode);
					if (data.debugDisplaySettings.data.enableDebugDepthRemap)
					{
						tempMaterialPropertyBlock.SetVector(HDShaderIDs._FullScreenDebugDepthRemap, new Vector4(data.debugDisplaySettings.data.fullScreenDebugDepthRemap.x, data.debugDisplaySettings.data.fullScreenDebugDepthRemap.y, data.hdCamera.camera.nearClipPlane, data.hdCamera.camera.farClipPlane));
					}
					else
					{
						tempMaterialPropertyBlock.SetVector(HDShaderIDs._FullScreenDebugDepthRemap, new Vector4(0f, 1f, 0f, 1f));
					}
					tempMaterialPropertyBlock.SetInt(HDShaderIDs._DebugDepthPyramidMip, data.depthPyramidMip);
					tempMaterialPropertyBlock.SetBuffer(HDShaderIDs._DebugDepthPyramidOffsets, data.depthPyramidOffsets);
					tempMaterialPropertyBlock.SetInt(HDShaderIDs._DebugContactShadowLightIndex, data.debugDisplaySettings.data.fullScreenContactShadowLightIndex);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._TransparencyOverdrawMaxPixelCost, data.debugDisplaySettings.data.transparencyDebugSettings.maxPixelCost);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._FogVolumeOverdrawMaxValue, sliceCount);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._QuadOverdrawMaxQuadCost, data.debugDisplaySettings.data.maxQuadCost);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._VertexDensityMaxPixelCost, data.debugDisplaySettings.data.maxVertexDensity);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._MinMotionVector, data.debugDisplaySettings.data.minMotionVectorLength);
					ctx.cmd.SetRandomWriteTarget(1, data.fullscreenBuffer);
					HDUtils.DrawFullScreen(ctx.cmd, data.debugFullScreenMaterial, data.output, tempMaterialPropertyBlock);
					ctx.cmd.ClearRandomWriteTargets();
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle ResolveColorPickerDebug(RenderGraph renderGraph, TextureHandle inputColorPickerDebug, HDCamera hdCamera, GraphicsFormat rtFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			ResolveColorPickerDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolveColorPickerDebugPassData>("ResolveColorPickerDebug", out passData);
			try
			{
				passData.hdCamera = hdCamera;
				passData.debugDisplaySettings = m_CurrentDebugDisplaySettings;
				passData.colorPickerMaterial = m_DebugColorPicker;
				passData.input = renderGraphBuilder.ReadTexture(in inputColorPickerDebug);
				ResolveColorPickerDebugPassData resolveColorPickerDebugPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = rtFormat,
					name = "ResolveColorPickerDebug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				resolveColorPickerDebugPassData.output = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ResolveColorPickerDebugPassData data, RenderGraphContext ctx)
				{
					FalseColorDebugSettings falseColorDebugSettings = data.debugDisplaySettings.data.falseColorDebugSettings;
					ColorPickerDebugSettings colorPickerDebugSettings = data.debugDisplaySettings.data.colorPickerDebugSettings;
					Vector4 value = new Vector4(falseColorDebugSettings.colorThreshold0, falseColorDebugSettings.colorThreshold1, falseColorDebugSettings.colorThreshold2, falseColorDebugSettings.colorThreshold3);
					data.colorPickerMaterial.SetTexture(HDShaderIDs._DebugColorPickerTexture, data.input);
					data.colorPickerMaterial.SetColor(HDShaderIDs._ColorPickerFontColor, colorPickerDebugSettings.fontColor);
					data.colorPickerMaterial.SetInt(HDShaderIDs._FalseColorEnabled, falseColorDebugSettings.falseColor ? 1 : 0);
					data.colorPickerMaterial.SetVector(HDShaderIDs._FalseColorThresholds, value);
					data.colorPickerMaterial.SetVector(HDShaderIDs._MousePixelCoord, HDUtils.GetMouseCoordinates(data.hdCamera));
					data.colorPickerMaterial.SetVector(HDShaderIDs._MouseClickPixelCoord, HDUtils.GetMouseClickCoordinates(data.hdCamera));
					data.colorPickerMaterial.SetFloat(HDShaderIDs._ApplyLinearToSRGB, data.debugDisplaySettings.IsDebugMaterialDisplayEnabled() ? 1f : 0f);
					HDUtils.DrawFullScreen(ctx.cmd, data.colorPickerMaterial, data.output);
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderSkyReflectionOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, HDCamera hdCamera)
		{
			if (!m_CurrentDebugDisplaySettings.data.lightingDebugSettings.displaySkyReflection)
			{
				return;
			}
			SkyReflectionOverlayPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SkyReflectionOverlayPassData>("SkyReflectionOverlay", out passData);
			passData.debugOverlay = m_DebugOverlay;
			passData.colorBuffer = renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
			passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
			passData.lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
			passData.skyReflectionTexture = m_SkyManager.GetSkyReflection(hdCamera);
			passData.debugLatlongMaterial = m_DebugDisplayLatlong;
			renderGraphBuilder.SetRenderFunc(delegate(SkyReflectionOverlayPassData data, RenderGraphContext ctx)
			{
				MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				ctx.cmd.SetViewport(data.debugOverlay.Next());
				tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputCubemap, data.skyReflectionTexture);
				tempMaterialPropertyBlock.SetFloat(HDShaderIDs._Mipmap, data.lightingDebugSettings.skyReflectionMipmap);
				tempMaterialPropertyBlock.SetFloat(HDShaderIDs._ApplyExposure, 1f);
				tempMaterialPropertyBlock.SetFloat(HDShaderIDs._SliceIndex, data.lightingDebugSettings.cubeArraySliceIndex);
				ctx.cmd.DrawProcedural(Matrix4x4.identity, data.debugLatlongMaterial, 0, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock);
			});
		}

		private void RenderRayCountOverlay(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthBuffer, TextureHandle rayCountTexture)
		{
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
			{
				m_RayCountManager.EvaluateRayCount(renderGraph, hdCamera, colorBuffer, depthBuffer, rayCountTexture);
			}
		}

		private void RenderAtlasDebugOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, Texture atlas, int slice, int mipLevel, bool applyExposure, string passName, HDProfileId profileID)
		{
			RenderAtlasDebugOverlayPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderAtlasDebugOverlayPassData>(passName, out passData, ProfilingSampler.Get(profileID));
			passData.debugOverlay = m_DebugOverlay;
			passData.colorBuffer = renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
			passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
			passData.debugBlitMaterial = m_DebugBlitMaterial;
			passData.mipLevel = mipLevel;
			passData.atlasTexture = atlas;
			renderGraphBuilder.SetRenderFunc(delegate(RenderAtlasDebugOverlayPassData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetViewport(data.debugOverlay.Next((float)data.atlasTexture.width / (float)data.atlasTexture.height));
				MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				tempMaterialPropertyBlock.SetFloat(HDShaderIDs._ApplyExposure, applyExposure ? 1f : 0f);
				tempMaterialPropertyBlock.SetFloat(HDShaderIDs._Mipmap, data.mipLevel);
				int shaderPass;
				if (data.atlasTexture.dimension == TextureDimension.Tex2D)
				{
					shaderPass = 0;
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputTexture, data.atlasTexture);
				}
				else
				{
					shaderPass = 1;
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputTextureArray, data.atlasTexture);
					tempMaterialPropertyBlock.SetInt(HDShaderIDs._ArrayIndex, slice);
				}
				ctx.cmd.DrawProcedural(Matrix4x4.identity, data.debugBlitMaterial, shaderPass, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock);
			});
		}

		private void RenderTileClusterDebugOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, in BuildGPULightListOutput lightLists, TextureHandle depthPyramidTexture, HDCamera hdCamera)
		{
			if (!lightLists.tileList.IsValid() || m_CurrentDebugDisplaySettings.data.lightingDebugSettings.tileClusterDebug == TileClusterDebug.None)
			{
				return;
			}
			RenderTileClusterDebugOverlayPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderTileClusterDebugOverlayPassData>("RenderTileAndClusterDebugOverlay", out passData, ProfilingSampler.Get(HDProfileId.TileClusterLightingDebug));
			passData.hdCamera = hdCamera;
			passData.debugOverlay = m_DebugOverlay;
			passData.colorBuffer = renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
			passData.depthPyramidTexture = renderGraphBuilder.ReadTexture(in depthPyramidTexture);
			passData.tileList = renderGraphBuilder.ReadComputeBuffer(in lightLists.tileList);
			passData.lightList = renderGraphBuilder.ReadComputeBuffer(in lightLists.lightList);
			passData.perVoxelLightList = renderGraphBuilder.ReadComputeBuffer(in lightLists.perVoxelLightLists);
			passData.dispatchIndirect = renderGraphBuilder.ReadComputeBuffer(in lightLists.dispatchIndirectBuffer);
			passData.debugViewTilesMaterial = m_DebugViewTilesMaterial;
			passData.lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
			passData.lightingViewportSize = new Vector4(hdCamera.actualWidth, hdCamera.actualHeight, 1f / (float)hdCamera.actualWidth, 1f / (float)hdCamera.actualHeight);
			renderGraphBuilder.SetRenderFunc(delegate(RenderTileClusterDebugOverlayPassData data, RenderGraphContext ctx)
			{
				int actualWidth = data.hdCamera.actualWidth;
				int actualHeight = data.hdCamera.actualHeight;
				int num = (actualWidth + 15) / 16;
				int num2 = (actualHeight + 15) / 16;
				int num3 = num * num2;
				LightingDebugSettings lightingDebugSettings = data.lightingDebugSettings;
				if (lightingDebugSettings.tileClusterDebug == TileClusterDebug.MaterialFeatureVariants)
				{
					if (GetFeatureVariantsEnabled(data.hdCamera.frameSettings))
					{
						data.debugViewTilesMaterial.SetInt(HDShaderIDs._NumTiles, num3);
						data.debugViewTilesMaterial.SetInt(HDShaderIDs._ViewTilesFlags, (int)lightingDebugSettings.tileClusterDebugByCategory);
						data.debugViewTilesMaterial.SetVector(HDShaderIDs._MousePixelCoord, HDUtils.GetMouseCoordinates(data.hdCamera));
						data.debugViewTilesMaterial.SetVector(HDShaderIDs._MouseClickPixelCoord, HDUtils.GetMouseClickCoordinates(data.hdCamera));
						data.debugViewTilesMaterial.SetVector(HDShaderIDs._ClusterDebugLightViewportSize, data.lightingViewportSize);
						data.debugViewTilesMaterial.SetBuffer(HDShaderIDs.g_TileList, data.tileList);
						data.debugViewTilesMaterial.SetBuffer(HDShaderIDs.g_DispatchIndirectBuffer, data.dispatchIndirect);
						CoreUtils.SetKeyword(ctx.cmd, "USE_FPTL_LIGHTLIST", state: true);
						CoreUtils.SetKeyword(ctx.cmd, "USE_CLUSTERED_LIGHTLIST", state: false);
						data.debugViewTilesMaterial.DisableKeyword("SHOW_LIGHT_CATEGORIES");
						data.debugViewTilesMaterial.EnableKeyword("SHOW_FEATURE_VARIANTS");
						if (DeferredUseComputeAsPixel(data.hdCamera.frameSettings))
						{
							data.debugViewTilesMaterial.EnableKeyword("IS_DRAWPROCEDURALINDIRECT");
						}
						else
						{
							data.debugViewTilesMaterial.DisableKeyword("IS_DRAWPROCEDURALINDIRECT");
						}
						ctx.cmd.DrawProcedural(Matrix4x4.identity, data.debugViewTilesMaterial, 0, MeshTopology.Triangles, num3 * 6);
					}
				}
				else
				{
					bool flag = lightingDebugSettings.tileClusterDebug == TileClusterDebug.Cluster;
					data.debugViewTilesMaterial.SetInt(HDShaderIDs._ViewTilesFlags, (int)lightingDebugSettings.tileClusterDebugByCategory);
					data.debugViewTilesMaterial.SetInt(HDShaderIDs._ClusterDebugMode, (int)(flag ? lightingDebugSettings.clusterDebugMode : ClusterDebugMode.VisualizeOpaque));
					data.debugViewTilesMaterial.SetFloat(HDShaderIDs._ClusterDebugDistance, lightingDebugSettings.clusterDebugDistance);
					data.debugViewTilesMaterial.SetVector(HDShaderIDs._ClusterDebugLightViewportSize, data.lightingViewportSize);
					data.debugViewTilesMaterial.SetVector(HDShaderIDs._MousePixelCoord, HDUtils.GetMouseCoordinates(data.hdCamera));
					data.debugViewTilesMaterial.SetVector(HDShaderIDs._MouseClickPixelCoord, HDUtils.GetMouseClickCoordinates(data.hdCamera));
					data.debugViewTilesMaterial.SetBuffer(HDShaderIDs.g_vLightListTile, data.lightList);
					data.debugViewTilesMaterial.SetBuffer(HDShaderIDs.g_vLightListCluster, data.perVoxelLightList);
					data.debugViewTilesMaterial.SetTexture(HDShaderIDs._CameraDepthTexture, data.depthPyramidTexture);
					CoreUtils.SetKeyword(ctx.cmd, "USE_FPTL_LIGHTLIST", !flag);
					CoreUtils.SetKeyword(ctx.cmd, "USE_CLUSTERED_LIGHTLIST", flag);
					data.debugViewTilesMaterial.EnableKeyword("SHOW_LIGHT_CATEGORIES");
					data.debugViewTilesMaterial.DisableKeyword("SHOW_FEATURE_VARIANTS");
					if (!flag && data.hdCamera.msaaEnabled)
					{
						data.debugViewTilesMaterial.EnableKeyword("DISABLE_TILE_MODE");
					}
					else
					{
						data.debugViewTilesMaterial.DisableKeyword("DISABLE_TILE_MODE");
					}
					HDUtils.DrawFullScreen(ctx.cmd, data.debugViewTilesMaterial, data.colorBuffer);
				}
			});
		}

		private void RenderShadowsDebugOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, in ShadowResult shadowResult)
		{
			if (currentAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.maxShadowRequests == 0 || m_CurrentDebugDisplaySettings.data.lightingDebugSettings.shadowDebugMode == ShadowMapDebugMode.None)
			{
				return;
			}
			RenderShadowsDebugOverlayPassData passData;
			using RenderGraphBuilder builder = renderGraph.AddRenderPass<RenderShadowsDebugOverlayPassData>("RenderShadowsDebugOverlay", out passData, ProfilingSampler.Get(HDProfileId.DisplayShadows));
			passData.debugOverlay = m_DebugOverlay;
			passData.colorBuffer = builder.UseColorBuffer(in colorBuffer, 0);
			passData.depthBuffer = builder.UseDepthBuffer(in depthBuffer, DepthAccess.Write);
			passData.lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
			passData.shadowTextures = HDShadowManager.ReadShadowResult(in shadowResult, builder);
			passData.shadowManager = m_ShadowManager;
			passData.debugSelectedLightShadowIndex = m_DebugSelectedLightShadowIndex;
			passData.debugSelectedLightShadowCount = m_DebugSelectedLightShadowCount;
			passData.debugShadowMapMaterial = m_DebugHDShadowMapMaterial;
			builder.SetRenderFunc(delegate(RenderShadowsDebugOverlayPassData data, RenderGraphContext ctx)
			{
				LightingDebugSettings lightingDebugSettings = data.lightingDebugSettings;
				MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				switch (lightingDebugSettings.shadowDebugMode)
				{
				case ShadowMapDebugMode.VisualizeShadowMap:
				{
					int shadowMapIndex = (int)lightingDebugSettings.shadowMapIndex;
					int num = 1;
					for (int i = shadowMapIndex; i < shadowMapIndex + num; i++)
					{
						Rect rect = data.debugOverlay.Next();
						data.shadowManager.DisplayShadowMap(in data.shadowTextures, i, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					}
					break;
				}
				case ShadowMapDebugMode.VisualizePunctualLightAtlas:
				{
					Rect rect = data.debugOverlay.Next();
					data.shadowManager.DisplayShadowAtlas(data.shadowTextures.punctualShadowResult, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					break;
				}
				case ShadowMapDebugMode.VisualizeCachedPunctualLightAtlas:
				{
					Rect rect = data.debugOverlay.Next();
					data.shadowManager.DisplayCachedPunctualShadowAtlas(data.shadowTextures.cachedPunctualShadowResult, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					break;
				}
				case ShadowMapDebugMode.VisualizeDirectionalLightAtlas:
				{
					Rect rect = data.debugOverlay.Next();
					data.shadowManager.DisplayShadowCascadeAtlas(data.shadowTextures.directionalShadowResult, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					break;
				}
				case ShadowMapDebugMode.VisualizeAreaLightAtlas:
				{
					Rect rect = data.debugOverlay.Next();
					data.shadowManager.DisplayAreaLightShadowAtlas(data.shadowTextures.areaShadowResult, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					break;
				}
				case ShadowMapDebugMode.VisualizeCachedAreaLightAtlas:
				{
					Rect rect = data.debugOverlay.Next();
					data.shadowManager.DisplayCachedAreaShadowAtlas(data.shadowTextures.cachedAreaShadowResult, ctx.cmd, data.debugShadowMapMaterial, rect.x, rect.y, rect.width, rect.height, lightingDebugSettings.shadowMinValue, lightingDebugSettings.shadowMaxValue, tempMaterialPropertyBlock);
					break;
				}
				}
			});
		}

		private void RenderDecalOverlay(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, HDCamera hdCamera)
		{
			if (!m_CurrentDebugDisplaySettings.data.decalsDebugSettings.displayAtlas)
			{
				return;
			}
			RenderDecalOverlayPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderDecalOverlayPassData>("DecalOverlay", out passData, ProfilingSampler.Get(HDProfileId.DisplayDebugDecalsAtlas));
			passData.debugOverlay = m_DebugOverlay;
			passData.colorBuffer = renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
			passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
			passData.mipLevel = (int)debugDisplaySettings.data.decalsDebugSettings.mipLevel;
			passData.hdCamera = hdCamera;
			renderGraphBuilder.SetRenderFunc(delegate(RenderDecalOverlayPassData data, RenderGraphContext ctx)
			{
				DecalSystem.instance.RenderDebugOverlay(data.hdCamera, ctx.cmd, data.mipLevel, data.debugOverlay);
			});
		}

		private void RenderDebugOverlays(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle depthBuffer, TextureHandle depthPyramidTexture, TextureHandle rayCountTexture, in BuildGPULightListOutput lightLists, in ShadowResult shadowResult, HDCamera hdCamera)
		{
			float debugOverlayRatio = m_CurrentDebugDisplaySettings.data.debugOverlayRatio;
			int num = (int)hdCamera.finalViewport.width;
			int num2 = (int)hdCamera.finalViewport.height;
			int num3 = (int)((float)Math.Min(num, num2) * debugOverlayRatio);
			m_DebugOverlay.StartOverlay(HDUtils.GetRuntimeDebugPanelWidth(hdCamera), num2 - num3, num3, num);
			RenderSkyReflectionOverlay(renderGraph, colorBuffer, depthBuffer, hdCamera);
			RenderRayCountOverlay(renderGraph, hdCamera, colorBuffer, depthBuffer, rayCountTexture);
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.displayCookieAtlas)
			{
				RenderAtlasDebugOverlay(renderGraph, colorBuffer, depthBuffer, m_TextureCaches.lightCookieManager.atlasTexture, 0, (int)m_CurrentDebugDisplaySettings.data.lightingDebugSettings.cookieAtlasMipLevel, applyExposure: false, "RenderCookieAtlasOverlay", HDProfileId.DisplayCookieAtlas);
			}
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.displayReflectionProbeAtlas)
			{
				RenderAtlasDebugOverlay(renderGraph, colorBuffer, depthBuffer, m_TextureCaches.reflectionProbeTextureCache.GetAtlasTexture(), (int)m_CurrentDebugDisplaySettings.data.lightingDebugSettings.reflectionProbeSlice, (int)m_CurrentDebugDisplaySettings.data.lightingDebugSettings.reflectionProbeMipLevel, m_CurrentDebugDisplaySettings.data.lightingDebugSettings.reflectionProbeApplyExposure, "RenderReflectionProbeAtlasOverlay", HDProfileId.DisplayReflectionProbeAtlas);
			}
			RenderTileClusterDebugOverlay(renderGraph, colorBuffer, depthBuffer, in lightLists, depthPyramidTexture, hdCamera);
			RenderShadowsDebugOverlay(renderGraph, colorBuffer, depthBuffer, in shadowResult);
			RenderDecalOverlay(renderGraph, colorBuffer, depthBuffer, hdCamera);
			RenderMonitorsOverlay(renderGraph, colorBuffer, hdCamera);
		}

		private void RenderLightVolumes(RenderGraph renderGraph, TextureHandle destination, TextureHandle depthBuffer, CullingResults cullResults, HDCamera hdCamera)
		{
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.displayLightVolumes)
			{
				s_lightVolumes.RenderLightVolumes(renderGraph, m_CurrentDebugDisplaySettings.data.lightingDebugSettings, destination, depthBuffer, cullResults, hdCamera);
			}
		}

		private void GenerateDebugImageHistogram(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.exposureDebugMode != ExposureDebugMode.FinalImageHistogramView)
			{
				return;
			}
			DebugImageHistogramData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DebugImageHistogramData>("Generate Debug Image Histogram", out passData, ProfilingSampler.Get(HDProfileId.FinalImageHistogram));
			ValidateComputeBuffer(ref m_DebugImageHistogramBuffer, 256, 16);
			m_DebugImageHistogramBuffer.SetData(m_EmptyDebugImageHistogram);
			passData.debugImageHistogramCS = defaultResources.shaders.debugImageHistogramCS;
			passData.debugImageHistogramKernel = passData.debugImageHistogramCS.FindKernel("KHistogramGen");
			passData.imageHistogram = m_DebugImageHistogramBuffer;
			passData.cameraWidth = postProcessViewportSize.x;
			passData.cameraHeight = postProcessViewportSize.y;
			passData.source = renderGraphBuilder.ReadTexture(in source);
			renderGraphBuilder.SetRenderFunc(delegate(DebugImageHistogramData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetComputeTextureParam(data.debugImageHistogramCS, data.debugImageHistogramKernel, HDShaderIDs._SourceTexture, data.source);
				ctx.cmd.SetComputeBufferParam(data.debugImageHistogramCS, data.debugImageHistogramKernel, HDShaderIDs._HistogramBuffer, data.imageHistogram);
				int y = 16;
				int y2 = 16;
				int threadGroupsX = HDUtils.DivRoundUp(data.cameraWidth / 2, y);
				int threadGroupsY = HDUtils.DivRoundUp(data.cameraHeight / 2, y2);
				_ = data.cameraWidth;
				_ = data.cameraHeight;
				ctx.cmd.DispatchCompute(data.debugImageHistogramCS, data.debugImageHistogramKernel, threadGroupsX, threadGroupsY, 1);
			});
		}

		private TextureHandle GenerateDebugHDRxyMapping(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.hdrDebugMode == HDRDebugMode.None)
			{
				return TextureHandle.nullHandle;
			}
			GenerateHDRDebugData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GenerateHDRDebugData>("Generate HDR debug data", out passData, ProfilingSampler.Get(HDProfileId.HDRDebugData));
			try
			{
				passData.generateXYMappingCS = defaultResources.shaders.debugHDRxyMappingCS;
				passData.debugXYGenKernel = passData.generateXYMappingCS.FindKernel("KCIExyGen");
				passData.cameraWidth = postProcessViewportSize.x;
				passData.cameraHeight = postProcessViewportSize.y;
				passData.source = renderGraphBuilder.ReadTexture(in source);
				GenerateHDRDebugData generateHDRDebugData = passData;
				TextureDesc desc = new TextureDesc(512, 512, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "HDR_xyMapping"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				generateHDRDebugData.xyBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				ColorPrimaries colorPrimaries = ColorPrimaries.Rec709;
				if (HDROutputActiveForCameraType(hdCamera.camera.cameraType))
				{
					colorPrimaries = ColorGamutUtility.GetColorPrimaries(HDROutputSettings.main.displayColorGamut);
				}
				passData.debugParameters = new Vector4(512f, 512f, 0f, (float)colorPrimaries);
				renderGraphBuilder.SetRenderFunc(delegate(GenerateHDRDebugData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeTextureParam(data.generateXYMappingCS, data.debugXYGenKernel, HDShaderIDs._SourceTexture, data.source);
					ctx.cmd.SetComputeVectorParam(data.generateXYMappingCS, HDShaderIDs._HDRxyBufferDebugParams, data.debugParameters);
					ctx.cmd.SetComputeTextureParam(data.generateXYMappingCS, data.debugXYGenKernel, HDShaderIDs._xyBuffer, data.xyBuffer);
					int y = 8;
					int y2 = 8;
					int threadGroupsX = HDUtils.DivRoundUp(data.cameraWidth, y);
					int threadGroupsY = HDUtils.DivRoundUp(data.cameraHeight, y2);
					_ = data.cameraWidth;
					_ = data.cameraHeight;
					ctx.cmd.DispatchCompute(data.generateXYMappingCS, data.debugXYGenKernel, threadGroupsX, threadGroupsY, 1);
				});
				source = passData.xyBuffer;
				return source;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderHDRDebug(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle xyBuff)
		{
			DebugHDRData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DebugHDRData>("Debug HDR", out passData);
			try
			{
				passData.debugHDRMaterial = m_DebugHDROutput;
				passData.lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
				if (HDROutputActiveForCameraType(hdCamera.camera.cameraType))
				{
					GetHDROutputParameters(hdCamera.volumeStack.GetComponent<Tonemapping>(), out passData.hdrOutputParams, out passData.hdrOutputParams2);
				}
				else
				{
					passData.hdrOutputParams.z = 1f;
				}
				passData.debugPass = (int)(m_CurrentDebugDisplaySettings.data.lightingDebugSettings.hdrDebugMode - 1);
				passData.colorBuffer = renderGraphBuilder.ReadTexture(in colorBuffer);
				passData.debugFullScreenTexture = renderGraphBuilder.ReadTexture(in m_DebugFullScreenTexture);
				DebugHDRData debugHDRData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					name = "HDRDebug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				debugHDRData.output = renderGraphBuilder.WriteTexture(in input);
				passData.hdrDebugParams = new Vector4(512f, 512f, 0f, 0f);
				passData.xyTexture = renderGraphBuilder.ReadTexture(in xyBuff);
				renderGraphBuilder.SetRenderFunc(delegate(DebugHDRData data, RenderGraphContext ctx)
				{
					data.debugHDRMaterial.SetTexture(HDShaderIDs._DebugFullScreenTexture, data.debugFullScreenTexture);
					data.debugHDRMaterial.SetTexture(HDShaderIDs._xyBuffer, data.xyTexture);
					data.debugHDRMaterial.SetVector(HDShaderIDs._HDROutputParams, data.hdrOutputParams);
					data.debugHDRMaterial.SetVector(HDShaderIDs._HDROutputParams2, data.hdrOutputParams2);
					data.debugHDRMaterial.SetVector(HDShaderIDs._HDRDebugParams, data.hdrDebugParams);
					HDUtils.DrawFullScreen(ctx.cmd, data.debugHDRMaterial, data.output, null, data.debugPass);
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderExposureDebug(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer)
		{
			DebugExposureData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DebugExposureData>("Debug Exposure", out passData);
			try
			{
				ComputeProceduralMeteringParams(hdCamera, out passData.proceduralMeteringParams1, out passData.proceduralMeteringParams2);
				passData.lightingDebugSettings = m_CurrentDebugDisplaySettings.data.lightingDebugSettings;
				passData.hdCamera = hdCamera;
				passData.debugExposureMaterial = m_DebugExposure;
				passData.colorBuffer = renderGraphBuilder.ReadTexture(in colorBuffer);
				passData.debugFullScreenTexture = renderGraphBuilder.ReadTexture(in m_DebugFullScreenTexture);
				DebugExposureData debugExposureData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					name = "ExposureDebug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				debugExposureData.output = renderGraphBuilder.WriteTexture(in input);
				DebugExposureData debugExposureData2 = passData;
				input = renderGraph.ImportTexture(GetExposureTexture(hdCamera));
				debugExposureData2.currentExposure = renderGraphBuilder.ReadTexture(in input);
				DebugExposureData debugExposureData3 = passData;
				input = renderGraph.ImportTexture(GetPreviousExposureTexture(hdCamera));
				debugExposureData3.previousExposure = renderGraphBuilder.ReadTexture(in input);
				DebugExposureData debugExposureData4 = passData;
				input = renderGraph.ImportTexture(GetExposureDebugData());
				debugExposureData4.debugExposureData = renderGraphBuilder.ReadTexture(in input);
				passData.customToneMapCurve = GetCustomToneMapCurve();
				passData.lutSize = GetLutSize();
				passData.histogramBuffer = ((passData.lightingDebugSettings.exposureDebugMode == ExposureDebugMode.FinalImageHistogramView) ? GetDebugImageHistogramBuffer() : GetHistogramBuffer());
				renderGraphBuilder.SetRenderFunc(delegate(DebugExposureData data, RenderGraphContext ctx)
				{
					Exposure component = data.hdCamera.volumeStack.GetComponent<Exposure>();
					Vector4 value = new Vector4(component.compensation.value + data.lightingDebugSettings.debugExposure, component.limitMin.value, component.limitMax.value, 0f);
					Vector4 value2 = new Vector4(1f, (float)component.meteringMode.value, (float)component.adaptationMode.value, 0f);
					Vector2 vector = component.histogramPercentages.value / 100f;
					float b = component.limitMax.value - component.limitMin.value;
					float num = 1f / Mathf.Max(1E-05f, b);
					float y = (0f - component.limitMin.value) * num;
					Vector4 value3 = new Vector4(num, y, vector.x, vector.y);
					data.debugExposureMaterial.SetVector(HDShaderIDs._ProceduralMaskParams, data.proceduralMeteringParams1);
					data.debugExposureMaterial.SetVector(HDShaderIDs._ProceduralMaskParams2, data.proceduralMeteringParams2);
					data.debugExposureMaterial.SetVector(HDShaderIDs._HistogramExposureParams, value3);
					data.debugExposureMaterial.SetVector(HDShaderIDs._Variants, value2);
					data.debugExposureMaterial.SetVector(HDShaderIDs._ExposureParams, value);
					data.debugExposureMaterial.SetVector(HDShaderIDs._ExposureParams2, new Vector4(0f, 0f, ColorUtils.lensImperfectionExposureScale, ColorUtils.s_LightMeterCalibrationConstant));
					data.debugExposureMaterial.SetVector(HDShaderIDs._MousePixelCoord, HDUtils.GetMouseCoordinates(data.hdCamera));
					data.debugExposureMaterial.SetTexture(HDShaderIDs._SourceTexture, data.colorBuffer);
					data.debugExposureMaterial.SetTexture(HDShaderIDs._DebugFullScreenTexture, data.debugFullScreenTexture);
					data.debugExposureMaterial.SetTexture(HDShaderIDs._PreviousExposureTexture, data.previousExposure);
					data.debugExposureMaterial.SetTexture(HDShaderIDs._ExposureTexture, data.currentExposure);
					data.debugExposureMaterial.SetTexture(HDShaderIDs._ExposureWeightMask, component.weightTextureMask.value);
					data.debugExposureMaterial.SetBuffer(HDShaderIDs._HistogramBuffer, data.histogramBuffer);
					int shaderPassId = 0;
					if (data.lightingDebugSettings.exposureDebugMode == ExposureDebugMode.MeteringWeighted)
					{
						shaderPassId = 1;
						data.debugExposureMaterial.SetVector(HDShaderIDs._ExposureDebugParams, new Vector4(data.lightingDebugSettings.displayMaskOnly ? 1 : 0, 0f, 0f, 0f));
					}
					if (data.lightingDebugSettings.exposureDebugMode == ExposureDebugMode.HistogramView)
					{
						data.debugExposureMaterial.SetTexture(HDShaderIDs._ExposureDebugTexture, data.debugExposureData);
						Tonemapping component2 = data.hdCamera.volumeStack.GetComponent<Tonemapping>();
						TonemappingMode tonemappingMode = (data.hdCamera.frameSettings.IsEnabled(FrameSettingsField.Tonemapping) ? component2.mode.value : TonemappingMode.None);
						bool flag = tonemappingMode != 0 && data.lightingDebugSettings.showTonemapCurveAlongHistogramView;
						bool centerHistogramAroundMiddleGrey = data.lightingDebugSettings.centerHistogramAroundMiddleGrey;
						bool displayOnSceneOverlay = data.lightingDebugSettings.displayOnSceneOverlay;
						data.debugExposureMaterial.SetVector(HDShaderIDs._ExposureDebugParams, new Vector4(flag ? 1f : 0f, (float)tonemappingMode, centerHistogramAroundMiddleGrey ? 1 : 0, displayOnSceneOverlay ? 1 : 0));
						if (flag)
						{
							if (tonemappingMode == TonemappingMode.Custom)
							{
								data.debugExposureMaterial.SetVector(HDShaderIDs._CustomToneCurve, data.customToneMapCurve.uniforms.curve);
								data.debugExposureMaterial.SetVector(HDShaderIDs._ToeSegmentA, data.customToneMapCurve.uniforms.toeSegmentA);
								data.debugExposureMaterial.SetVector(HDShaderIDs._ToeSegmentB, data.customToneMapCurve.uniforms.toeSegmentB);
								data.debugExposureMaterial.SetVector(HDShaderIDs._MidSegmentA, data.customToneMapCurve.uniforms.midSegmentA);
								data.debugExposureMaterial.SetVector(HDShaderIDs._MidSegmentB, data.customToneMapCurve.uniforms.midSegmentB);
								data.debugExposureMaterial.SetVector(HDShaderIDs._ShoSegmentA, data.customToneMapCurve.uniforms.shoSegmentA);
								data.debugExposureMaterial.SetVector(HDShaderIDs._ShoSegmentB, data.customToneMapCurve.uniforms.shoSegmentB);
							}
						}
						else if (tonemappingMode == TonemappingMode.External)
						{
							data.debugExposureMaterial.SetTexture(HDShaderIDs._LogLut3D, component2.lutTexture.value);
							data.debugExposureMaterial.SetVector(HDShaderIDs._LogLut3D_Params, new Vector4(1f / (float)data.lutSize, (float)data.lutSize - 1f, component2.lutContribution.value, 0f));
						}
						shaderPassId = 2;
					}
					if (data.lightingDebugSettings.exposureDebugMode == ExposureDebugMode.FinalImageHistogramView)
					{
						bool displayFinalImageHistogramAsRGB = data.lightingDebugSettings.displayFinalImageHistogramAsRGB;
						data.debugExposureMaterial.SetVector(HDShaderIDs._ExposureDebugParams, new Vector4(0f, 0f, 0f, displayFinalImageHistogramAsRGB ? 1 : 0));
						data.debugExposureMaterial.SetBuffer(HDShaderIDs._FullImageHistogram, data.histogramBuffer);
						shaderPassId = 3;
					}
					HDUtils.DrawFullScreen(ctx.cmd, data.debugExposureMaterial, data.output, null, shaderPassId);
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderDebug(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthBuffer, TextureHandle depthPyramidTexture, TextureHandle colorPickerDebugTexture, TextureHandle rayCountTexture, TextureHandle xyBufferMapping, in BuildGPULightListOutput lightLists, in ShadowResult shadowResult, CullingResults cullResults, GraphicsFormat colorFormat)
		{
			if (hdCamera.camera.cameraType == CameraType.Reflection || hdCamera.camera.cameraType == CameraType.Preview)
			{
				return colorBuffer;
			}
			TextureHandle textureHandle = colorBuffer;
			if (NeedsFullScreenDebugMode() && m_FullScreenDebugPushed)
			{
				textureHandle = ResolveFullScreenDebug(renderGraph, m_DebugFullScreenTexture, depthPyramidTexture, hdCamera, colorFormat);
				if (NeedColorPickerDebug(m_CurrentDebugDisplaySettings))
				{
					colorPickerDebugTexture = PushColorPickerDebugTexture(renderGraph, textureHandle);
				}
				m_FullScreenDebugPushed = false;
				m_DebugFullScreenComputeBuffer = ComputeBufferHandle.nullHandle;
			}
			if (NeedExposureDebugMode(m_CurrentDebugDisplaySettings))
			{
				textureHandle = RenderExposureDebug(renderGraph, hdCamera, colorBuffer);
			}
			if (NeedHDRDebugMode(m_CurrentDebugDisplaySettings))
			{
				textureHandle = RenderHDRDebug(renderGraph, hdCamera, colorBuffer, xyBufferMapping);
			}
			if (NeedColorPickerDebug(m_CurrentDebugDisplaySettings))
			{
				textureHandle = ResolveColorPickerDebug(renderGraph, colorPickerDebugTexture, hdCamera, colorFormat);
			}
			RenderLightVolumes(renderGraph, textureHandle, depthBuffer, cullResults, hdCamera);
			RenderDebugOverlays(renderGraph, textureHandle, depthBuffer, depthPyramidTexture, rayCountTexture, in lightLists, in shadowResult, hdCamera);
			return textureHandle;
		}

		private TextureHandle RenderDebugViewMaterial(RenderGraph renderGraph, CullingResults cull, HDCamera hdCamera, BuildGPULightListOutput lightLists, DBufferOutput dbuffer, GBufferOutput gbuffer, TextureHandle depthBuffer, TextureHandle vtFeedbackBuffer)
		{
			bool msaaEnabled = hdCamera.msaaEnabled;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GetColorBufferFormat(),
				enableRandomWrite = !msaaEnabled,
				bindTextureMS = msaaEnabled,
				msaaSamples = hdCamera.msaaSamples,
				clearBuffer = true,
				clearColor = Color.clear,
				name = (msaaEnabled ? "CameraColorMSAA" : "CameraColor")
			};
			TextureHandle input = renderGraph.CreateTexture(in desc);
			if (m_CurrentDebugDisplaySettings.data.materialDebugSettings.IsDebugGBufferEnabled() && hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred)
			{
				DebugViewMaterialData passData;
				using RenderGraphBuilder builder = renderGraph.AddRenderPass<DebugViewMaterialData>("DebugViewMaterialGBuffer", out passData, ProfilingSampler.Get(HDProfileId.DebugViewMaterialGBuffer));
				passData.debugGBufferMaterial = m_currentDebugViewMaterialGBuffer;
				passData.outputColor = builder.WriteTexture(in input);
				passData.gbuffer = ReadGBuffer(gbuffer, builder);
				passData.depthBuffer = builder.ReadTexture(in depthBuffer);
				builder.SetRenderFunc(delegate(DebugViewMaterialData data, RenderGraphContext context)
				{
					GBufferOutput gbuffer2 = data.gbuffer;
					for (int i = 0; i < gbuffer2.gBufferCount; i++)
					{
						data.debugGBufferMaterial.SetTexture(HDShaderIDs._GBufferTexture[i], gbuffer2.mrt[i]);
					}
					data.debugGBufferMaterial.SetTexture(HDShaderIDs._CameraDepthTexture, data.depthBuffer);
					HDUtils.DrawFullScreen(context.cmd, data.debugGBufferMaterial, data.outputColor);
				});
			}
			else
			{
				TextureHandle input2 = CreateDepthBuffer(renderGraph, clear: true, hdCamera.msaaSamples);
				RenderWaterDebug(renderGraph, hdCamera, msaaEnabled, input, depthBuffer, in lightLists);
				DebugViewMaterialData passData2;
				RenderGraphBuilder builder2 = renderGraph.AddRenderPass<DebugViewMaterialData>("DisplayDebug ViewMaterial", out passData2, ProfilingSampler.Get(HDProfileId.DisplayDebugViewMaterial));
				try
				{
					passData2.frameSettings = hdCamera.frameSettings;
					passData2.outputColor = builder2.UseColorBuffer(in input, 0);
					passData2.outputDepth = builder2.UseDepthBuffer(in input2, DepthAccess.ReadWrite);
					DebugViewMaterialData debugViewMaterialData = passData2;
					Camera camera = hdCamera.camera;
					ShaderTagId[] allForwardOpaquePassNames = m_AllForwardOpaquePassNames;
					PerObjectData currentRendererConfigurationBakedLighting = m_CurrentRendererConfigurationBakedLighting;
					RenderStateBlock? stateBlock = m_DepthStateOpaque;
					RendererListDesc desc2 = CreateOpaqueRendererListDesc(cull, camera, allForwardOpaquePassNames, currentRendererConfigurationBakedLighting, null, stateBlock);
					RendererListHandle input3 = renderGraph.CreateRendererList(in desc2);
					debugViewMaterialData.opaqueRendererList = builder2.UseRendererList(in input3);
					DebugViewMaterialData debugViewMaterialData2 = passData2;
					Camera camera2 = hdCamera.camera;
					ShaderTagId[] allTransparentPassNames = m_AllTransparentPassNames;
					PerObjectData currentRendererConfigurationBakedLighting2 = m_CurrentRendererConfigurationBakedLighting;
					stateBlock = m_DepthStateNoWrite;
					desc2 = CreateTransparentRendererListDesc(cull, camera2, allTransparentPassNames, currentRendererConfigurationBakedLighting2, null, stateBlock);
					input3 = renderGraph.CreateRendererList(in desc2);
					debugViewMaterialData2.transparentRendererList = builder2.UseRendererList(in input3);
					passData2.decalsEnabled = hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) && DecalSystem.m_DecalDatasCount > 0;
					passData2.perVoxelOffset = builder2.ReadComputeBuffer(in lightLists.perVoxelOffset);
					passData2.dbuffer = ReadDBuffer(dbuffer, builder2);
					passData2.clearColorTexture = CompositionManager.GetClearTextureForStackedCamera(hdCamera);
					passData2.clearDepthTexture = CompositionManager.GetClearDepthForStackedCamera(hdCamera);
					passData2.clearDepth = hdCamera.clearDepth;
					builder2.SetRenderFunc(delegate(DebugViewMaterialData data, RenderGraphContext context)
					{
						if (data.clearColorTexture != null)
						{
							HDUtils.BlitColorAndDepth(context.cmd, data.clearColorTexture, data.clearDepthTexture, new Vector4(1f, 1f, 0f, 0f), 0f, !data.clearDepth);
						}
						BindDefaultTexturesLightingBuffers(context.defaultResources, context.cmd);
						BindDBufferGlobalData(in data.dbuffer, in context);
						ref FrameSettings frameSettings = ref data.frameSettings;
						RendererList rendererList = data.opaqueRendererList;
						DrawOpaqueRendererList(in context, in frameSettings, in rendererList);
						if (data.decalsEnabled)
						{
							DecalSystem.instance.SetAtlas(context.cmd);
						}
						if (data.perVoxelOffset.IsValid())
						{
							context.cmd.SetGlobalBuffer(HDShaderIDs.g_vLayeredOffsetsBuffer, data.perVoxelOffset);
						}
						DrawTransparentRendererList(in context, in data.frameSettings, data.transparentRendererList);
					});
				}
				finally
				{
					((IDisposable)builder2).Dispose();
				}
			}
			return input;
		}

		private void PushFullScreenLightingDebugTexture(RenderGraph renderGraph, TextureHandle input, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			if (NeedsFullScreenDebugMode() && !m_FullScreenDebugPushed)
			{
				PushFullScreenDebugTexture(renderGraph, input, colorFormat);
			}
		}

		internal void PushFullScreenDebugTexture(RenderGraph renderGraph, TextureHandle input, FullScreenDebugMode debugMode, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat, bool xrTexture = true)
		{
			if (debugMode == m_CurrentDebugDisplaySettings.data.fullScreenDebugMode)
			{
				PushFullScreenDebugTexture(renderGraph, input, colorFormat, -1, xrTexture);
			}
		}

		internal void PushFullScreenDebugTexture(RenderGraph renderGraph, TextureHandle input, Vector2 scales, FullScreenDebugMode debugMode, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat, bool xrTexture = true)
		{
			if (debugMode == m_CurrentDebugDisplaySettings.data.fullScreenDebugMode)
			{
				PushFullScreenDebugTexture(renderGraph, input, useCustomScaleBias: true, scales, colorFormat, -1, xrTexture);
			}
		}

		private void PushFullScreenDebugTextureMip(RenderGraph renderGraph, TextureHandle input, int lodCount, Vector4 scaleBias, FullScreenDebugMode debugMode, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			if (debugMode == m_CurrentDebugDisplaySettings.data.fullScreenDebugMode)
			{
				int mipIndex = Mathf.FloorToInt(m_CurrentDebugDisplaySettings.data.fullscreenDebugMip * (float)lodCount);
				PushFullScreenDebugTexture(renderGraph, input, colorFormat, mipIndex);
			}
		}

		private void PushFullScreenDebugTexture(RenderGraph renderGraph, TextureHandle input, GraphicsFormat rtFormat = GraphicsFormat.R16G16B16A16_SFloat, int mipIndex = -1, bool xrTexture = true)
		{
			PushFullScreenDebugTexture(renderGraph, input, useCustomScaleBias: false, new Vector2(1f, 1f), rtFormat, mipIndex, xrTexture);
		}

		private void PushFullScreenDebugTexture(RenderGraph renderGraph, TextureHandle input, bool useCustomScaleBias, Vector2 customScales, GraphicsFormat rtFormat = GraphicsFormat.R16G16B16A16_SFloat, int mipIndex = -1, bool xrTexture = true)
		{
			PushFullScreenDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PushFullScreenDebugPassData>("Push Full Screen Debug", out passData);
			try
			{
				passData.mipIndex = mipIndex;
				passData.xrTexture = xrTexture;
				passData.input = renderGraphBuilder.ReadTexture(in input);
				passData.useCustomScaleBias = false;
				if (useCustomScaleBias)
				{
					passData.useCustomScaleBias = true;
					passData.customScaleBias = new Vector4(customScales.x, customScales.y, 0f, 0f);
				}
				PushFullScreenDebugPassData pushFullScreenDebugPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = rtFormat,
					name = "DebugFullScreen"
				};
				TextureHandle input2 = renderGraph.CreateTexture(in desc);
				pushFullScreenDebugPassData.output = renderGraphBuilder.UseColorBuffer(in input2, 0);
				renderGraphBuilder.SetRenderFunc(delegate(PushFullScreenDebugPassData data, RenderGraphContext ctx)
				{
					if (data.useCustomScaleBias)
					{
						if (data.xrTexture)
						{
							if (data.mipIndex != -1)
							{
								HDUtils.BlitCameraTexture(ctx.cmd, data.input, data.output, data.customScaleBias, data.mipIndex);
							}
							else
							{
								HDUtils.BlitCameraTexture(ctx.cmd, data.input, data.output, data.customScaleBias);
							}
						}
						else
						{
							CoreUtils.SetRenderTarget(ctx.cmd, data.output);
							if (data.mipIndex != -1)
							{
								HDUtils.BlitTexture2D(ctx.cmd, data.input, data.customScaleBias, data.mipIndex, bilinear: false);
							}
							else
							{
								HDUtils.BlitTexture2D(ctx.cmd, data.input, data.customScaleBias, 0f, bilinear: false);
							}
						}
					}
					else if (data.xrTexture)
					{
						if (data.mipIndex != -1)
						{
							HDUtils.BlitCameraTexture(ctx.cmd, data.input, data.output, data.mipIndex);
						}
						else
						{
							HDUtils.BlitCameraTexture(ctx.cmd, data.input, data.output);
						}
					}
					else if (data.mipIndex != -1)
					{
						HDUtils.BlitCameraTexture2D(ctx.cmd, data.input, data.output, data.mipIndex);
					}
					else
					{
						HDUtils.BlitCameraTexture2D(ctx.cmd, data.input, data.output);
					}
				});
				m_DebugFullScreenTexture = passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			m_FullScreenDebugPushed = true;
		}

		private void PushFullScreenExposureDebugTexture(RenderGraph renderGraph, TextureHandle input, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.exposureDebugMode != 0)
			{
				PushFullScreenDebugTexture(renderGraph, input, colorFormat);
			}
		}

		private void PushFullScreenHDRDebugTexture(RenderGraph renderGraph, TextureHandle input, GraphicsFormat colorFormat = GraphicsFormat.R16G16B16A16_SFloat)
		{
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.hdrDebugMode != 0)
			{
				PushFullScreenDebugTexture(renderGraph, input, colorFormat);
			}
		}

		private TextureHandle PushColorPickerDebugTexture(RenderGraph renderGraph, TextureHandle input)
		{
			PushFullScreenDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PushFullScreenDebugPassData>("Push To Color Picker", out passData);
			try
			{
				passData.input = renderGraphBuilder.ReadTexture(in input);
				PushFullScreenDebugPassData pushFullScreenDebugPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					name = "DebugColorPicker"
				};
				TextureHandle input2 = renderGraph.CreateTexture(in desc);
				pushFullScreenDebugPassData.output = renderGraphBuilder.UseColorBuffer(in input2, 0);
				renderGraphBuilder.SetRenderFunc(delegate(PushFullScreenDebugPassData data, RenderGraphContext ctx)
				{
					HDUtils.BlitCameraTexture(ctx.cmd, data.input, data.output);
				});
				return passData.output;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private static LightingBuffers ReadLightingBuffers(in LightingBuffers buffers, RenderGraphBuilder builder)
		{
			LightingBuffers result = default(LightingBuffers);
			result.ambientOcclusionBuffer = builder.ReadTexture(in buffers.ambientOcclusionBuffer);
			result.ssrLightingBuffer = builder.ReadTexture(in buffers.ssrLightingBuffer);
			result.ssgiLightingBuffer = builder.ReadTexture(in buffers.ssgiLightingBuffer);
			result.contactShadowsBuffer = builder.ReadTexture(in buffers.contactShadowsBuffer);
			result.screenspaceShadowBuffer = builder.ReadTexture(in buffers.screenspaceShadowBuffer);
			return result;
		}

		private static void BindGlobalLightingBuffers(in LightingBuffers buffers, CommandBuffer cmd)
		{
			cmd.SetGlobalTexture(HDShaderIDs._AmbientOcclusionTexture, buffers.ambientOcclusionBuffer);
			cmd.SetGlobalTexture(HDShaderIDs._SsrLightingTexture, buffers.ssrLightingBuffer);
			cmd.SetGlobalTexture(HDShaderIDs._IndirectDiffuseTexture, buffers.ssgiLightingBuffer);
			cmd.SetGlobalTexture(HDShaderIDs._ContactShadowTexture, buffers.contactShadowsBuffer);
			cmd.SetGlobalTexture(HDShaderIDs._ScreenSpaceShadowsTexture, buffers.screenspaceShadowBuffer);
		}

		private static void BindDefaultTexturesLightingBuffers(RenderGraphDefaultResources defaultResources, CommandBuffer cmd)
		{
			cmd.SetGlobalTexture(HDShaderIDs._AmbientOcclusionTexture, defaultResources.blackTextureXR);
			cmd.SetGlobalTexture(HDShaderIDs._SsrLightingTexture, defaultResources.blackTextureXR);
			cmd.SetGlobalTexture(HDShaderIDs._IndirectDiffuseTexture, defaultResources.blackTextureXR);
			cmd.SetGlobalTexture(HDShaderIDs._ContactShadowTexture, defaultResources.blackUIntTextureXR);
			cmd.SetGlobalTexture(HDShaderIDs._ScreenSpaceShadowsTexture, defaultResources.blackTextureXR);
		}

		private static void ClearLightList(BuildGPULightListPassData data, CommandBuffer cmd, ComputeBuffer bufferToClear)
		{
			cmd.SetComputeBufferParam(data.clearLightListCS, data.clearLightListKernel, HDShaderIDs._LightListToClear, bufferToClear);
			Vector2 vector = new Vector2Int(bufferToClear.count, 0);
			int num = 64;
			int num2 = (bufferToClear.count + num - 1) / num;
			int num3 = 0;
			while (num2 > 0)
			{
				vector.y = 65535 * num3;
				cmd.SetComputeVectorParam(data.clearLightListCS, HDShaderIDs._LightListEntriesAndOffset, vector);
				int num4 = Math.Min(65535, num2);
				cmd.DispatchCompute(data.clearLightListCS, data.clearLightListKernel, num4, 1, 1);
				num2 -= num4;
				num3++;
			}
		}

		private static void ClearLightLists(BuildGPULightListPassData data, CommandBuffer cmd)
		{
			if (data.clearLightLists)
			{
				if (data.runBigTilePrepass)
				{
					ClearLightList(data, cmd, data.output.bigTileLightList);
				}
				if (data.canClearLightList)
				{
					ClearLightList(data, cmd, data.output.lightList);
				}
				ClearLightList(data, cmd, data.output.perVoxelOffset);
			}
		}

		private static void GenerateLightsScreenSpaceAABBs(BuildGPULightListPassData data, CommandBuffer cmd)
		{
			if (data.totalLightCount != 0)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.GenerateLightAABBs)))
				{
					cmd.SetComputeBufferParam(data.screenSpaceAABBShader, data.screenSpaceAABBKernel, HDShaderIDs.g_data, data.convexBoundsBuffer);
					cmd.SetComputeBufferParam(data.screenSpaceAABBShader, data.screenSpaceAABBKernel, HDShaderIDs.g_vBoundsBuffer, data.AABBBoundsBuffer);
					ConstantBuffer.Push(cmd, in data.lightListCB, data.screenSpaceAABBShader, HDShaderIDs._ShaderVariablesLightList);
					int threadGroupsX = HDUtils.DivRoundUp(data.totalLightCount * 4, 64);
					cmd.DispatchCompute(data.screenSpaceAABBShader, data.screenSpaceAABBKernel, threadGroupsX, data.viewCount, 1);
				}
			}
		}

		private static void BigTilePrepass(BuildGPULightListPassData data, CommandBuffer cmd)
		{
			if (data.runLightList && data.runBigTilePrepass)
			{
				cmd.SetComputeBufferParam(data.bigTilePrepassShader, data.bigTilePrepassKernel, HDShaderIDs.g_vLightList, data.output.bigTileLightList);
				cmd.SetComputeBufferParam(data.bigTilePrepassShader, data.bigTilePrepassKernel, HDShaderIDs.g_vBoundsBuffer, data.AABBBoundsBuffer);
				cmd.SetComputeBufferParam(data.bigTilePrepassShader, data.bigTilePrepassKernel, HDShaderIDs._LightVolumeData, data.lightVolumeDataBuffer);
				cmd.SetComputeBufferParam(data.bigTilePrepassShader, data.bigTilePrepassKernel, HDShaderIDs.g_data, data.convexBoundsBuffer);
				ConstantBuffer.Push(cmd, in data.lightListCB, data.bigTilePrepassShader, HDShaderIDs._ShaderVariablesLightList);
				cmd.DispatchCompute(data.bigTilePrepassShader, data.bigTilePrepassKernel, data.numBigTilesX, data.numBigTilesY, data.viewCount);
			}
		}

		private static void BuildPerTileLightList(BuildGPULightListPassData data, ref bool tileFlagsWritten, CommandBuffer cmd)
		{
			if (!data.runLightList || !data.runFPTL)
			{
				return;
			}
			cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_vBoundsBuffer, data.AABBBoundsBuffer);
			cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs._LightVolumeData, data.lightVolumeDataBuffer);
			cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_data, data.convexBoundsBuffer);
			cmd.SetComputeTextureParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_depth_tex, data.depthBuffer);
			cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_vLightList, data.output.lightList);
			if (data.runBigTilePrepass)
			{
				cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_vBigTileLightList, data.output.bigTileLightList);
			}
			ShaderVariablesLightList data2 = data.lightListCB;
			if (data.enableFeatureVariants)
			{
				uint num = 0u;
				if (data.directionalLightCount > 0)
				{
					num |= 0x4000u;
				}
				if (data.skyEnabled)
				{
					num |= 0x10000u;
				}
				if (!data.computeMaterialVariants)
				{
					num |= LightDefinitions.s_MaterialFeatureMaskFlags;
				}
				data2.g_BaseFeatureFlags = num;
				cmd.SetComputeBufferParam(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, HDShaderIDs.g_TileFeatureFlags, data.output.tileFeatureFlags);
				tileFlagsWritten = true;
			}
			ConstantBuffer.Push(cmd, in data2, data.buildPerTileLightListShader, HDShaderIDs._ShaderVariablesLightList);
			cmd.DispatchCompute(data.buildPerTileLightListShader, data.buildPerTileLightListKernel, data.numTilesFPTLX, data.numTilesFPTLY, data.viewCount);
		}

		private static void VoxelLightListGeneration(BuildGPULightListPassData data, CommandBuffer cmd)
		{
			if (data.runLightList)
			{
				cmd.SetComputeBufferParam(data.clearClusterAtomicIndexShader, s_ClearVoxelAtomicKernel, HDShaderIDs.g_LayeredSingleIdxBuffer, data.globalLightListAtomic);
				cmd.DispatchCompute(data.clearClusterAtomicIndexShader, s_ClearVoxelAtomicKernel, 1, 1, 1);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, s_ClearVoxelAtomicKernel, HDShaderIDs.g_LayeredSingleIdxBuffer, data.globalLightListAtomic);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_vLayeredLightList, data.output.perVoxelLightLists);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_LayeredOffset, data.output.perVoxelOffset);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_LayeredSingleIdxBuffer, data.globalLightListAtomic);
				if (data.runBigTilePrepass)
				{
					cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_vBigTileLightList, data.output.bigTileLightList);
				}
				if (data.clusterNeedsDepth)
				{
					cmd.SetComputeTextureParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_depth_tex, data.depthBuffer);
					cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_logBaseBuffer, data.output.perTileLogBaseTweak);
				}
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_vBoundsBuffer, data.AABBBoundsBuffer);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs._LightVolumeData, data.lightVolumeDataBuffer);
				cmd.SetComputeBufferParam(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, HDShaderIDs.g_data, data.convexBoundsBuffer);
				ConstantBuffer.Push(cmd, in data.lightListCB, data.buildPerVoxelLightListShader, HDShaderIDs._ShaderVariablesLightList);
				cmd.DispatchCompute(data.buildPerVoxelLightListShader, data.buildPerVoxelLightListKernel, data.numTilesClusterX, data.numTilesClusterY, data.viewCount);
			}
		}

		private static void BuildDispatchIndirectArguments(BuildGPULightListPassData data, bool tileFlagsWritten, CommandBuffer cmd)
		{
			if (!data.enableFeatureVariants)
			{
				return;
			}
			if (!tileFlagsWritten || data.computeMaterialVariants)
			{
				int kernelIndex = s_BuildMaterialFlagsWriteKernel;
				data.buildMaterialFlagsShader.shaderKeywords = null;
				if (tileFlagsWritten && data.computeLightVariants)
				{
					data.buildMaterialFlagsShader.EnableKeyword("USE_OR");
				}
				uint num = 0u;
				if (!data.computeLightVariants)
				{
					num |= LightDefinitions.s_LightFeatureMaskFlags;
				}
				if (!tileFlagsWritten)
				{
					if (data.directionalLightCount > 0)
					{
						num |= 0x4000u;
					}
					if (data.skyEnabled)
					{
						num |= 0x10000u;
					}
					if (!data.computeMaterialVariants)
					{
						num |= LightDefinitions.s_MaterialFeatureMaskFlags;
					}
				}
				ShaderVariablesLightList data2 = data.lightListCB;
				data2.g_BaseFeatureFlags = num;
				cmd.SetComputeBufferParam(data.buildMaterialFlagsShader, kernelIndex, HDShaderIDs.g_TileFeatureFlags, data.output.tileFeatureFlags);
				for (int i = 0; i < data.gBufferCount; i++)
				{
					cmd.SetComputeTextureParam(data.buildMaterialFlagsShader, kernelIndex, HDShaderIDs._GBufferTexture[i], data.gBuffer[i]);
				}
				RTHandle rTHandle = data.stencilTexture;
				if (rTHandle?.rt != null && rTHandle.rt.stencilFormat != 0)
				{
					cmd.SetComputeTextureParam(data.buildMaterialFlagsShader, kernelIndex, HDShaderIDs._StencilTexture, data.stencilTexture, 0, RenderTextureSubElement.Stencil);
				}
				else
				{
					cmd.SetComputeTextureParam(data.buildMaterialFlagsShader, kernelIndex, HDShaderIDs._StencilTexture, data.stencilTexture);
				}
				ConstantBuffer.Push(cmd, in data2, data.buildMaterialFlagsShader, HDShaderIDs._ShaderVariablesLightList);
				cmd.DispatchCompute(data.buildMaterialFlagsShader, kernelIndex, data.numTilesFPTLX, data.numTilesFPTLY, data.viewCount);
			}
			if (data.useComputeAsPixel)
			{
				cmd.SetComputeBufferParam(data.clearDispatchIndirectShader, s_ClearDrawProceduralIndirectKernel, HDShaderIDs.g_DispatchIndirectBuffer, data.output.dispatchIndirectBuffer);
				cmd.SetComputeIntParam(data.clearDispatchIndirectShader, HDShaderIDs.g_NumTiles, data.numTilesFPTL);
				cmd.SetComputeIntParam(data.clearDispatchIndirectShader, HDShaderIDs.g_VertexPerTile, 6);
				cmd.DispatchCompute(data.clearDispatchIndirectShader, s_ClearDrawProceduralIndirectKernel, 1, 1, 1);
			}
			else
			{
				cmd.SetComputeBufferParam(data.clearDispatchIndirectShader, s_ClearDispatchIndirectKernel, HDShaderIDs.g_DispatchIndirectBuffer, data.output.dispatchIndirectBuffer);
				cmd.DispatchCompute(data.clearDispatchIndirectShader, s_ClearDispatchIndirectKernel, 1, 1, 1);
			}
			cmd.SetComputeBufferParam(data.buildDispatchIndirectShader, s_BuildIndirectKernel, HDShaderIDs.g_DispatchIndirectBuffer, data.output.dispatchIndirectBuffer);
			cmd.SetComputeBufferParam(data.buildDispatchIndirectShader, s_BuildIndirectKernel, HDShaderIDs.g_TileList, data.output.tileList);
			cmd.SetComputeBufferParam(data.buildDispatchIndirectShader, s_BuildIndirectKernel, HDShaderIDs.g_TileFeatureFlags, data.output.tileFeatureFlags);
			cmd.SetComputeIntParam(data.buildDispatchIndirectShader, HDShaderIDs.g_NumTiles, data.numTilesFPTL);
			cmd.SetComputeIntParam(data.buildDispatchIndirectShader, HDShaderIDs.g_NumTilesX, data.numTilesFPTLX);
			cmd.DispatchCompute(data.buildDispatchIndirectShader, s_BuildIndirectKernel, (data.numTilesFPTL + 64 - 1) / 64, 1, data.viewCount);
		}

		private static bool DeferredUseComputeAsPixel(FrameSettings frameSettings)
		{
			if (frameSettings.IsEnabled(FrameSettingsField.DeferredTile))
			{
				if (frameSettings.IsEnabled(FrameSettingsField.ComputeLightEvaluation))
				{
					return k_PreferFragment;
				}
				return true;
			}
			return false;
		}

		private unsafe void PrepareBuildGPULightListPassData(RenderGraph renderGraph, RenderGraphBuilder builder, HDCamera hdCamera, TileAndClusterData tileAndClusterData, ref ShaderVariablesLightList constantBuffer, int totalLightCount, TextureHandle depthStencilBuffer, TextureHandle stencilBufferCopy, GBufferOutput gBuffer, BuildGPULightListPassData passData)
		{
			Camera camera = hdCamera.camera;
			int num = (int)hdCamera.screenSize.x;
			int num2 = (int)hdCamera.screenSize.y;
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetRow(0, new Vector4(0.5f * (float)num, 0f, 0f, 0.5f * (float)num));
			matrix4x.SetRow(1, new Vector4(0f, 0.5f * (float)num2, 0f, 0.5f * (float)num2));
			matrix4x.SetRow(2, new Vector4(0f, 0f, 0.5f, 0.5f));
			matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			for (int i = 0; i < hdCamera.viewCount; i++)
			{
				Matrix4x4 matrix4x2 = (hdCamera.xr.enabled ? hdCamera.xr.GetProjMatrix(i) : camera.projectionMatrix);
				matrix4x2 = (hdCamera.RequiresCameraJitter() ? hdCamera.GetJitteredProjectionMatrix(matrix4x2) : matrix4x2);
				m_LightListProjMatrices[i] = matrix4x2 * s_FlipMatrixLHSRHS;
				Matrix4x4 matrix4x3 = matrix4x * m_LightListProjMatrices[i];
				Matrix4x4 inverse = matrix4x3.inverse;
				for (int j = 0; j < 16; j++)
				{
					constantBuffer.g_mScrProjectionArr[i * 16 + j] = matrix4x3[j];
					constantBuffer.g_mInvScrProjectionArr[i * 16 + j] = inverse[j];
				}
			}
			for (int k = 0; k < hdCamera.viewCount; k++)
			{
				matrix4x.SetRow(0, new Vector4(1f, 0f, 0f, 0f));
				matrix4x.SetRow(1, new Vector4(0f, 1f, 0f, 0f));
				matrix4x.SetRow(2, new Vector4(0f, 0f, 0.5f, 0.5f));
				matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
				Matrix4x4 matrix4x4 = matrix4x * m_LightListProjMatrices[k];
				Matrix4x4 inverse2 = matrix4x4.inverse;
				for (int l = 0; l < 16; l++)
				{
					constantBuffer.g_mProjectionArr[k * 16 + l] = matrix4x4[l];
					constantBuffer.g_mInvProjectionArr[k * 16 + l] = inverse2[l];
				}
			}
			Math.Min(DecalSystem.m_DecalDatasCount, m_MaxDecalsOnScreen);
			constantBuffer.g_iNrVisibLights = totalLightCount;
			constantBuffer.g_screenSize = hdCamera.screenSize;
			constantBuffer.g_viDimensions = new Vector2Int((int)hdCamera.screenSize.x, (int)hdCamera.screenSize.y);
			constantBuffer.g_isOrthographic = (camera.orthographic ? 1u : 0u);
			constantBuffer.g_BaseFeatureFlags = 0u;
			constantBuffer.g_iNumSamplesMSAA = (int)hdCamera.msaaSamples;
			constantBuffer._EnvLightIndexShift = (uint)m_GpuLightsBuilder.lightsCount;
			constantBuffer._DecalIndexShift = (uint)(m_GpuLightsBuilder.lightsCount + m_lightList.envLights.Count);
			passData.lightListCB = constantBuffer;
			passData.totalLightCount = totalLightCount;
			passData.runLightList = passData.totalLightCount > 0;
			passData.clearLightLists = false;
			if (hdCamera.xr.enabled)
			{
				passData.runLightList = true;
			}
			else if (!passData.runLightList && !tileAndClusterData.listsAreClear)
			{
				passData.clearLightLists = true;
				tileAndClusterData.listsAreClear = true;
			}
			else if (passData.runLightList)
			{
				tileAndClusterData.listsAreClear = false;
			}
			passData.viewCount = hdCamera.viewCount;
			passData.enableFeatureVariants = GetFeatureVariantsEnabled(hdCamera.frameSettings) && tileAndClusterData.hasTileBuffers;
			passData.computeMaterialVariants = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ComputeMaterialVariants);
			passData.computeLightVariants = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ComputeLightVariants);
			passData.directionalLightCount = m_GpuLightsBuilder.directionalLightCount;
			passData.canClearLightList = m_GpuLightsBuilder != null && m_lightList != null;
			passData.skyEnabled = m_SkyManager.IsLightingSkyValid(hdCamera);
			passData.useComputeAsPixel = DeferredUseComputeAsPixel(hdCamera.frameSettings);
			bool flag = GeometryUtils.IsProjectionMatrixOblique(m_LightListProjMatrices[0]);
			passData.clearLightListCS = defaultResources.shaders.clearLightListsCS;
			passData.clearLightListKernel = passData.clearLightListCS.FindKernel("ClearList");
			passData.screenSpaceAABBShader = buildScreenAABBShader;
			passData.screenSpaceAABBKernel = 0;
			passData.runBigTilePrepass = hdCamera.frameSettings.IsEnabled(FrameSettingsField.BigTilePrepass);
			passData.bigTilePrepassShader = buildPerBigTileLightListShader;
			passData.bigTilePrepassKernel = s_GenListPerBigTileKernel;
			passData.numBigTilesX = (num + 63) / 64;
			passData.numBigTilesY = (num2 + 63) / 64;
			passData.runFPTL = hdCamera.frameSettings.fptl && tileAndClusterData.hasTileBuffers;
			passData.buildPerTileLightListShader = buildPerTileLightListShader;
			passData.buildPerTileLightListShader.shaderKeywords = null;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.BigTilePrepass))
			{
				passData.buildPerTileLightListShader.EnableKeyword("USE_TWO_PASS_TILED_LIGHTING");
			}
			if (flag)
			{
				passData.buildPerTileLightListShader.EnableKeyword("USE_OBLIQUE_MODE");
			}
			if (GetFeatureVariantsEnabled(hdCamera.frameSettings))
			{
				passData.buildPerTileLightListShader.EnableKeyword("USE_FEATURE_FLAGS");
			}
			passData.buildPerTileLightListKernel = s_GenListPerTileKernel;
			passData.numTilesFPTLX = GetNumTileFtplX(hdCamera);
			passData.numTilesFPTLY = GetNumTileFtplY(hdCamera);
			passData.numTilesFPTL = passData.numTilesFPTLX * passData.numTilesFPTLY;
			bool msaaEnabled = hdCamera.msaaEnabled;
			ClusterPrepassSource clusterPrepassSource = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.BigTilePrepass) ? ClusterPrepassSource.BigTile : ClusterPrepassSource.None);
			ClusterDepthSource clusterDepthSource = ClusterDepthSource.NoDepth;
			if (tileAndClusterData.clusterNeedsDepth)
			{
				clusterDepthSource = ((!msaaEnabled) ? ClusterDepthSource.Depth : ClusterDepthSource.MSAA_Depth);
			}
			passData.buildPerVoxelLightListShader = buildPerVoxelLightListShader;
			passData.clearClusterAtomicIndexShader = clearClusterAtomicIndexShader;
			passData.buildPerVoxelLightListKernel = (flag ? s_ClusterObliqueKernels[(int)clusterPrepassSource, (int)clusterDepthSource] : s_ClusterKernels[(int)clusterPrepassSource, (int)clusterDepthSource]);
			passData.numTilesClusterX = GetNumTileClusteredX(hdCamera);
			passData.numTilesClusterY = GetNumTileClusteredY(hdCamera);
			passData.clusterNeedsDepth = tileAndClusterData.clusterNeedsDepth;
			passData.buildMaterialFlagsShader = buildMaterialFlagsShader;
			passData.clearDispatchIndirectShader = clearDispatchIndirectShader;
			passData.buildDispatchIndirectShader = buildDispatchIndirectShader;
			passData.buildDispatchIndirectShader.shaderKeywords = null;
			if (passData.useComputeAsPixel)
			{
				passData.buildDispatchIndirectShader.EnableKeyword("IS_DRAWPROCEDURALINDIRECT");
			}
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				passData.depthBuffer = builder.ReadTexture(in depthStencilBuffer);
				passData.stencilTexture = builder.ReadTexture(in stencilBufferCopy);
			}
			else
			{
				TextureHandle input = renderGraph.defaultResources.blackTextureXR;
				passData.depthBuffer = builder.ReadTexture(in input);
				input = renderGraph.defaultResources.blackTextureXR;
				passData.stencilTexture = builder.ReadTexture(in input);
			}
			if (passData.computeMaterialVariants && passData.enableFeatureVariants)
			{
				for (int m = 0; m < gBuffer.gBufferCount; m++)
				{
					passData.gBuffer[m] = builder.ReadTexture(in gBuffer.mrt[m]);
				}
				for (int n = gBuffer.gBufferCount; n < 7; n++)
				{
					passData.gBuffer[n] = renderGraph.defaultResources.blackTextureXR;
				}
				passData.gBufferCount = 7;
			}
			ComputeBufferHandle input2 = renderGraph.ImportComputeBuffer(tileAndClusterData.convexBoundsBuffer);
			passData.convexBoundsBuffer = builder.ReadComputeBuffer(in input2);
			input2 = renderGraph.ImportComputeBuffer(tileAndClusterData.lightVolumeDataBuffer);
			passData.lightVolumeDataBuffer = builder.ReadComputeBuffer(in input2);
			ComputeBufferDesc desc = new ComputeBufferDesc(1, 4)
			{
				name = "LightListAtomic"
			};
			passData.globalLightListAtomic = builder.CreateTransientComputeBuffer(in desc);
			desc = new ComputeBufferDesc(m_MaxViewCount * 2 * tileAndClusterData.maxLightCount, 16)
			{
				name = "AABBBoundBuffer"
			};
			passData.AABBBoundsBuffer = builder.CreateTransientComputeBuffer(in desc);
			int num3 = (m_MaxCameraWidth + LightDefinitions.s_TileSizeFptl - 1) / LightDefinitions.s_TileSizeFptl;
			int num4 = (m_MaxCameraHeight + LightDefinitions.s_TileSizeFptl - 1) / LightDefinitions.s_TileSizeFptl;
			int num5 = num3 * num4 * m_MaxViewCount;
			if (tileAndClusterData.hasTileBuffers)
			{
				ref BuildGPULightListOutput output = ref passData.output;
				desc = new ComputeBufferDesc(4 * InternalLightCullingDefs.s_LightDwordPerFptlTile * num5, 4)
				{
					name = "LightList"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output.lightList = builder.WriteComputeBuffer(in input2);
				ref BuildGPULightListOutput output2 = ref passData.output;
				desc = new ComputeBufferDesc(LightDefinitions.s_NumFeatureVariants * num5, 4)
				{
					name = "TileList"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output2.tileList = builder.WriteComputeBuffer(in input2);
				ref BuildGPULightListOutput output3 = ref passData.output;
				desc = new ComputeBufferDesc(num5, 4)
				{
					name = "TileFeatureFlags"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output3.tileFeatureFlags = builder.WriteComputeBuffer(in input2);
				ref BuildGPULightListOutput output4 = ref passData.output;
				desc = new ComputeBufferDesc(m_MaxViewCount * LightDefinitions.s_NumFeatureVariants * 4, 4, ComputeBufferType.DrawIndirect)
				{
					name = "DispatchIndirectBuffer"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output4.dispatchIndirectBuffer = builder.WriteComputeBuffer(in input2);
			}
			if (passData.runBigTilePrepass)
			{
				int num6 = (m_MaxCameraWidth + 63) / 64;
				int num7 = (m_MaxCameraHeight + 63) / 64;
				int num8 = num6 * num7 * m_MaxViewCount;
				ref BuildGPULightListOutput output5 = ref passData.output;
				desc = new ComputeBufferDesc(InternalLightCullingDefs.s_MaxNrBigTileLightsPlusOne * num8, 4)
				{
					name = "BigTiles"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output5.bigTileLightList = builder.WriteComputeBuffer(in input2);
			}
			int num9 = (m_MaxCameraWidth + LightDefinitions.s_TileSizeClustered - 1) / LightDefinitions.s_TileSizeClustered;
			int num10 = (m_MaxCameraHeight + LightDefinitions.s_TileSizeClustered - 1) / LightDefinitions.s_TileSizeClustered;
			int num11 = num9 * num10 * m_MaxViewCount;
			ref BuildGPULightListOutput output6 = ref passData.output;
			desc = new ComputeBufferDesc(256 * num11, 4)
			{
				name = "PerVoxelOffset"
			};
			input2 = renderGraph.CreateComputeBuffer(in desc);
			output6.perVoxelOffset = builder.WriteComputeBuffer(in input2);
			ref BuildGPULightListOutput output7 = ref passData.output;
			desc = new ComputeBufferDesc(NumLightIndicesPerClusteredTile() * num11, 4)
			{
				name = "PerVoxelLightList"
			};
			input2 = renderGraph.CreateComputeBuffer(in desc);
			output7.perVoxelLightLists = builder.WriteComputeBuffer(in input2);
			if (tileAndClusterData.clusterNeedsDepth)
			{
				ref BuildGPULightListOutput output8 = ref passData.output;
				desc = new ComputeBufferDesc(num11, 4)
				{
					name = "PerTileLogBaseTweak"
				};
				input2 = renderGraph.CreateComputeBuffer(in desc);
				output8.perTileLogBaseTweak = builder.WriteComputeBuffer(in input2);
			}
		}

		private BuildGPULightListOutput BuildGPULightList(RenderGraph renderGraph, HDCamera hdCamera, TileAndClusterData tileAndClusterData, int totalLightCount, ref ShaderVariablesLightList constantBuffer, TextureHandle depthStencilBuffer, TextureHandle stencilBufferCopy, GBufferOutput gBuffer)
		{
			BuildGPULightListPassData passData;
			using RenderGraphBuilder builder = renderGraph.AddRenderPass<BuildGPULightListPassData>("Build Light List", out passData, ProfilingSampler.Get(HDProfileId.BuildLightList));
			builder.EnableAsyncCompute(hdCamera.frameSettings.BuildLightListRunsAsync());
			PrepareBuildGPULightListPassData(renderGraph, builder, hdCamera, tileAndClusterData, ref constantBuffer, totalLightCount, depthStencilBuffer, stencilBufferCopy, gBuffer, passData);
			builder.SetRenderFunc(delegate(BuildGPULightListPassData data, RenderGraphContext context)
			{
				bool tileFlagsWritten = false;
				ClearLightLists(data, context.cmd);
				GenerateLightsScreenSpaceAABBs(data, context.cmd);
				BigTilePrepass(data, context.cmd);
				BuildPerTileLightList(data, ref tileFlagsWritten, context.cmd);
				VoxelLightListGeneration(data, context.cmd);
				BuildDispatchIndirectArguments(data, tileFlagsWritten, context.cmd);
			});
			return passData.output;
		}

		private void PushGlobalCameraParams(RenderGraph renderGraph, HDCamera hdCamera)
		{
			PushGlobalCameraParamPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PushGlobalCameraParamPassData>("Push Global Camera Parameters", out passData);
			passData.hdCamera = hdCamera;
			passData.globalCB = m_ShaderVariablesGlobalCB;
			passData.xrCB = m_ShaderVariablesXRCB;
			renderGraphBuilder.SetRenderFunc(delegate(PushGlobalCameraParamPassData data, RenderGraphContext context)
			{
				data.hdCamera.UpdateShaderVariablesGlobalCB(ref data.globalCB);
				ConstantBuffer.PushGlobal(context.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
				data.hdCamera.UpdateShaderVariablesXRCB(ref data.xrCB);
				ConstantBuffer.PushGlobal(context.cmd, in data.xrCB, HDShaderIDs._ShaderVariablesXR);
			});
		}

		internal ShadowResult RenderShadows(RenderGraph renderGraph, HDCamera hdCamera, CullingResults cullResults, ref ShadowResult result)
		{
			m_ShadowManager.RenderShadows(m_RenderGraph, in m_ShaderVariablesGlobalCB, hdCamera, cullResults, ref result);
			PushGlobalCameraParams(renderGraph, hdCamera);
			return result;
		}

		private TextureHandle CreateDiffuseLightingBuffer(RenderGraph renderGraph, MSAASamples msaaSamples)
		{
			bool flag = msaaSamples != MSAASamples.None;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				enableRandomWrite = !flag,
				bindTextureMS = flag,
				msaaSamples = msaaSamples,
				clearBuffer = true,
				clearColor = Color.clear,
				name = (flag ? "CameraSSSDiffuseLightingMSAA" : "CameraSSSDiffuseLighting")
			};
			return renderGraph.CreateTexture(in desc);
		}

		private static void RenderComputeDeferredLighting(DeferredLightingPassData data, RenderTargetIdentifier[] colorBuffers, CommandBuffer cmd)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.RenderDeferredLightingCompute)))
			{
				data.deferredComputeShader.shaderKeywords = null;
				switch (currentAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.shadowFilteringQuality)
				{
				case HDShadowFilteringQuality.Low:
					data.deferredComputeShader.EnableKeyword("SHADOW_LOW");
					break;
				case HDShadowFilteringQuality.Medium:
					data.deferredComputeShader.EnableKeyword("SHADOW_MEDIUM");
					break;
				case HDShadowFilteringQuality.High:
					data.deferredComputeShader.EnableKeyword("SHADOW_HIGH");
					break;
				default:
					data.deferredComputeShader.EnableKeyword("SHADOW_MEDIUM");
					break;
				}
				switch (currentAsset.currentPlatformRenderPipelineSettings.hdShadowInitParams.areaShadowFilteringQuality)
				{
				case HDAreaShadowFilteringQuality.Medium:
					data.deferredComputeShader.EnableKeyword("AREA_SHADOW_MEDIUM");
					break;
				case HDAreaShadowFilteringQuality.High:
					data.deferredComputeShader.EnableKeyword("AREA_SHADOW_HIGH");
					break;
				default:
					data.deferredComputeShader.EnableKeyword("AREA_SHADOW_MEDIUM");
					break;
				}
				if (data.enableShadowMasks)
				{
					data.deferredComputeShader.EnableKeyword("SHADOWS_SHADOWMASK");
				}
				if (data.enableFeatureVariants)
				{
					for (int i = 0; i < data.numVariants; i++)
					{
						int kernelIndex = s_shadeOpaqueIndirectFptlKernels[i];
						cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex, HDShaderIDs._CameraDepthTexture, data.depthTexture);
						cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex, HDShaderIDs.specularLightingUAV, colorBuffers[0]);
						cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex, HDShaderIDs.diffuseLightingUAV, colorBuffers[1]);
						cmd.SetComputeBufferParam(data.deferredComputeShader, kernelIndex, HDShaderIDs.g_vLightListTile, data.lightListBuffer);
						cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex, HDShaderIDs._StencilTexture, data.depthBuffer, 0, RenderTextureSubElement.Stencil);
						cmd.SetComputeBufferParam(data.deferredComputeShader, kernelIndex, HDShaderIDs.g_TileFeatureFlags, data.tileFeatureFlagsBuffer);
						cmd.SetComputeIntParam(data.deferredComputeShader, HDShaderIDs.g_TileListOffset, i * data.numTiles * data.viewCount);
						cmd.SetComputeBufferParam(data.deferredComputeShader, kernelIndex, HDShaderIDs.g_TileList, data.tileListBuffer);
						cmd.DispatchCompute(data.deferredComputeShader, kernelIndex, data.dispatchIndirectBuffer, (uint)(i * 3 * 4));
					}
				}
				else
				{
					int kernelIndex2 = (data.debugDisplaySettings.IsDebugDisplayEnabled() ? s_shadeOpaqueDirectFptlDebugDisplayKernel : s_shadeOpaqueDirectFptlKernel);
					cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex2, HDShaderIDs._CameraDepthTexture, data.depthTexture);
					cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex2, HDShaderIDs.specularLightingUAV, colorBuffers[0]);
					cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex2, HDShaderIDs.diffuseLightingUAV, colorBuffers[1]);
					cmd.SetComputeBufferParam(data.deferredComputeShader, kernelIndex2, HDShaderIDs.g_vLightListTile, data.lightListBuffer);
					cmd.SetComputeTextureParam(data.deferredComputeShader, kernelIndex2, HDShaderIDs._StencilTexture, data.depthBuffer, 0, RenderTextureSubElement.Stencil);
					cmd.DispatchCompute(data.deferredComputeShader, kernelIndex2, data.numTilesX * 2, data.numTilesY * 2, data.viewCount);
				}
			}
		}

		private static void RenderComputeAsPixelDeferredLighting(DeferredLightingPassData data, RenderTargetIdentifier[] colorBuffers, Material deferredMat, bool outputSplitLighting, CommandBuffer cmd)
		{
			CoreUtils.SetKeyword(cmd, "OUTPUT_SPLIT_LIGHTING", outputSplitLighting);
			CoreUtils.SetKeyword(cmd, "SHADOWS_SHADOWMASK", data.enableShadowMasks);
			if (data.enableFeatureVariants)
			{
				if (outputSplitLighting)
				{
					CoreUtils.SetRenderTarget(cmd, colorBuffers, data.depthBuffer);
				}
				else
				{
					CoreUtils.SetRenderTarget(cmd, colorBuffers[0], data.depthBuffer);
				}
				for (int i = 0; i < data.numVariants; i++)
				{
					cmd.SetGlobalInt(HDShaderIDs.g_TileListOffset, i * data.numTiles);
					cmd.EnableShaderKeyword(s_variantNames[i]);
					MeshTopology topology = MeshTopology.Triangles;
					cmd.DrawProceduralIndirect(Matrix4x4.identity, deferredMat, 0, topology, data.dispatchIndirectBuffer, i * 4 * 4, null);
					cmd.DisableShaderKeyword(s_variantNames[i]);
				}
			}
			else
			{
				CoreUtils.SetKeyword(cmd, "DEBUG_DISPLAY", data.debugDisplaySettings.IsDebugDisplayEnabled());
				if (outputSplitLighting)
				{
					CoreUtils.DrawFullScreen(cmd, deferredMat, colorBuffers, data.depthBuffer, null, 1);
				}
				else
				{
					CoreUtils.DrawFullScreen(cmd, deferredMat, colorBuffers[0], data.depthBuffer, null, 1);
				}
			}
		}

		private static void RenderComputeAsPixelDeferredLighting(DeferredLightingPassData data, RenderTargetIdentifier[] colorBuffers, CommandBuffer cmd)
		{
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.RenderDeferredLightingComputeAsPixel)))
			{
				cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, data.depthTexture);
				cmd.SetGlobalBuffer(HDShaderIDs.g_TileFeatureFlags, data.tileFeatureFlagsBuffer);
				cmd.SetGlobalBuffer(HDShaderIDs.g_TileList, data.tileListBuffer);
				if (data.outputSplitLighting)
				{
					s_DeferredTileSplitLightingMat.SetBuffer(HDShaderIDs.g_vLightListTile, data.lightListBuffer);
					s_DeferredTileRegularLightingMat.SetBuffer(HDShaderIDs.g_vLightListTile, data.lightListBuffer);
					RenderComputeAsPixelDeferredLighting(data, colorBuffers, s_DeferredTileSplitLightingMat, outputSplitLighting: true, cmd);
					RenderComputeAsPixelDeferredLighting(data, colorBuffers, s_DeferredTileRegularLightingMat, outputSplitLighting: false, cmd);
				}
				else
				{
					s_DeferredTileMat.SetBuffer(HDShaderIDs.g_vLightListTile, data.lightListBuffer);
					RenderComputeAsPixelDeferredLighting(data, colorBuffers, s_DeferredTileMat, outputSplitLighting: false, cmd);
				}
			}
		}

		private static void RenderPixelDeferredLighting(DeferredLightingPassData data, RenderTargetIdentifier[] colorBuffers, CommandBuffer cmd)
		{
			if (data.outputSplitLighting)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.RenderDeferredLightingSinglePassMRT)))
				{
					CoreUtils.DrawFullScreen(cmd, data.splitLightingMat, colorBuffers, data.depthBuffer);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.RenderDeferredLightingSinglePass)))
			{
				Material regularLightingMat = data.regularLightingMat;
				if (!data.outputSplitLighting)
				{
					regularLightingMat.SetInt(HDShaderIDs._StencilRef, 0);
					regularLightingMat.SetInt(HDShaderIDs._StencilMask, 6);
					regularLightingMat.SetInt(HDShaderIDs._StencilCmp, 6);
				}
				else
				{
					regularLightingMat.SetInt(HDShaderIDs._StencilRef, 2);
					regularLightingMat.SetInt(HDShaderIDs._StencilMask, 2);
					regularLightingMat.SetInt(HDShaderIDs._StencilCmp, 3);
				}
				regularLightingMat.SetBuffer(HDShaderIDs.g_vLightListTile, data.lightListBuffer);
				CoreUtils.DrawFullScreen(cmd, regularLightingMat, colorBuffers[0], data.depthBuffer);
			}
		}

		private LightingOutput RenderDeferredLighting(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthStencilBuffer, TextureHandle depthPyramidTexture, in LightingBuffers lightingBuffers, in GBufferOutput gbuffer, in ShadowResult shadowResult, in BuildGPULightListOutput lightLists)
		{
			if (hdCamera.frameSettings.litShaderMode != LitShaderMode.Deferred || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return default(LightingOutput);
			}
			DeferredLightingPassData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<DeferredLightingPassData>("Deferred Lighting", out passData);
			try
			{
				bool flag = CoreUtils.IsSceneLightingDisabled(hdCamera.camera) || m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled();
				int actualWidth = hdCamera.actualWidth;
				int actualHeight = hdCamera.actualHeight;
				passData.numTilesX = (actualWidth + 15) / 16;
				passData.numTilesY = (actualHeight + 15) / 16;
				passData.numTiles = passData.numTilesX * passData.numTilesY;
				passData.enableTile = hdCamera.frameSettings.IsEnabled(FrameSettingsField.DeferredTile);
				passData.outputSplitLighting = hdCamera.frameSettings.IsEnabled(FrameSettingsField.SubsurfaceScattering);
				passData.useComputeLightingEvaluation = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ComputeLightEvaluation);
				passData.enableFeatureVariants = GetFeatureVariantsEnabled(hdCamera.frameSettings) && !flag;
				passData.enableShadowMasks = m_EnableBakeShadowMask;
				passData.numVariants = LightDefinitions.s_NumFeatureVariants;
				passData.debugDisplaySettings = m_CurrentDebugDisplaySettings;
				passData.deferredComputeShader = deferredComputeShader;
				passData.viewCount = hdCamera.viewCount;
				passData.splitLightingMat = GetDeferredLightingMaterial(outputSplitLighting: true, passData.enableShadowMasks, flag);
				passData.regularLightingMat = GetDeferredLightingMaterial(outputSplitLighting: false, passData.enableShadowMasks, flag);
				passData.colorBuffer = builder.WriteTexture(in colorBuffer);
				if (passData.outputSplitLighting)
				{
					passData.sssDiffuseLightingBuffer = builder.WriteTexture(in lightingBuffers.diffuseLightingBuffer);
				}
				else
				{
					DeferredLightingPassData deferredLightingPassData = passData;
					TextureDesc desc = new TextureDesc(1, 1, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
						enableRandomWrite = true
					};
					deferredLightingPassData.sssDiffuseLightingBuffer = builder.CreateTransientTexture(in desc);
				}
				passData.depthBuffer = builder.ReadTexture(in depthStencilBuffer);
				passData.depthTexture = builder.ReadTexture(in depthPyramidTexture);
				passData.lightingBuffers = ReadLightingBuffers(in lightingBuffers, builder);
				passData.lightLayersTextureIndex = gbuffer.lightLayersTextureIndex;
				passData.shadowMaskTextureIndex = gbuffer.shadowMaskTextureIndex;
				passData.gbufferCount = gbuffer.gBufferCount;
				for (int i = 0; i < gbuffer.gBufferCount; i++)
				{
					passData.gbuffer[i] = builder.ReadTexture(in gbuffer.mrt[i]);
				}
				HDShadowManager.ReadShadowResult(in shadowResult, builder);
				passData.lightListBuffer = builder.ReadComputeBuffer(in lightLists.lightList);
				passData.tileFeatureFlagsBuffer = builder.ReadComputeBuffer(in lightLists.tileFeatureFlags);
				passData.tileListBuffer = builder.ReadComputeBuffer(in lightLists.tileList);
				passData.dispatchIndirectBuffer = builder.ReadComputeBuffer(in lightLists.dispatchIndirectBuffer);
				LightingOutput result = default(LightingOutput);
				result.colorBuffer = passData.colorBuffer;
				builder.SetRenderFunc(delegate(DeferredLightingPassData data, RenderGraphContext context)
				{
					RenderTargetIdentifier[] tempArray = context.renderGraphPool.GetTempArray<RenderTargetIdentifier>(2);
					tempArray[0] = data.colorBuffer;
					tempArray[1] = data.sssDiffuseLightingBuffer;
					for (int j = 0; j < data.gbufferCount; j++)
					{
						context.cmd.SetGlobalTexture(HDShaderIDs._GBufferTexture[j], data.gbuffer[j]);
					}
					if (data.lightLayersTextureIndex != -1)
					{
						context.cmd.SetGlobalTexture(HDShaderIDs._LightLayersTexture, data.gbuffer[data.lightLayersTextureIndex]);
					}
					else
					{
						context.cmd.SetGlobalTexture(HDShaderIDs._LightLayersTexture, TextureXR.GetWhiteTexture());
					}
					if (data.shadowMaskTextureIndex != -1)
					{
						context.cmd.SetGlobalTexture(HDShaderIDs._ShadowMaskTexture, data.gbuffer[data.shadowMaskTextureIndex]);
					}
					else
					{
						context.cmd.SetGlobalTexture(HDShaderIDs._ShadowMaskTexture, TextureXR.GetWhiteTexture());
					}
					BindGlobalLightingBuffers(in data.lightingBuffers, context.cmd);
					if (data.enableTile)
					{
						if (data.useComputeLightingEvaluation && !k_PreferFragment)
						{
							RenderComputeDeferredLighting(data, tempArray, context.cmd);
						}
						else
						{
							RenderComputeAsPixelDeferredLighting(data, tempArray, context.cmd);
						}
					}
					else
					{
						RenderPixelDeferredLighting(data, tempArray, context.cmd);
					}
				});
				return result;
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private static void ClearColorBuffer2D(RenderSSRPassData data, CommandBuffer cmd, TextureHandle rt, Color clearColor, bool async)
		{
			if (!async)
			{
				CoreUtils.SetRenderTarget(cmd, rt, ClearFlag.Color, clearColor);
				return;
			}
			cmd.SetComputeTextureParam(data.clearBuffer2DCS, data.clearBuffer2DKernel, HDShaderIDs._Buffer2D, data.ssrAccum);
			cmd.SetComputeVectorParam(data.clearBuffer2DCS, HDShaderIDs._ClearValue, clearColor);
			cmd.SetComputeVectorParam(data.clearBuffer2DCS, HDShaderIDs._BufferSize, new Vector4(data.width, data.height, 0f, 0f));
			cmd.DispatchCompute(data.clearBuffer2DCS, data.clearBuffer2DKernel, HDUtils.DivRoundUp(data.width, 8), HDUtils.DivRoundUp(data.height, 8), data.viewCount);
		}

		private void UpdateSSRConstantBuffer(HDCamera hdCamera, ScreenSpaceReflection settings, bool isTransparent, ref ShaderVariablesScreenSpaceReflection cb)
		{
			float nearClipPlane = hdCamera.camera.nearClipPlane;
			float farClipPlane = hdCamera.camera.farClipPlane;
			float value = settings.depthBufferThickness.value;
			cb._SsrThicknessScale = 1f / (1f + value);
			cb._SsrThicknessBias = (0f - nearClipPlane) / (farClipPlane - nearClipPlane) * (value * cb._SsrThicknessScale);
			cb._SsrIterLimit = settings.rayMaxIterations;
			cb._SsrReflectsSky = ((!isTransparent) ? (settings.reflectSky.value ? 1 : 0) : 0);
			cb._SsrStencilBit = 8;
			float num = 1f - settings.smoothnessFadeStart;
			cb._SsrRoughnessFadeEnd = 1f - settings.minSmoothness;
			float num2 = cb._SsrRoughnessFadeEnd - num;
			cb._SsrRoughnessFadeEndTimesRcpLength = ((num2 != 0f) ? (cb._SsrRoughnessFadeEnd * (1f / num2)) : 1f);
			cb._SsrRoughnessFadeRcpLength = ((num2 != 0f) ? (1f / num2) : 0f);
			cb._SsrEdgeFadeRcpLength = Mathf.Min(1f / settings.screenFadeDistance.value, float.MaxValue);
			cb._ColorPyramidUvScaleAndLimitPrevFrame = HDUtils.ComputeViewportScaleAndLimit(hdCamera.historyRTHandleProperties.previousViewportSize, hdCamera.historyRTHandleProperties.previousRenderTargetSize);
			cb._SsrColorPyramidMaxMip = hdCamera.colorPyramidHistoryMipCount - 1;
			cb._SsrDepthPyramidMaxMip = hdCamera.depthBufferMipChainInfo.mipLevelCount - 1;
			if (hdCamera.isFirstFrame || hdCamera.cameraFrameCount <= 3)
			{
				cb._SsrAccumulationAmount = 1f;
			}
			else
			{
				cb._SsrAccumulationAmount = Mathf.Pow(2f, Mathf.Lerp(0f, -7f, settings.accumulationFactor.value));
			}
			if (settings.enableWorldSpeedRejection.value && !settings.speedSmoothReject.value)
			{
				cb._SsrPBRSpeedRejection = Mathf.Clamp01(1f - settings.speedRejectionParam.value);
			}
			else
			{
				cb._SsrPBRSpeedRejection = Mathf.Clamp01(settings.speedRejectionParam.value);
			}
			cb._SsrPBRBias = settings.biasFactor.value;
			cb._SsrPRBSpeedRejectionScalerFactor = Mathf.Pow(settings.speedRejectionScalerFactor.value * 0.1f, 2f);
		}

		private TextureHandle RenderSSR(RenderGraph renderGraph, HDCamera hdCamera, ref PrepassOutput prepassOutput, TextureHandle clearCoatMask, TextureHandle rayCountTexture, Texture skyTexture, bool transparent)
		{
			if (!hdCamera.IsSSREnabled(transparent))
			{
				return renderGraph.defaultResources.blackTextureXR;
			}
			bool debugDisplaySpeed = m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.ScreenSpaceReflectionSpeedRejection;
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			TextureHandle textureHandle;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && ScreenSpaceReflection.RayTracingActive(component) && GetRayTracingState() && GetRayTracingClusterState())
			{
				textureHandle = RenderRayTracedReflections(renderGraph, hdCamera, in prepassOutput, clearCoatMask, skyTexture, rayCountTexture, m_ShaderVariablesRayTracingCB, transparent);
			}
			else
			{
				if (transparent)
				{
					BuildCoarseStencilAndResolveIfNeeded(renderGraph, hdCamera, resolveOnly: true, ref prepassOutput);
				}
				RTHandle previousFrameRT = hdCamera.GetPreviousFrameRT(0);
				if (previousFrameRT == null)
				{
					return renderGraph.defaultResources.blackTextureXR;
				}
				RenderSSRPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderSSRPassData>("Render SSR", out passData);
				try
				{
					bool flag = hdCamera.frameSettings.SSRRunsAsync() && !transparent;
					renderGraphBuilder.EnableAsyncCompute(flag);
					hdCamera.AllocateScreenSpaceAccumulationHistoryBuffer(1f);
					bool flag2 = !transparent && component.usedAlgorithm.value == ScreenSpaceReflectionAlgorithm.PBRAccumulation;
					TextureHandle input = renderGraph.ImportTexture(previousFrameRT);
					ScreenSpaceReflection component2 = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
					UpdateSSRConstantBuffer(hdCamera, component2, transparent, ref passData.cb);
					passData.hdCamera = hdCamera;
					passData.blueNoise = GetBlueNoiseManager();
					passData.ssrCS = m_ScreenSpaceReflectionsCS;
					passData.tracingKernel = m_SsrTracingKernel;
					passData.reprojectionKernel = m_SsrReprojectionKernel;
					passData.accumulateNoWorldSpeedRejectionBothKernel = m_SsrAccumulateNoWorldSpeedRejectionBothKernel;
					passData.accumulateNoWorldSpeedRejectionSurfaceKernel = m_SsrAccumulateNoWorldSpeedRejectionSurfaceKernel;
					passData.accumulateNoWorldSpeedRejectionHitKernel = m_SsrAccumulateNoWorldSpeedRejectionHitKernel;
					passData.accumulateHardThresholdSpeedRejectionBothKernel = m_SsrAccumulateHardThresholdSpeedRejectionBothKernel;
					passData.accumulateHardThresholdSpeedRejectionSurfaceKernel = m_SsrAccumulateHardThresholdSpeedRejectionSurfaceKernel;
					passData.accumulateHardThresholdSpeedRejectionHitKernel = m_SsrAccumulateHardThresholdSpeedRejectionHitKernel;
					passData.accumulateSmoothSpeedRejectionBothKernel = m_SsrAccumulateSmoothSpeedRejectionBothKernel;
					passData.accumulateSmoothSpeedRejectionSurfaceKernel = m_SsrAccumulateSmoothSpeedRejectionSurfaceKernel;
					passData.accumulateSmoothSpeedRejectionHitKernel = m_SsrAccumulateSmoothSpeedRejectionHitKernel;
					passData.accumulateNoWorldSpeedRejectionBothDebugKernel = m_SsrAccumulateNoWorldSpeedRejectionBothDebugKernel;
					passData.accumulateNoWorldSpeedRejectionSurfaceDebugKernel = m_SsrAccumulateNoWorldSpeedRejectionSurfaceDebugKernel;
					passData.accumulateNoWorldSpeedRejectionHitDebugKernel = m_SsrAccumulateNoWorldSpeedRejectionHitDebugKernel;
					passData.accumulateHardThresholdSpeedRejectionBothDebugKernel = m_SsrAccumulateHardThresholdSpeedRejectionBothDebugKernel;
					passData.accumulateHardThresholdSpeedRejectionSurfaceDebugKernel = m_SsrAccumulateHardThresholdSpeedRejectionSurfaceDebugKernel;
					passData.accumulateHardThresholdSpeedRejectionHitDebugKernel = m_SsrAccumulateHardThresholdSpeedRejectionHitDebugKernel;
					passData.accumulateSmoothSpeedRejectionBothDebugKernel = m_SsrAccumulateSmoothSpeedRejectionBothDebugKernel;
					passData.accumulateSmoothSpeedRejectionSurfaceDebugKernel = m_SsrAccumulateSmoothSpeedRejectionSurfaceDebugKernel;
					passData.accumulateSmoothSpeedRejectionHitDebugKernel = m_SsrAccumulateSmoothSpeedRejectionHitDebugKernel;
					passData.transparentSSR = transparent;
					passData.usePBRAlgo = flag2;
					passData.width = hdCamera.actualWidth;
					passData.height = hdCamera.actualHeight;
					passData.viewCount = hdCamera.viewCount;
					passData.offsetBufferData = hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer);
					passData.accumNeedClear = flag2;
					passData.previousAccumNeedClear = flag2 && (hdCamera.currentSSRAlgorithm == ScreenSpaceReflectionAlgorithm.Approximation || hdCamera.isFirstFrame || hdCamera.resetPostProcessingHistory);
					hdCamera.currentSSRAlgorithm = component2.usedAlgorithm.value;
					passData.validColorPyramid = hdCamera.colorPyramidHistoryValidFrames > 1;
					passData.depthBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.depthBuffer);
					passData.depthPyramid = renderGraphBuilder.ReadTexture(in prepassOutput.depthPyramidTexture);
					passData.colorPyramid = renderGraphBuilder.ReadTexture(in input);
					passData.stencilBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.stencilBuffer);
					passData.clearCoatMask = renderGraphBuilder.ReadTexture(in clearCoatMask);
					passData.coarseStencilBuffer = renderGraphBuilder.ReadComputeBuffer(in prepassOutput.coarseStencilBuffer);
					passData.normalBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.resolvedNormalBuffer);
					passData.motionVectorsBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.resolvedMotionVectorsBuffer);
					if (hdCamera.isFirstFrame || hdCamera.cameraFrameCount <= 2)
					{
						passData.frameIndex = 1f;
					}
					else
					{
						passData.frameIndex = hdCamera.cameraFrameCount;
					}
					passData.roughnessBiasFactor = component2.biasFactor.value;
					passData.debugDisplaySpeed = debugDisplaySpeed;
					passData.speedRejection = component2.speedRejectionParam.value;
					passData.speedRejectionFactor = component2.speedRejectionScalerFactor.value;
					passData.enableWorldSmoothRejection = component2.enableWorldSpeedRejection.value;
					passData.smoothSpeedRejection = component2.speedSmoothReject.value;
					passData.motionVectorFromSurface = component2.speedSurfaceOnly.value;
					passData.motionVectorFromHit = component2.speedTargetOnly.value;
					passData.clearBuffer2DCS = m_ClearBuffer2DCS;
					passData.clearBuffer2DKernel = m_ClearBuffer2DKernel;
					passData.useAsync = flag;
					RenderSSRPassData renderSSRPassData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R16G16_UNorm,
						clearBuffer = true,
						clearColor = Color.clear,
						enableRandomWrite = true,
						name = (transparent ? "SSR_Hit_Point_Texture_Trans" : "SSR_Hit_Point_Texture")
					};
					renderSSRPassData.hitPointsTexture = renderGraphBuilder.CreateTransientTexture(in desc);
					if (flag2)
					{
						RenderSSRPassData renderSSRPassData2 = passData;
						TextureHandle input2 = renderGraph.ImportTexture(hdCamera.GetCurrentFrameRT(21));
						renderSSRPassData2.ssrAccum = renderGraphBuilder.WriteTexture(in input2);
						RenderSSRPassData renderSSRPassData3 = passData;
						input2 = renderGraph.ImportTexture(hdCamera.GetPreviousFrameRT(21));
						renderSSRPassData3.ssrAccumPrev = renderGraphBuilder.WriteTexture(in input2);
						RenderSSRPassData renderSSRPassData4 = passData;
						desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
						{
							colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
							clearBuffer = true,
							clearColor = Color.clear,
							enableRandomWrite = true,
							name = "SSR_Lighting_Texture"
						};
						renderSSRPassData4.lightingTexture = renderGraphBuilder.CreateTransientTexture(in desc);
					}
					else
					{
						RenderSSRPassData renderSSRPassData5 = passData;
						desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
						{
							colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
							clearBuffer = true,
							clearColor = Color.clear,
							enableRandomWrite = true,
							name = "SSR_Lighting_Texture"
						};
						TextureHandle input2 = renderGraph.CreateTexture(in desc);
						renderSSRPassData5.lightingTexture = renderGraphBuilder.WriteTexture(in input2);
					}
					renderGraphBuilder.SetRenderFunc(delegate(RenderSSRPassData data, RenderGraphContext ctx)
					{
						ComputeShader ssrCS = data.ssrCS;
						if (!data.usePBRAlgo)
						{
							ctx.cmd.EnableShaderKeyword("SSR_APPROX");
						}
						else
						{
							if (data.accumNeedClear || data.debugDisplaySpeed)
							{
								ClearColorBuffer2D(data, ctx.cmd, data.ssrAccum, Color.clear, data.useAsync);
							}
							if (data.previousAccumNeedClear || data.debugDisplaySpeed)
							{
								ClearColorBuffer2D(data, ctx.cmd, data.ssrAccumPrev, Color.clear, data.useAsync);
							}
							ctx.cmd.DisableShaderKeyword("SSR_APPROX");
						}
						if (data.transparentSSR)
						{
							ctx.cmd.EnableShaderKeyword("DEPTH_SOURCE_NOT_FROM_MIP_CHAIN");
						}
						else
						{
							ctx.cmd.DisableShaderKeyword("DEPTH_SOURCE_NOT_FROM_MIP_CHAIN");
						}
						using (new ProfilingScope(ctx.cmd, ProfilingSampler.Get(HDProfileId.SsrTracing)))
						{
							ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._CameraDepthTexture, data.depthPyramid);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMask);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._SsrHitPointTexture, data.hitPointsTexture);
							RTHandle rTHandle = data.stencilBuffer;
							if (rTHandle.rt.stencilFormat == GraphicsFormat.None)
							{
								ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._StencilTexture, rTHandle);
							}
							else
							{
								ctx.cmd.SetComputeTextureParam(ssrCS, data.tracingKernel, HDShaderIDs._StencilTexture, rTHandle, 0, RenderTextureSubElement.Stencil);
							}
							ctx.cmd.SetComputeBufferParam(ssrCS, data.tracingKernel, HDShaderIDs._CoarseStencilBuffer, data.coarseStencilBuffer);
							ctx.cmd.SetComputeBufferParam(ssrCS, data.tracingKernel, HDShaderIDs._DepthPyramidMipLevelOffsets, data.offsetBufferData);
							ctx.cmd.SetComputeFloatParam(ssrCS, HDShaderIDs._SsrPBRBias, data.roughnessBiasFactor);
							data.blueNoise.BindDitheredRNGData1SPP(ctx.cmd);
							ConstantBuffer.Push(ctx.cmd, in data.cb, ssrCS, HDShaderIDs._ShaderVariablesScreenSpaceReflection);
							ctx.cmd.DispatchCompute(ssrCS, data.tracingKernel, HDUtils.DivRoundUp(data.width, 8), HDUtils.DivRoundUp(data.height, 8), data.viewCount);
						}
						using (new ProfilingScope(ctx.cmd, ProfilingSampler.Get(HDProfileId.SsrReprojection)))
						{
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._CameraDepthTexture, data.depthPyramid);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._ColorPyramidTexture, data.colorPyramid);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._SsrHitPointTexture, data.hitPointsTexture);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._SSRAccumTexture, data.usePBRAlgo ? data.ssrAccum : data.lightingTexture);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMask);
							ctx.cmd.SetComputeTextureParam(ssrCS, data.reprojectionKernel, HDShaderIDs._CameraMotionVectorsTexture, data.motionVectorsBuffer);
							ConstantBuffer.Push(ctx.cmd, in data.cb, ssrCS, HDShaderIDs._ShaderVariablesScreenSpaceReflection);
							ctx.cmd.DispatchCompute(ssrCS, data.reprojectionKernel, HDUtils.DivRoundUp(data.width, 8), HDUtils.DivRoundUp(data.height, 8), data.viewCount);
						}
						if (data.usePBRAlgo)
						{
							if (data.validColorPyramid)
							{
								using (new ProfilingScope(ctx.cmd, ProfilingSampler.Get(HDProfileId.SsrAccumulate)))
								{
									int kernelIndex = (data.debugDisplaySpeed ? ((!data.enableWorldSmoothRejection) ? ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateNoWorldSpeedRejectionBothDebugKernel : ((!data.motionVectorFromHit) ? data.accumulateNoWorldSpeedRejectionSurfaceDebugKernel : data.accumulateNoWorldSpeedRejectionHitDebugKernel)) : (data.smoothSpeedRejection ? ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateSmoothSpeedRejectionBothDebugKernel : ((!data.motionVectorFromHit) ? data.accumulateSmoothSpeedRejectionSurfaceDebugKernel : data.accumulateSmoothSpeedRejectionHitDebugKernel)) : ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateHardThresholdSpeedRejectionBothDebugKernel : ((!data.motionVectorFromHit) ? data.accumulateHardThresholdSpeedRejectionSurfaceDebugKernel : data.accumulateHardThresholdSpeedRejectionHitDebugKernel)))) : ((!data.enableWorldSmoothRejection) ? ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateNoWorldSpeedRejectionBothKernel : ((!data.motionVectorFromHit) ? data.accumulateNoWorldSpeedRejectionSurfaceKernel : data.accumulateNoWorldSpeedRejectionHitKernel)) : (data.smoothSpeedRejection ? ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateSmoothSpeedRejectionBothKernel : ((!data.motionVectorFromHit) ? data.accumulateSmoothSpeedRejectionSurfaceKernel : data.accumulateSmoothSpeedRejectionHitKernel)) : ((data.motionVectorFromSurface && data.motionVectorFromHit) ? data.accumulateHardThresholdSpeedRejectionBothKernel : ((!data.motionVectorFromHit) ? data.accumulateHardThresholdSpeedRejectionSurfaceKernel : data.accumulateHardThresholdSpeedRejectionHitKernel)))));
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._DepthTexture, data.depthBuffer);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._CameraDepthTexture, data.depthPyramid);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._ColorPyramidTexture, data.colorPyramid);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._SsrHitPointTexture, data.hitPointsTexture);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._SSRAccumTexture, data.ssrAccum);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._SsrLightingTextureRW, data.lightingTexture);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._SsrAccumPrev, data.ssrAccumPrev);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMask);
									ctx.cmd.SetComputeTextureParam(ssrCS, kernelIndex, HDShaderIDs._CameraMotionVectorsTexture, data.motionVectorsBuffer);
									ctx.cmd.SetComputeFloatParam(ssrCS, HDShaderIDs._SsrFrameIndex, data.frameIndex);
									ctx.cmd.SetComputeFloatParam(ssrCS, HDShaderIDs._SsrPBRSpeedRejection, data.speedRejection);
									ctx.cmd.SetComputeFloatParam(ssrCS, HDShaderIDs._SsrPRBSpeedRejectionScalerFactor, data.speedRejectionFactor);
									ConstantBuffer.Push(ctx.cmd, in data.cb, ssrCS, HDShaderIDs._ShaderVariablesScreenSpaceReflection);
									ctx.cmd.DispatchCompute(ssrCS, kernelIndex, HDUtils.DivRoundUp(data.width, 8), HDUtils.DivRoundUp(data.height, 8), data.viewCount);
									return;
								}
							}
							ClearColorBuffer2D(data, ctx.cmd, data.ssrAccum, Color.clear, data.useAsync);
							ClearColorBuffer2D(data, ctx.cmd, data.ssrAccumPrev, Color.clear, data.useAsync);
						}
					});
					if (flag2)
					{
						textureHandle = passData.ssrAccum;
						PushFullScreenDebugTexture(renderGraph, passData.ssrAccum, FullScreenDebugMode.ScreenSpaceReflectionsAccum);
						PushFullScreenDebugTexture(renderGraph, passData.ssrAccumPrev, FullScreenDebugMode.ScreenSpaceReflectionsPrev);
						PushFullScreenDebugTexture(renderGraph, passData.ssrAccum, FullScreenDebugMode.ScreenSpaceReflectionSpeedRejection);
					}
					else
					{
						textureHandle = passData.lightingTexture;
						PushFullScreenDebugTexture(renderGraph, textureHandle, FullScreenDebugMode.ScreenSpaceReflectionSpeedRejection);
					}
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				if (!hdCamera.colorPyramidHistoryIsValid)
				{
					textureHandle = renderGraph.defaultResources.blackTextureXR;
				}
			}
			PushFullScreenDebugTexture(renderGraph, textureHandle, transparent ? FullScreenDebugMode.TransparentScreenSpaceReflections : FullScreenDebugMode.ScreenSpaceReflections);
			return textureHandle;
		}

		private TextureHandle RenderContactShadows(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthTexture, in BuildGPULightListOutput lightLists, int firstMipOffsetY)
		{
			if (!WillRenderContactShadow())
			{
				return renderGraph.defaultResources.blackUIntTextureXR;
			}
			RenderContactShadowPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderContactShadowPassData>("Contact Shadows", out passData);
			TextureHandle contactShadowsTexture;
			try
			{
				renderGraphBuilder.EnableAsyncCompute(hdCamera.frameSettings.ContactShadowsRunsAsync());
				bool clearBuffer = m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.ContactShadows;
				bool msaaEnabled = hdCamera.msaaEnabled;
				passData.contactShadowsCS = contactShadowComputeShader;
				passData.contactShadowsCS.shaderKeywords = null;
				if (msaaEnabled)
				{
					passData.contactShadowsCS.EnableKeyword("ENABLE_MSAA");
				}
				passData.rayTracingEnabled = RayTracedContactShadowsRequired() && GetRayTracingState();
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
				{
					passData.contactShadowsRTS = m_GlobalSettings.renderPipelineRayTracingResources.contactShadowRayTracingRT;
					passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
					passData.actualWidth = hdCamera.actualWidth;
					passData.actualHeight = hdCamera.actualHeight;
				}
				passData.kernel = s_deferredContactShadowKernel;
				float val = Mathf.Clamp(m_ContactShadows.fadeDistance.value, 0f, m_ContactShadows.maxDistance.value);
				float value = m_ContactShadows.maxDistance.value;
				float w = 1f / Math.Max(1E-06f, val);
				float y = Mathf.Min(m_ContactShadows.minDistance.value, value);
				float z = Mathf.Clamp(m_ContactShadows.fadeInDistance.value, 1E-06f, value);
				passData.params1 = new Vector4(m_ContactShadows.length.value, m_ContactShadows.distanceScaleFactor.value, value, w);
				passData.params2 = new Vector4(firstMipOffsetY, y, z, m_ContactShadows.rayBias.value * 0.01f);
				passData.params3 = new Vector4(m_ContactShadows.sampleCount, m_ContactShadows.thicknessScale.value * 10f, 0f, 0f);
				int num = 8;
				passData.numTilesX = (hdCamera.actualWidth + (num - 1)) / num;
				passData.numTilesY = (hdCamera.actualHeight + (num - 1)) / num;
				passData.viewCount = hdCamera.viewCount;
				passData.depthTextureParameterName = (msaaEnabled ? HDShaderIDs._CameraDepthValuesTexture : HDShaderIDs._CameraDepthTexture);
				passData.lightLoopLightData = m_LightLoopLightData;
				passData.lightList = renderGraphBuilder.ReadComputeBuffer(in lightLists.lightList);
				passData.depthTexture = renderGraphBuilder.ReadTexture(in depthTexture);
				RenderContactShadowPassData renderContactShadowPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_UInt,
					enableRandomWrite = true,
					clearBuffer = clearBuffer,
					clearColor = Color.clear,
					name = "ContactShadowsBuffer"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				renderContactShadowPassData.contactShadowsTexture = renderGraphBuilder.WriteTexture(in input);
				contactShadowsTexture = passData.contactShadowsTexture;
				renderGraphBuilder.SetRenderFunc(delegate(RenderContactShadowPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeVectorParam(data.contactShadowsCS, HDShaderIDs._ContactShadowParamsParameters, data.params1);
					ctx.cmd.SetComputeVectorParam(data.contactShadowsCS, HDShaderIDs._ContactShadowParamsParameters2, data.params2);
					ctx.cmd.SetComputeVectorParam(data.contactShadowsCS, HDShaderIDs._ContactShadowParamsParameters3, data.params3);
					ctx.cmd.SetComputeBufferParam(data.contactShadowsCS, data.kernel, HDShaderIDs._DirectionalLightDatas, data.lightLoopLightData.directionalLightData);
					ctx.cmd.SetComputeBufferParam(data.contactShadowsCS, data.kernel, HDShaderIDs._LightDatas, data.lightLoopLightData.lightData);
					ctx.cmd.SetComputeBufferParam(data.contactShadowsCS, data.kernel, HDShaderIDs.g_vLightListTile, data.lightList);
					ctx.cmd.SetComputeTextureParam(data.contactShadowsCS, data.kernel, data.depthTextureParameterName, data.depthTexture);
					ctx.cmd.SetComputeTextureParam(data.contactShadowsCS, data.kernel, HDShaderIDs._ContactShadowTextureUAV, data.contactShadowsTexture);
					ctx.cmd.DispatchCompute(data.contactShadowsCS, data.kernel, data.numTilesX, data.numTilesY, data.viewCount);
					if (data.rayTracingEnabled)
					{
						ctx.cmd.SetRayTracingShaderPass(data.contactShadowsRTS, "VisibilityDXR");
						ctx.cmd.SetRayTracingAccelerationStructure(data.contactShadowsRTS, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
						ctx.cmd.SetRayTracingVectorParam(data.contactShadowsRTS, HDShaderIDs._ContactShadowParamsParameters, data.params1);
						ctx.cmd.SetRayTracingVectorParam(data.contactShadowsRTS, HDShaderIDs._ContactShadowParamsParameters2, data.params2);
						ctx.cmd.SetRayTracingBufferParam(data.contactShadowsRTS, HDShaderIDs._DirectionalLightDatas, data.lightLoopLightData.directionalLightData);
						ctx.cmd.SetRayTracingBufferParam(data.contactShadowsRTS, HDShaderIDs._LightDatas, data.lightLoopLightData.lightData);
						ctx.cmd.SetRayTracingBufferParam(data.contactShadowsRTS, HDShaderIDs.g_vLightListTile, data.lightList);
						ctx.cmd.SetRayTracingTextureParam(data.contactShadowsRTS, HDShaderIDs._DepthTexture, data.depthTexture);
						ctx.cmd.SetRayTracingTextureParam(data.contactShadowsRTS, HDShaderIDs._ContactShadowTextureUAV, data.contactShadowsTexture);
						ctx.cmd.DispatchRays(data.contactShadowsRTS, "RayGenContactShadows", (uint)data.actualWidth, (uint)data.actualHeight, (uint)data.viewCount);
					}
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			PushFullScreenDebugTexture(renderGraph, contactShadowsTexture, FullScreenDebugMode.ContactShadows);
			return contactShadowsTexture;
		}

		void IDataProvider.FirstInitScene(StageRuntimeInterface SRI)
		{
			Camera camera = SRI.camera;
			camera.allowHDR = true;
			HDAdditionalCameraData hDAdditionalCameraData = camera.gameObject.AddComponent<HDAdditionalCameraData>();
			hDAdditionalCameraData.clearColorMode = HDAdditionalCameraData.ClearColorMode.Color;
			hDAdditionalCameraData.clearDepth = true;
			hDAdditionalCameraData.backgroundColorHDR = camera.backgroundColor;
			hDAdditionalCameraData.volumeAnchorOverride = camera.transform;
			hDAdditionalCameraData.volumeLayerMask = int.MinValue;
			hDAdditionalCameraData.customRenderingSettings = true;
			hDAdditionalCameraData.renderingPathCustomFrameSettings.SetEnabled(FrameSettingsField.SSR, value: false);
			hDAdditionalCameraData.hasPersistentHistory = true;
			HDAdditionalLightData hDAdditionalLightData = SRI.sunLight.gameObject.AddComponent<HDAdditionalLightData>();
			hDAdditionalLightData.intensity = 0f;
			hDAdditionalLightData.SetShadowResolution(2048);
			GameObject gameObject = SRI.AddGameObject(persistent: true);
			gameObject.name = "StageVolume";
			Volume volume = gameObject.AddComponent<Volume>();
			volume.isGlobal = true;
			volume.priority = float.MaxValue;
			volume.enabled = false;
			SRI.SRPData = new LookDevDataForHDRP
			{
				additionalCameraData = null,
				additionalLightData = null,
				visualEnvironment = null,
				sky = null,
				volume = null
			};
		}

		void IDataProvider.UpdateSky(Camera camera, Sky sky, StageRuntimeInterface SRI)
		{
			LookDevDataForHDRP lookDevDataForHDRP = (LookDevDataForHDRP)SRI.SRPData;
			if (sky.cubemap == null)
			{
				lookDevDataForHDRP.visualEnvironment.skyType.Override(0);
				lookDevDataForHDRP.additionalCameraData.clearColorMode = HDAdditionalCameraData.ClearColorMode.Color;
				return;
			}
			lookDevDataForHDRP.visualEnvironment.skyType.Override(1);
			lookDevDataForHDRP.sky.hdriSky.Override(sky.cubemap);
			lookDevDataForHDRP.sky.rotation.Override(sky.longitudeOffset);
			lookDevDataForHDRP.additionalCameraData.clearColorMode = HDAdditionalCameraData.ClearColorMode.Sky;
		}

		void IDataProvider.OnBeginRendering(StageRuntimeInterface SRI)
		{
			((LookDevDataForHDRP)SRI.SRPData).volume.enabled = true;
		}

		void IDataProvider.OnEndRendering(StageRuntimeInterface SRI)
		{
			((LookDevDataForHDRP)SRI.SRPData).volume.enabled = false;
		}

		void IDataProvider.UpdateDebugMode(int debugIndex)
		{
			debugDisplaySettings.SetDebugViewCommonMaterialProperty((MaterialSharedProperty)(debugIndex + 1));
		}

		void IDataProvider.GetShadowMask(ref RenderTexture output, StageRuntimeInterface SRI)
		{
			LookDevDataForHDRP obj = (LookDevDataForHDRP)SRI.SRPData;
			Color backgroundColorHDR = obj.additionalCameraData.backgroundColorHDR;
			HDAdditionalCameraData.ClearColorMode clearColorMode = obj.additionalCameraData.clearColorMode;
			obj.additionalCameraData.backgroundColorHDR = Color.white;
			obj.additionalCameraData.clearColorMode = HDAdditionalCameraData.ClearColorMode.Color;
			obj.additionalLightData.intensity = 1f;
			debugDisplaySettings.SetShadowDebugMode(ShadowMapDebugMode.SingleShadow);
			SRI.camera.targetTexture = output;
			SRI.camera.Render();
			debugDisplaySettings.SetShadowDebugMode(ShadowMapDebugMode.None);
			obj.additionalLightData.intensity = 0f;
			obj.additionalCameraData.backgroundColorHDR = backgroundColorHDR;
			obj.additionalCameraData.clearColorMode = clearColorMode;
		}

		void IDataProvider.Cleanup(StageRuntimeInterface SRI)
		{
			CoreUtils.Destroy(((LookDevDataForHDRP)SRI.SRPData).volume.sharedProfile);
		}

		private void InitializePostProcess()
		{
			m_FinalPassMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.finalPassPS);
			m_ClearBlackMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.clearBlackPS);
			m_SMAAMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.SMAAPS);
			m_TemporalAAMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.temporalAntialiasingPS);
			m_DLSSBiasColorMaskMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.DLSSBiasColorMaskPS);
			m_LensFlareDataDrivenShader = CoreUtils.CreateEngineMaterial(defaultResources.shaders.lensFlareDataDrivenPS);
			m_LensFlareDataDrivenShader.SetOverrideTag("RenderType", "Transparent");
			m_UseSafePath = SystemInfo.graphicsDeviceVendor.ToLowerInvariant().Contains("intel");
			GlobalPostProcessSettings postProcessSettings = asset.currentPlatformRenderPipelineSettings.postProcessSettings;
			m_LutSize = postProcessSettings.lutSize;
			m_LutFormat = (GraphicsFormat)postProcessSettings.lutFormat;
			m_HableCurve = new HableCurve();
			m_MotionBlurSupportsScattering = SystemInfo.IsFormatSupported(GraphicsFormat.R32_UInt, FormatUsage.LoadStore) && SystemInfo.IsFormatSupported(GraphicsFormat.R16_UInt, FormatUsage.LoadStore);
			m_MotionBlurSupportsScattering = m_MotionBlurSupportsScattering && SystemInfo.graphicsDeviceType != GraphicsDeviceType.Vulkan;
			m_MotionBlurSupportsScattering = m_MotionBlurSupportsScattering && SystemInfo.graphicsDeviceType != GraphicsDeviceType.Metal;
			m_Random = new System.Random();
			m_PostProcessColorFormat = (GraphicsFormat)postProcessSettings.bufferFormat;
			m_KeepAlpha = false;
			m_EnableAlpha = asset.currentPlatformRenderPipelineSettings.SupportsAlpha() && postProcessSettings.supportsAlpha;
			if (!m_EnableAlpha)
			{
				m_KeepAlpha = asset.currentPlatformRenderPipelineSettings.SupportsAlpha();
			}
			m_EmptyExposureTexture = RTHandles.Alloc(1, 1, 1, DepthBits.None, GraphicsFormat.R32G32_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Empty EV100 Exposure");
			m_DebugExposureData = RTHandles.Alloc(1, 1, 1, DepthBits.None, GraphicsFormat.R32G32_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2D, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Debug Exposure Info");
			m_ExposureCurveTexture = new Texture2D(128, 1, GraphicsFormat.R16G16B16A16_SFloat, TextureCreationFlags.None)
			{
				name = "Exposure Curve",
				filterMode = FilterMode.Bilinear,
				wrapMode = TextureWrapMode.Clamp
			};
			m_ExposureCurveTexture.hideFlags = HideFlags.HideAndDontSave;
			SetExposureTextureToEmpty(m_EmptyExposureTexture);
			m_GradingAndTonemappingLUT = RTHandles.Alloc(m_LutSize, m_LutSize, m_LutSize, DepthBits.None, m_LutFormat, FilterMode.Bilinear, TextureWrapMode.Clamp, TextureDimension.Tex3D, enableRandomWrite: true);
			resGroup = ResolutionGroup.BeforeDynamicResUpscale;
			m_DLSSPass = DLSSPass.Create(m_GlobalSettings);
		}

		private GraphicsFormat GetPostprocessTextureFormat(HDCamera camera)
		{
			if (camera.CameraIsSceneFiltering())
			{
				return GraphicsFormat.R16G16B16A16_SFloat;
			}
			return m_PostProcessColorFormat;
		}

		private bool PostProcessEnableAlpha(HDCamera camera)
		{
			if (camera.CameraIsSceneFiltering())
			{
				return true;
			}
			return m_EnableAlpha;
		}

		private void CleanupPostProcess()
		{
			RTHandles.Release(m_EmptyExposureTexture);
			RTHandles.Release(m_GradingAndTonemappingLUT);
			m_GradingAndTonemappingLUT = null;
			m_EmptyExposureTexture = null;
			CoreUtils.Destroy(m_ExposureCurveTexture);
			CoreUtils.Destroy(m_InternalSpectralLut);
			CoreUtils.Destroy(m_FinalPassMaterial);
			CoreUtils.Destroy(m_ClearBlackMaterial);
			CoreUtils.Destroy(m_SMAAMaterial);
			CoreUtils.Destroy(m_TemporalAAMaterial);
			CoreUtils.SafeRelease(m_HistogramBuffer);
			CoreUtils.SafeRelease(m_DebugImageHistogramBuffer);
			RTHandles.Release(m_DebugExposureData);
			m_ExposureCurveTexture = null;
			m_InternalSpectralLut = null;
			m_FinalPassMaterial = null;
			m_ClearBlackMaterial = null;
			m_SMAAMaterial = null;
			m_TemporalAAMaterial = null;
			m_HistogramBuffer = null;
			m_DebugImageHistogramBuffer = null;
			m_DebugExposureData = null;
			m_DLSSPass = null;
		}

		private void CheckRenderTexturesValidity()
		{
			if (!m_EmptyExposureTexture.rt.IsCreated())
			{
				SetExposureTextureToEmpty(m_EmptyExposureTexture);
			}
			HDUtils.CheckRTCreated(m_DebugExposureData.rt);
		}

		private void BeginPostProcessFrame(CommandBuffer cmd, HDCamera camera, HDRenderPipeline hdInstance)
		{
			m_PostProcessEnabled = camera.frameSettings.IsEnabled(FrameSettingsField.Postprocess) && CoreUtils.ArePostProcessesEnabled(camera.camera);
			m_AnimatedMaterialsEnabled = camera.animateMaterials;
			m_AfterDynamicResUpscaleRes = new Vector2Int((int)Mathf.Round(camera.finalViewport.width), (int)Mathf.Round(camera.finalViewport.height));
			m_BeforeDynamicResUpscaleRes = new Vector2Int(camera.actualWidth, camera.actualHeight);
			VolumeStack volumeStack = camera.volumeStack;
			m_Exposure = volumeStack.GetComponent<Exposure>();
			m_DepthOfField = volumeStack.GetComponent<DepthOfField>();
			m_MotionBlur = volumeStack.GetComponent<MotionBlur>();
			m_PaniniProjection = volumeStack.GetComponent<PaniniProjection>();
			m_Bloom = volumeStack.GetComponent<Bloom>();
			m_ChromaticAberration = volumeStack.GetComponent<ChromaticAberration>();
			m_LensDistortion = volumeStack.GetComponent<LensDistortion>();
			m_Vignette = volumeStack.GetComponent<Vignette>();
			m_Tonemapping = volumeStack.GetComponent<Tonemapping>();
			m_WhiteBalance = volumeStack.GetComponent<WhiteBalance>();
			m_ColorAdjustments = volumeStack.GetComponent<ColorAdjustments>();
			m_ChannelMixer = volumeStack.GetComponent<ChannelMixer>();
			m_SplitToning = volumeStack.GetComponent<SplitToning>();
			m_LiftGammaGain = volumeStack.GetComponent<LiftGammaGain>();
			m_ShadowsMidtonesHighlights = volumeStack.GetComponent<ShadowsMidtonesHighlights>();
			m_Curves = volumeStack.GetComponent<ColorCurves>();
			m_FilmGrain = volumeStack.GetComponent<FilmGrain>();
			FrameSettings frameSettings = camera.frameSettings;
			m_StopNaNFS = frameSettings.IsEnabled(FrameSettingsField.StopNaN) && m_PostProcessEnabled;
			m_DepthOfFieldFS = frameSettings.IsEnabled(FrameSettingsField.DepthOfField) && m_PostProcessEnabled;
			m_MotionBlurFS = frameSettings.IsEnabled(FrameSettingsField.MotionBlur) && m_PostProcessEnabled;
			m_PaniniProjectionFS = frameSettings.IsEnabled(FrameSettingsField.PaniniProjection) && m_PostProcessEnabled;
			m_BloomFS = frameSettings.IsEnabled(FrameSettingsField.Bloom) && m_PostProcessEnabled;
			m_LensFlareDataDataDrivenFS = frameSettings.IsEnabled(FrameSettingsField.LensFlareDataDriven) && m_PostProcessEnabled;
			m_ChromaticAberrationFS = frameSettings.IsEnabled(FrameSettingsField.ChromaticAberration) && m_PostProcessEnabled;
			m_LensDistortionFS = frameSettings.IsEnabled(FrameSettingsField.LensDistortion) && m_PostProcessEnabled;
			m_VignetteFS = frameSettings.IsEnabled(FrameSettingsField.Vignette) && m_PostProcessEnabled;
			m_ColorGradingFS = frameSettings.IsEnabled(FrameSettingsField.ColorGrading) && m_PostProcessEnabled;
			m_TonemappingFS = frameSettings.IsEnabled(FrameSettingsField.Tonemapping) && m_PostProcessEnabled;
			m_FilmGrainFS = frameSettings.IsEnabled(FrameSettingsField.FilmGrain) && m_PostProcessEnabled;
			m_DitheringFS = frameSettings.IsEnabled(FrameSettingsField.Dithering) && m_PostProcessEnabled;
			m_AntialiasingFS = frameSettings.IsEnabled(FrameSettingsField.Antialiasing) || camera.IsTAAUEnabled();
			m_ScreenCoordOverride = frameSettings.IsEnabled(FrameSettingsField.ScreenCoordOverride) && m_PostProcessEnabled;
			m_AntialiasingFS &= !camera.IsPathTracingEnabled();
			m_DLSSPassEnabled = m_DLSSPass != null && camera.IsDLSSEnabled();
			m_DebugExposureCompensation = m_CurrentDebugDisplaySettings.data.lightingDebugSettings.debugExposure;
			m_CurrCameraType = camera.camera.cameraType;
			CheckRenderTexturesValidity();
			if (CanRunFixedExposurePass(camera))
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.FixedExposure)))
				{
					DoFixedExposure(camera, cmd);
				}
			}
			cmd.SetGlobalTexture(HDShaderIDs._ExposureTexture, GetExposureTexture(camera));
			cmd.SetGlobalTexture(HDShaderIDs._PrevExposureTexture, GetPreviousExposureTexture(camera));
			if (m_DLSSPass != null)
			{
				m_DLSSPass.BeginFrame(camera);
			}
		}

		private int ComputeLUTHash()
		{
			return m_Tonemapping.GetHashCode() * 23 + m_WhiteBalance.GetHashCode() * 23 + m_ColorAdjustments.GetHashCode() * 23 + m_ChannelMixer.GetHashCode() * 23 + m_SplitToning.GetHashCode() * 23 + m_LiftGammaGain.GetHashCode() * 23 + m_ShadowsMidtonesHighlights.GetHashCode() * 23 + m_Curves.GetHashCode() * 23 + m_TonemappingFS.GetHashCode() * 23 + m_ColorGradingFS.GetHashCode() * 23 + HDROutputActiveForCameraType(m_CurrCameraType).GetHashCode();
		}

		private static void ValidateComputeBuffer(ref ComputeBuffer cb, int size, int stride, ComputeBufferType type = ComputeBufferType.Default)
		{
			if (cb == null || cb.count < size)
			{
				CoreUtils.SafeRelease(cb);
				cb = new ComputeBuffer(size, stride, type);
			}
		}

		private bool IsDynamicResUpscaleTargetEnabled()
		{
			return resGroup == ResolutionGroup.BeforeDynamicResUpscale;
		}

		private TextureHandle GetPostprocessOutputHandle(RenderGraph renderGraph, string name, bool dynamicResolution, GraphicsFormat colorFormat, bool useMipMap)
		{
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution, xrReady: true)
			{
				name = name,
				colorFormat = colorFormat,
				useMipMap = useMipMap,
				enableRandomWrite = true
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle GetPostprocessOutputHandle(HDCamera camera, RenderGraph renderGraph, string name, bool useMipMap = false)
		{
			return GetPostprocessOutputHandle(renderGraph, name, IsDynamicResUpscaleTargetEnabled(), GetPostprocessTextureFormat(camera), useMipMap);
		}

		private TextureHandle GetPostprocessOutputHandle(RenderGraph renderGraph, string name, GraphicsFormat colorFormat, bool useMipMap = false)
		{
			return GetPostprocessOutputHandle(renderGraph, name, IsDynamicResUpscaleTargetEnabled(), colorFormat, useMipMap);
		}

		private TextureHandle GetPostprocessUpsampledOutputHandle(HDCamera camera, RenderGraph renderGraph, string name)
		{
			return GetPostprocessOutputHandle(renderGraph, name, dynamicResolution: false, GetPostprocessTextureFormat(camera), useMipMap: false);
		}

		private bool GrabPostProcessHistoryTextures(HDCamera camera, HDCameraFrameHistoryType historyType, string name, GraphicsFormat format, out RTHandle previous, out RTHandle next, bool useMips = false)
		{
			bool result = true;
			next = camera.GetCurrentFrameRT((int)historyType);
			if (next == null || (useMips && next.rt.mipmapCount == 1) || next.rt.width != camera.postProcessRTHistoryMaxReference.x || next.rt.height != camera.postProcessRTHistoryMaxReference.y)
			{
				result = false;
				Vector2Int newSize = new Vector2Int(camera.postProcessRTHistoryMaxReference.x, camera.postProcessRTHistoryMaxReference.y);
				PostProcessHistoryTextureAllocator postProcessHistoryTextureAllocator = new PostProcessHistoryTextureAllocator(name, newSize, format, useMips);
				if (next != null)
				{
					camera.ReleaseHistoryFrameRT((int)historyType);
				}
				next = camera.AllocHistoryFrameRT((int)historyType, ((PostProcessHistoryTextureAllocator)postProcessHistoryTextureAllocator).Allocator, 2);
			}
			previous = camera.GetPreviousFrameRT((int)historyType);
			return result;
		}

		private TextureHandle RenderPostProcess(RenderGraph renderGraph, in PrepassOutput prepassOutput, TextureHandle inputColor, TextureHandle backBuffer, TextureHandle uiBuffer, TextureHandle afterPostProcessBuffer, TextureHandle sunOcclusionTexture, CullingResults cullResults, HDCamera hdCamera, CubemapFace cubemapFace, bool postProcessIsFinalPass)
		{
			TextureHandle textureHandle;
			if (!postProcessIsFinalPass)
			{
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: false, xrReady: true)
				{
					colorFormat = GetColorBufferFormat(),
					name = "Intermediate Postprocess buffer"
				};
				textureHandle = renderGraph.CreateTexture(in desc);
			}
			else
			{
				textureHandle = backBuffer;
			}
			TextureHandle textureHandle2 = textureHandle;
			TextureHandle motionVectors = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors) ? prepassOutput.resolvedMotionVectorsBuffer : renderGraph.defaultResources.blackTextureXR);
			bool flipY = postProcessIsFinalPass && (hdCamera.flipYMode == HDAdditionalCameraData.FlipYMode.ForceFlipY || hdCamera.isMainGameView);
			renderGraph.BeginProfilingSampler(ProfilingSampler.Get(HDProfileId.PostProcessing));
			Vector2Int vector2Int = ((DynamicResolutionHandler.instance.upsamplerSchedule != 0) ? m_BeforeDynamicResUpscaleRes : m_AfterDynamicResUpscaleRes);
			hdCamera.SetPostProcessHistorySizeAndReference(vector2Int.x, vector2Int.y, m_AfterDynamicResUpscaleRes.x, m_AfterDynamicResUpscaleRes.y);
			TextureHandle source = inputColor;
			TextureHandle resolvedDepthBuffer = prepassOutput.resolvedDepthBuffer;
			TextureHandle depthPyramidTexture = prepassOutput.depthPyramidTexture;
			TextureHandle resolvedNormalBuffer = prepassOutput.resolvedNormalBuffer;
			TextureHandle depthMinMaxAvgMSAA = (hdCamera.msaaEnabled ? prepassOutput.depthValuesMSAA : TextureHandle.nullHandle);
			TextureHandle alphaTexture = DoCopyAlpha(renderGraph, hdCamera, source);
			Vector4 postProcessScreenSize = hdCamera.postProcessScreenSize;
			if (m_PostProcessEnabled || m_AntialiasingFS)
			{
				source = StopNaNsPass(renderGraph, hdCamera, source);
				source = DynamicExposurePass(renderGraph, hdCamera, source);
				source = DoDLSSPasses(renderGraph, hdCamera, DynamicResolutionHandler.UpsamplerScheduleType.BeforePost, source, resolvedDepthBuffer, motionVectors);
				source = CustomPostProcessPass(renderGraph, hdCamera, source, resolvedDepthBuffer, resolvedNormalBuffer, motionVectors, m_GlobalSettings.beforeTAACustomPostProcesses, HDProfileId.CustomPostProcessBeforeTAA);
				if (m_AntialiasingFS)
				{
					if (hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.TemporalAntialiasing)
					{
						source = DoTemporalAntialiasing(renderGraph, hdCamera, resolvedDepthBuffer, motionVectors, depthPyramidTexture, source, prepassOutput.stencilBuffer, postDoF: false, "TAA Destination");
						if (hdCamera.IsTAAUEnabled())
						{
							SetCurrentResolutionGroup(renderGraph, hdCamera, ResolutionGroup.AfterDynamicResUpscale);
						}
						RestoreNonjitteredMatrices(renderGraph, hdCamera);
					}
					else if (hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.SubpixelMorphologicalAntiAliasing)
					{
						source = SMAAPass(renderGraph, hdCamera, resolvedDepthBuffer, source);
					}
				}
				source = CustomPostProcessPass(renderGraph, hdCamera, source, resolvedDepthBuffer, resolvedNormalBuffer, motionVectors, m_GlobalSettings.beforePostProcessCustomPostProcesses, HDProfileId.CustomPostProcessBeforePP);
				source = DepthOfFieldPass(renderGraph, hdCamera, resolvedDepthBuffer, motionVectors, depthPyramidTexture, source, depthMinMaxAvgMSAA, prepassOutput.stencilBuffer);
				source = DoDLSSPasses(renderGraph, hdCamera, DynamicResolutionHandler.UpsamplerScheduleType.AfterDepthOfField, source, resolvedDepthBuffer, motionVectors);
				if (m_DepthOfField.IsActive() && m_SubFrameManager.isRecording && m_SubFrameManager.subFrameCount > 1 && !hdCamera.IsPathTracingEnabled())
				{
					RenderAccumulation(m_RenderGraph, hdCamera, source, source, null, needExposure: false);
				}
				source = MotionBlurPass(renderGraph, hdCamera, resolvedDepthBuffer, motionVectors, source);
				source = CustomPostProcessPass(renderGraph, hdCamera, source, resolvedDepthBuffer, resolvedNormalBuffer, motionVectors, m_GlobalSettings.afterPostProcessBlursCustomPostProcesses, HDProfileId.CustomPostProcessAfterPPBlurs);
				source = PaniniProjectionPass(renderGraph, hdCamera, source);
				bool flag = m_AntialiasingFS && hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.TemporalAntialiasing;
				LensFlareComputeOcclusionDataDrivenPass(renderGraph, hdCamera, resolvedDepthBuffer, sunOcclusionTexture, flag);
				if (flag)
				{
					LensFlareMergeOcclusionDataDrivenPass(renderGraph, hdCamera, flag);
				}
				TextureHandle bloomTexture = BloomPass(renderGraph, hdCamera, source);
				TextureHandle logLut = ColorGradingPass(renderGraph);
				source = LensFlareDataDrivenPass(renderGraph, hdCamera, source, depthPyramidTexture, sunOcclusionTexture, flag);
				source = UberPass(renderGraph, hdCamera, logLut, bloomTexture, source);
				PushFullScreenDebugTexture(renderGraph, source, hdCamera.postProcessRTScales, FullScreenDebugMode.ColorLog);
				source = CustomPostProcessPass(renderGraph, hdCamera, source, resolvedDepthBuffer, resolvedNormalBuffer, motionVectors, m_GlobalSettings.afterPostProcessCustomPostProcesses, HDProfileId.CustomPostProcessAfterPP);
				source = FXAAPass(renderGraph, hdCamera, source);
				hdCamera.didResetPostProcessingHistoryInLastFrame = hdCamera.resetPostProcessingHistory;
				hdCamera.resetPostProcessingHistory = false;
			}
			else
			{
				source = DoDLSSPasses(renderGraph, hdCamera, DynamicResolutionHandler.UpsamplerScheduleType.BeforePost, source, resolvedDepthBuffer, motionVectors);
				source = DoDLSSPasses(renderGraph, hdCamera, DynamicResolutionHandler.UpsamplerScheduleType.AfterDepthOfField, source, resolvedDepthBuffer, motionVectors);
			}
			if (DynamicResolutionHandler.instance.upsamplerSchedule == DynamicResolutionHandler.UpsamplerScheduleType.AfterPost)
			{
				if (hdCamera.IsDLSSEnabled())
				{
					source = DoDLSSPasses(renderGraph, hdCamera, DynamicResolutionHandler.UpsamplerScheduleType.AfterPost, source, resolvedDepthBuffer, motionVectors);
				}
				else
				{
					source = ContrastAdaptiveSharpeningPass(renderGraph, hdCamera, source);
					source = EdgeAdaptiveSpatialUpsampling(renderGraph, hdCamera, source);
				}
			}
			FinalPass(renderGraph, hdCamera, afterPostProcessBuffer, alphaTexture, textureHandle2, source, uiBuffer, m_BlueNoise, flipY, cubemapFace, postProcessIsFinalPass);
			bool flag2 = hdCamera.IsTAAUEnabled();
			bool previousFrameWasTAAUpsampled = hdCamera.previousFrameWasTAAUpsampled;
			hdCamera.previousFrameWasTAAUpsampled = flag2;
			hdCamera.resetPostProcessingHistory = previousFrameWasTAAUpsampled != flag2;
			renderGraph.EndProfilingSampler(ProfilingSampler.Get(HDProfileId.PostProcessing));
			if (postProcessScreenSize != hdCamera.postProcessScreenSize)
			{
				hdCamera.SetPostProcessScreenSize((int)postProcessScreenSize.x, (int)postProcessScreenSize.y);
			}
			return textureHandle2;
		}

		private void RestoreNonjitteredMatrices(RenderGraph renderGraph, HDCamera hdCamera)
		{
			RestoreNonJitteredPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RestoreNonJitteredPassData>("Restore Non-Jittered Camera Matrices", out passData);
			passData.hdCamera = hdCamera;
			passData.globalCB = m_ShaderVariablesGlobalCB;
			renderGraphBuilder.SetRenderFunc(delegate(RestoreNonJitteredPassData data, RenderGraphContext ctx)
			{
				data.hdCamera.UpdateAllViewConstants(jitterProjectionMatrix: false);
				data.hdCamera.UpdateShaderVariablesGlobalCB(ref data.globalCB);
				ConstantBuffer.PushGlobal(ctx.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
			});
		}

		private TextureHandle DoDLSSColorMaskPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle inputDepth)
		{
			TextureHandle nullHandle = TextureHandle.nullHandle;
			DLSSColorMaskPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DLSSColorMaskPassData>("DLSS Color Mask", out passData, ProfilingSampler.Get(HDProfileId.DeepLearningSuperSamplingColorMask));
			try
			{
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
					clearBuffer = true,
					clearColor = Color.black,
					name = "DLSS Color Mask"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				nullHandle = renderGraphBuilder.UseColorBuffer(in input, 0);
				renderGraphBuilder.UseDepthBuffer(in inputDepth, DepthAccess.Read);
				passData.colorMaskMaterial = m_DLSSBiasColorMaskMaterial;
				passData.destWidth = hdCamera.actualWidth;
				passData.destHeight = hdCamera.actualHeight;
				renderGraphBuilder.SetRenderFunc(delegate(DLSSColorMaskPassData data, RenderGraphContext ctx)
				{
					Rect viewport = new Rect(0f, 0f, data.destWidth, data.destHeight);
					data.colorMaskMaterial.SetInt(HDShaderIDs._StencilMask, 2);
					data.colorMaskMaterial.SetInt(HDShaderIDs._StencilRef, 2);
					ctx.cmd.SetViewport(viewport);
					ctx.cmd.DrawProcedural(Matrix4x4.identity, data.colorMaskMaterial, 0, MeshTopology.Triangles, 3, 1, null);
				});
				return nullHandle;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle DoDLSSPasses(RenderGraph renderGraph, HDCamera hdCamera, DynamicResolutionHandler.UpsamplerScheduleType upsamplerSchedule, TextureHandle source, TextureHandle depthBuffer, TextureHandle motionVectors)
		{
			if (!m_DLSSPassEnabled || upsamplerSchedule != currentAsset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.DLSSInjectionPoint)
			{
				return source;
			}
			TextureHandle biasColorMask = DoDLSSColorMaskPass(renderGraph, hdCamera, depthBuffer);
			source = DoDLSSPass(renderGraph, hdCamera, source, depthBuffer, motionVectors, biasColorMask);
			SetCurrentResolutionGroup(renderGraph, hdCamera, ResolutionGroup.AfterDynamicResUpscale);
			return source;
		}

		private TextureHandle DoDLSSPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source, TextureHandle depthBuffer, TextureHandle motionVectors, TextureHandle biasColorMask)
		{
			DLSSData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<DLSSData>("Deep Learning Super Sampling", out passData, ProfilingSampler.Get(HDProfileId.DeepLearningSuperSampling));
			try
			{
				hdCamera.RequestGpuExposureValue(GetExposureTexture(hdCamera));
				passData.parameters = default(DLSSPass.Parameters);
				passData.parameters.resetHistory = hdCamera.resetPostProcessingHistory;
				passData.parameters.hdCamera = hdCamera;
				passData.parameters.drsSettings = currentAsset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings;
				passData.parameters.preExposure = Mathf.Clamp(hdCamera.GpuExposureValue(), 0.35f, 2f);
				DLSSPass.ViewResourceHandles resources = default(DLSSPass.ViewResourceHandles);
				resources.source = builder.ReadTexture(in source);
				TextureHandle input = GetPostprocessUpsampledOutputHandle(hdCamera, renderGraph, "DLSS destination");
				resources.output = builder.WriteTexture(in input);
				resources.depth = builder.ReadTexture(in depthBuffer);
				resources.motionVectors = builder.ReadTexture(in motionVectors);
				if (biasColorMask.IsValid())
				{
					resources.biasColorMask = builder.ReadTexture(in biasColorMask);
				}
				else
				{
					resources.biasColorMask = TextureHandle.nullHandle;
				}
				passData.resourceHandles = DLSSPass.CreateCameraResources(hdCamera, renderGraph, builder, in resources);
				source = resources.output;
				passData.pass = m_DLSSPass;
				builder.SetRenderFunc(delegate(DLSSData data, RenderGraphContext ctx)
				{
					data.pass.Render(data.parameters, DLSSPass.GetCameraResources(in data.resourceHandles), ctx.cmd);
				});
				return source;
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private TextureHandle DoCopyAlpha(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (m_KeepAlpha)
			{
				AlphaCopyPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<AlphaCopyPassData>("Alpha Copy", out passData, ProfilingSampler.Get(HDProfileId.AlphaCopy));
				try
				{
					passData.hdCamera = hdCamera;
					passData.copyAlphaCS = defaultResources.shaders.copyAlphaCS;
					passData.copyAlphaKernel = passData.copyAlphaCS.FindKernel("KMain");
					passData.source = renderGraphBuilder.ReadTexture(in source);
					AlphaCopyPassData alphaCopyPassData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						name = "Alpha Channel Copy",
						colorFormat = GraphicsFormat.R16_SFloat,
						enableRandomWrite = true
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					alphaCopyPassData.outputAlpha = renderGraphBuilder.WriteTexture(in input);
					renderGraphBuilder.SetRenderFunc(delegate(AlphaCopyPassData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeTextureParam(data.copyAlphaCS, data.copyAlphaKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeTextureParam(data.copyAlphaCS, data.copyAlphaKernel, HDShaderIDs._OutputTexture, data.outputAlpha);
						ctx.cmd.DispatchCompute(data.copyAlphaCS, data.copyAlphaKernel, (data.hdCamera.actualWidth + 7) / 8, (data.hdCamera.actualHeight + 7) / 8, data.hdCamera.viewCount);
					});
					return passData.outputAlpha;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return renderGraph.defaultResources.whiteTextureXR;
		}

		private TextureHandle StopNaNsPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (hdCamera.stopNaNs && m_StopNaNFS)
			{
				StopNaNPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<StopNaNPassData>("Stop NaNs", out passData, ProfilingSampler.Get(HDProfileId.StopNaNs));
				try
				{
					passData.nanKillerCS = defaultResources.shaders.nanKillerCS;
					passData.nanKillerKernel = passData.nanKillerCS.FindKernel("KMain");
					passData.width = postProcessViewportSize.x;
					passData.height = postProcessViewportSize.y;
					passData.viewCount = hdCamera.viewCount;
					passData.nanKillerCS.shaderKeywords = null;
					if (PostProcessEnableAlpha(hdCamera))
					{
						passData.nanKillerCS.EnableKeyword("ENABLE_ALPHA");
					}
					passData.source = renderGraphBuilder.ReadTexture(in source);
					StopNaNPassData stopNaNPassData = passData;
					TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "Stop NaNs Destination");
					stopNaNPassData.destination = renderGraphBuilder.WriteTexture(in input);
					renderGraphBuilder.SetRenderFunc(delegate(StopNaNPassData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeTextureParam(data.nanKillerCS, data.nanKillerKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeTextureParam(data.nanKillerCS, data.nanKillerKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.DispatchCompute(data.nanKillerCS, data.nanKillerKernel, (data.width + 7) / 8, (data.height + 7) / 8, data.viewCount);
					});
					return passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return source;
		}

		internal static void SetExposureTextureToEmpty(RTHandle exposureTexture)
		{
			Texture2D texture2D = new Texture2D(1, 1, GraphicsFormat.R16G16_SFloat, TextureCreationFlags.None);
			texture2D.SetPixel(0, 0, new Color(1f, ColorUtils.ConvertExposureToEV100(1f), 0f, 0f));
			texture2D.Apply();
			Graphics.Blit(texture2D, exposureTexture);
			CoreUtils.Destroy(texture2D);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool IsExposureFixed(HDCamera camera)
		{
			if (m_Exposure.mode.value != 0)
			{
				return m_Exposure.mode.value == ExposureMode.UsePhysicalCamera;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool CanRunFixedExposurePass(HDCamera camera)
		{
			if (IsExposureFixed(camera) && camera.exposureControlFS && camera.currentExposureTextures.useCurrentCamera)
			{
				return camera.currentExposureTextures.current != null;
			}
			return false;
		}

		internal RTHandle GetExposureTexture(HDCamera camera)
		{
			if (m_Exposure != null && camera.resetPostProcessingHistory && camera.currentExposureTextures.useCurrentCamera && !IsExposureFixed(camera))
			{
				return m_EmptyExposureTexture;
			}
			return GetExposureTextureHandle(camera.currentExposureTextures.current);
		}

		internal RTHandle GetExposureTextureHandle(RTHandle rt)
		{
			return rt ?? m_EmptyExposureTexture;
		}

		private RTHandle GetPreviousExposureTexture(HDCamera camera)
		{
			if (!camera.didResetPostProcessingHistoryInLastFrame || IsExposureFixed(camera))
			{
				return GetExposureTextureHandle(camera.currentExposureTextures.previous);
			}
			return m_EmptyExposureTexture;
		}

		private RTHandle GetExposureDebugData()
		{
			return m_DebugExposureData;
		}

		private HableCurve GetCustomToneMapCurve()
		{
			return m_HableCurve;
		}

		private int GetLutSize()
		{
			return m_LutSize;
		}

		private ComputeBuffer GetHistogramBuffer()
		{
			return m_HistogramBuffer;
		}

		private void ComputeProceduralMeteringParams(HDCamera camera, out Vector4 proceduralParams1, out Vector4 proceduralParams2)
		{
			Vector2 value = m_Exposure.proceduralCenter.value;
			if (camera.exposureTarget != null && m_Exposure.centerAroundExposureTarget.value)
			{
				Vector3 position = camera.exposureTarget.transform.position;
				if (ShaderConfig.s_CameraRelativeRendering != 0)
				{
					position -= camera.camera.transform.position;
				}
				Vector4 vector = camera.mainViewConstants.viewProjMatrix * position;
				vector.x /= vector.w;
				vector.y /= vector.w;
				Vector2 vector2 = new Vector2(vector.x, vector.y) * 0.5f + new Vector2(0.5f, 0.5f);
				vector2.y = 1f - vector2.y;
				value += vector2;
			}
			value.x = Mathf.Clamp01(value.x);
			value.y = Mathf.Clamp01(value.y);
			value.x *= camera.actualWidth;
			value.y *= camera.actualHeight;
			_ = camera.actualHeight;
			_ = camera.actualWidth;
			proceduralParams1 = new Vector4(value.x, value.y, m_Exposure.proceduralRadii.value.x * (float)camera.actualWidth, m_Exposure.proceduralRadii.value.y * (float)camera.actualHeight);
			proceduralParams2 = new Vector4(1f / m_Exposure.proceduralSoftness.value, LightUtils.ConvertEvToLuminance(m_Exposure.maskMinIntensity.value), LightUtils.ConvertEvToLuminance(m_Exposure.maskMaxIntensity.value), 0f);
		}

		private ComputeBuffer GetDebugImageHistogramBuffer()
		{
			return m_DebugImageHistogramBuffer;
		}

		private void DoFixedExposure(HDCamera hdCamera, CommandBuffer cmd)
		{
			ComputeShader exposureCS = defaultResources.shaders.exposureCS;
			int num = 0;
			Vector4 val = new Vector4(0f, 0f, ColorUtils.lensImperfectionExposureScale, ColorUtils.s_LightMeterCalibrationConstant);
			Vector4 val2;
			if (m_Exposure.mode.value == ExposureMode.Fixed)
			{
				num = exposureCS.FindKernel("KFixedExposure");
				val2 = new Vector4(m_Exposure.compensation.value + m_DebugExposureCompensation, m_Exposure.fixedExposure.value, 0f, 0f);
			}
			else
			{
				num = exposureCS.FindKernel("KManualCameraExposure");
				val2 = new Vector4(m_Exposure.compensation.value + m_DebugExposureCompensation, hdCamera.camera.aperture, hdCamera.camera.shutterSpeed, hdCamera.camera.iso);
			}
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ExposureParams, val2);
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ExposureParams2, val);
			cmd.SetComputeTextureParam(exposureCS, num, HDShaderIDs._OutputTexture, hdCamera.currentExposureTextures.current);
			cmd.DispatchCompute(exposureCS, num, 1, 1, 1);
		}

		private void PrepareExposureCurveData(out float min, out float max)
		{
			AnimationCurve value = m_Exposure.curveMap.value;
			AnimationCurve value2 = m_Exposure.limitMinCurveMap.value;
			AnimationCurve value3 = m_Exposure.limitMaxCurveMap.value;
			if (m_ExposureCurveTexture == null)
			{
				m_ExposureCurveTexture = new Texture2D(128, 1, GraphicsFormat.R16G16B16A16_SFloat, TextureCreationFlags.None)
				{
					name = "Exposure Curve",
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp
				};
				m_ExposureCurveTexture.hideFlags = HideFlags.HideAndDontSave;
			}
			bool flag = value2.length > 0;
			bool flag2 = value3.length > 0;
			float num = -100f;
			float num2 = 100f;
			Color[] exposureCurveColorArray = m_ExposureCurveColorArray;
			if (value == null || value.length == 0)
			{
				min = 0f;
				max = 0f;
				for (int i = 0; i < 128; i++)
				{
					exposureCurveColorArray[i] = Color.clear;
				}
			}
			else
			{
				min = value[0].time;
				max = value[value.length - 1].time;
				float num3 = (max - min) / 127f;
				for (int j = 0; j < 128; j++)
				{
					float time = min + num3 * (float)j;
					exposureCurveColorArray[j] = new Color(value.Evaluate(time), flag ? value2.Evaluate(time) : num, flag2 ? value3.Evaluate(time) : num2, 0f);
				}
			}
			m_ExposureCurveTexture.SetPixels(exposureCurveColorArray);
			m_ExposureCurveTexture.Apply();
		}

		private void PrepareExposurePassData(RenderGraph renderGraph, RenderGraphBuilder builder, HDCamera hdCamera, TextureHandle source, DynamicExposureData passData)
		{
			passData.exposureCS = defaultResources.shaders.exposureCS;
			passData.histogramExposureCS = defaultResources.shaders.histogramExposureCS;
			passData.histogramExposureCS.shaderKeywords = null;
			passData.camera = hdCamera;
			passData.viewportSize = postProcessViewportSize;
			AdaptationMode adaptationMode = m_Exposure.adaptationMode.value;
			if (!Application.isPlaying || hdCamera.resetPostProcessingHistory)
			{
				adaptationMode = AdaptationMode.Fixed;
			}
			passData.exposureVariants = m_ExposureVariants;
			passData.exposureVariants[0] = 1;
			passData.exposureVariants[1] = (int)m_Exposure.meteringMode.value;
			passData.exposureVariants[2] = (int)adaptationMode;
			passData.exposureVariants[3] = 0;
			bool flag = m_Exposure.meteringMode.value == MeteringMode.MaskWeighted && m_Exposure.weightTextureMask.value != null;
			passData.textureMeteringMask = (flag ? m_Exposure.weightTextureMask.value : Texture2D.whiteTexture);
			ComputeProceduralMeteringParams(hdCamera, out passData.proceduralMaskParams, out passData.proceduralMaskParams2);
			bool num = m_Exposure.mode.value == ExposureMode.AutomaticHistogram;
			bool num2 = (num && m_Exposure.histogramUseCurveRemapping.value) || m_Exposure.mode.value == ExposureMode.CurveMapping;
			passData.histogramUsesCurve = m_Exposure.histogramUseCurveRemapping.value;
			float num3 = (m_SubFrameManager.isRecording ? ((float)m_SubFrameManager.subFrameCount) : 1f);
			passData.adaptationParams = new Vector4(m_Exposure.adaptationSpeedLightToDark.value * num3, m_Exposure.adaptationSpeedDarkToLight.value * num3, 0f, 0f);
			passData.exposureMode = m_Exposure.mode.value;
			float num4 = m_Exposure.limitMax.value;
			float num5 = m_Exposure.limitMin.value;
			float min = 0f;
			float max = 0f;
			if (num2)
			{
				PrepareExposureCurveData(out min, out max);
				num5 = min;
				num4 = max;
			}
			passData.exposureParams = new Vector4(m_Exposure.compensation.value + m_DebugExposureCompensation, num5, num4, 0f);
			passData.exposureParams2 = new Vector4(min, max, ColorUtils.lensImperfectionExposureScale, ColorUtils.s_LightMeterCalibrationConstant);
			passData.exposureCurve = m_ExposureCurveTexture;
			if (num)
			{
				ValidateComputeBuffer(ref m_HistogramBuffer, 128, 4);
				m_HistogramBuffer.SetData(m_EmptyHistogram);
				Vector2 vector = m_Exposure.histogramPercentages.value / 100f;
				float b = num4 - num5;
				float num6 = 1f / Mathf.Max(1E-05f, b);
				float y = (0f - num5) * num6;
				passData.histogramExposureParams = new Vector4(num6, y, vector.x, vector.y);
				passData.histogramBuffer = m_HistogramBuffer;
				passData.histogramOutputDebugData = m_CurrentDebugDisplaySettings.data.lightingDebugSettings.exposureDebugMode == ExposureDebugMode.HistogramView;
				if (passData.histogramOutputDebugData)
				{
					passData.histogramExposureCS.EnableKeyword("OUTPUT_DEBUG_DATA");
				}
				passData.exposurePreparationKernel = passData.histogramExposureCS.FindKernel("KHistogramGen");
				passData.exposureReductionKernel = passData.histogramExposureCS.FindKernel("KHistogramReduce");
			}
			else
			{
				passData.exposurePreparationKernel = passData.exposureCS.FindKernel("KPrePass");
				passData.exposureReductionKernel = passData.exposureCS.FindKernel("KReduction");
			}
			GrabExposureRequiredTextures(hdCamera, out var prevExposure, out var nextExposure);
			passData.source = builder.ReadTexture(in source);
			TextureHandle input = renderGraph.ImportTexture(prevExposure);
			passData.prevExposure = builder.ReadTexture(in input);
			input = renderGraph.ImportTexture(nextExposure);
			passData.nextExposure = builder.WriteTexture(in input);
		}

		private void GrabExposureRequiredTextures(HDCamera camera, out RTHandle prevExposure, out RTHandle nextExposure)
		{
			prevExposure = camera.currentExposureTextures.current;
			nextExposure = camera.currentExposureTextures.previous;
			if (camera.resetPostProcessingHistory)
			{
				prevExposure = m_EmptyExposureTexture;
			}
		}

		private static void DoDynamicExposure(DynamicExposureData data, CommandBuffer cmd)
		{
			ComputeShader exposureCS = data.exposureCS;
			int exposurePreparationKernel = data.exposurePreparationKernel;
			cmd.SetComputeIntParams(exposureCS, HDShaderIDs._Variants, data.exposureVariants);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._PreviousExposureTexture, data.prevExposure);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._SourceTexture, data.source);
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ExposureParams2, data.exposureParams2);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._ExposureWeightMask, data.textureMeteringMask);
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ProceduralMaskParams, data.proceduralMaskParams);
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ProceduralMaskParams2, data.proceduralMaskParams2);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._OutputTexture, data.tmpTarget1024);
			cmd.DispatchCompute(exposureCS, exposurePreparationKernel, 128, 128, 1);
			exposurePreparationKernel = data.exposureReductionKernel;
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._PreviousExposureTexture, data.prevExposure);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._ExposureCurveTexture, Texture2D.blackTexture);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._InputTexture, data.tmpTarget1024);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._OutputTexture, data.tmpTarget32);
			cmd.DispatchCompute(exposureCS, exposurePreparationKernel, 32, 32, 1);
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._ExposureParams, data.exposureParams);
			if (data.exposureMode == ExposureMode.Automatic)
			{
				data.exposureVariants[3] = 1;
			}
			else if (data.exposureMode == ExposureMode.CurveMapping)
			{
				cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._ExposureCurveTexture, data.exposureCurve);
				data.exposureVariants[3] = 2;
			}
			cmd.SetComputeVectorParam(exposureCS, HDShaderIDs._AdaptationParams, data.adaptationParams);
			cmd.SetComputeIntParams(exposureCS, HDShaderIDs._Variants, data.exposureVariants);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._PreviousExposureTexture, data.prevExposure);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._InputTexture, data.tmpTarget32);
			cmd.SetComputeTextureParam(exposureCS, exposurePreparationKernel, HDShaderIDs._OutputTexture, data.nextExposure);
			cmd.DispatchCompute(exposureCS, exposurePreparationKernel, 1, 1, 1);
		}

		private static void DoHistogramBasedExposure(DynamicExposureData data, CommandBuffer cmd)
		{
			ComputeShader histogramExposureCS = data.histogramExposureCS;
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._ProceduralMaskParams, data.proceduralMaskParams);
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._ProceduralMaskParams2, data.proceduralMaskParams2);
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._HistogramExposureParams, data.histogramExposureParams);
			int exposurePreparationKernel = data.exposurePreparationKernel;
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._PreviousExposureTexture, data.prevExposure);
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._SourceTexture, data.source);
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._ExposureWeightMask, data.textureMeteringMask);
			cmd.SetComputeIntParams(histogramExposureCS, HDShaderIDs._Variants, data.exposureVariants);
			cmd.SetComputeBufferParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._HistogramBuffer, data.histogramBuffer);
			int y = 16;
			int y2 = 8;
			int threadGroupsX = HDUtils.DivRoundUp(data.viewportSize.x / 2, y);
			int threadGroupsY = HDUtils.DivRoundUp(data.viewportSize.y / 2, y2);
			cmd.DispatchCompute(histogramExposureCS, exposurePreparationKernel, threadGroupsX, threadGroupsY, 1);
			exposurePreparationKernel = data.exposureReductionKernel;
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._ExposureParams, data.exposureParams);
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._ExposureParams2, data.exposureParams2);
			cmd.SetComputeVectorParam(histogramExposureCS, HDShaderIDs._AdaptationParams, data.adaptationParams);
			cmd.SetComputeBufferParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._HistogramBuffer, data.histogramBuffer);
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._PreviousExposureTexture, data.prevExposure);
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._OutputTexture, data.nextExposure);
			cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._ExposureCurveTexture, data.exposureCurve);
			data.exposureVariants[3] = 0;
			if (data.histogramUsesCurve)
			{
				data.exposureVariants[3] = 2;
			}
			cmd.SetComputeIntParams(histogramExposureCS, HDShaderIDs._Variants, data.exposureVariants);
			if (data.histogramOutputDebugData)
			{
				cmd.SetComputeTextureParam(histogramExposureCS, exposurePreparationKernel, HDShaderIDs._ExposureDebugTexture, data.exposureDebugData);
			}
			cmd.DispatchCompute(histogramExposureCS, exposurePreparationKernel, 1, 1, 1);
		}

		private TextureHandle DynamicExposurePass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			TextureHandle prevExposure = TextureHandle.nullHandle;
			if (!IsExposureFixed(hdCamera) && hdCamera.exposureControlFS)
			{
				DynamicExposureData passData;
				RenderGraphBuilder builder = renderGraph.AddRenderPass<DynamicExposureData>("Dynamic Exposure", out passData, ProfilingSampler.Get(HDProfileId.DynamicExposure));
				try
				{
					PrepareExposurePassData(renderGraph, builder, hdCamera, source, passData);
					if (m_Exposure.mode.value == ExposureMode.AutomaticHistogram)
					{
						DynamicExposureData dynamicExposureData = passData;
						TextureHandle input = renderGraph.ImportTexture(m_DebugExposureData);
						dynamicExposureData.exposureDebugData = builder.WriteTexture(in input);
						builder.SetRenderFunc(delegate(DynamicExposureData data, RenderGraphContext ctx)
						{
							DoHistogramBasedExposure(data, ctx.cmd);
						});
						prevExposure = passData.nextExposure;
					}
					else
					{
						DynamicExposureData dynamicExposureData2 = passData;
						TextureDesc desc = new TextureDesc(1024, 1024)
						{
							colorFormat = GraphicsFormat.R16G16_SFloat,
							enableRandomWrite = true,
							name = "Average Luminance Temp 1024"
						};
						dynamicExposureData2.tmpTarget1024 = builder.CreateTransientTexture(in desc);
						DynamicExposureData dynamicExposureData3 = passData;
						desc = new TextureDesc(32, 32)
						{
							colorFormat = GraphicsFormat.R16G16_SFloat,
							enableRandomWrite = true,
							name = "Average Luminance Temp 32"
						};
						dynamicExposureData3.tmpTarget32 = builder.CreateTransientTexture(in desc);
						builder.SetRenderFunc(delegate(DynamicExposureData data, RenderGraphContext ctx)
						{
							DoDynamicExposure(data, ctx.cmd);
						});
						prevExposure = passData.nextExposure;
					}
				}
				finally
				{
					((IDisposable)builder).Dispose();
				}
				if (hdCamera.resetPostProcessingHistory)
				{
					ApplyExposureData passData2;
					using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ApplyExposureData>("Apply Exposure", out passData2, ProfilingSampler.Get(HDProfileId.ApplyExposure));
					passData2.applyExposureCS = defaultResources.shaders.applyExposureCS;
					passData2.applyExposureCS.shaderKeywords = null;
					passData2.applyExposureKernel = passData2.applyExposureCS.FindKernel("KMain");
					if (PostProcessEnableAlpha(hdCamera))
					{
						passData2.applyExposureCS.EnableKeyword("ENABLE_ALPHA");
					}
					passData2.width = postProcessViewportSize.x;
					passData2.height = postProcessViewportSize.y;
					passData2.width = hdCamera.actualWidth;
					passData2.height = hdCamera.actualHeight;
					passData2.viewCount = hdCamera.viewCount;
					passData2.source = renderGraphBuilder.ReadTexture(in source);
					passData2.prevExposure = prevExposure;
					TextureHandle input2 = GetPostprocessOutputHandle(hdCamera, renderGraph, "Apply Exposure Destination");
					passData2.destination = renderGraphBuilder.WriteTexture(in input2);
					renderGraphBuilder.SetRenderFunc(delegate(ApplyExposureData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeTextureParam(data.applyExposureCS, data.applyExposureKernel, HDShaderIDs._ExposureTexture, data.prevExposure);
						ctx.cmd.SetComputeTextureParam(data.applyExposureCS, data.applyExposureKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeTextureParam(data.applyExposureCS, data.applyExposureKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.DispatchCompute(data.applyExposureCS, data.applyExposureKernel, (data.width + 7) / 8, (data.height + 7) / 8, data.viewCount);
					});
					source = passData2.destination;
				}
			}
			return source;
		}

		private void DoUserAfterOpaqueAndSky(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectors)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.CustomPostProcess))
			{
				return;
			}
			using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(HDProfileId.CustomPostProcessAfterOpaqueAndSky)))
			{
				TextureHandle source = colorBuffer;
				if (DoCustomPostProcess(renderGraph, hdCamera, ref source, depthBuffer, normalBuffer, motionVectors, m_GlobalSettings.beforeTransparentCustomPostProcesses))
				{
					BlitCameraTexture(renderGraph, source, colorBuffer);
				}
			}
		}

		private bool DoCustomPostProcess(RenderGraph renderGraph, HDCamera hdCamera, ref TextureHandle source, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectors, List<string> postProcessList)
		{
			bool result = false;
			foreach (string postProcess in postProcessList)
			{
				Type type = Type.GetType(postProcess);
				if (type == null || !(hdCamera.volumeStack.GetComponent(type) is CustomPostProcessVolumeComponent customPostProcessVolumeComponent))
				{
					continue;
				}
				customPostProcessVolumeComponent.SetupIfNeeded();
				if (!(customPostProcessVolumeComponent is IPostProcessComponent postProcessComponent) || !postProcessComponent.IsActive() || (hdCamera.camera.cameraType == CameraType.SceneView && !customPostProcessVolumeComponent.visibleInSceneView))
				{
					continue;
				}
				string passName = (string.IsNullOrEmpty(customPostProcessVolumeComponent.name) ? customPostProcessVolumeComponent.typeName : customPostProcessVolumeComponent.name);
				CustomPostProcessData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CustomPostProcessData>(passName, out passData);
				try
				{
					passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
					passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
					passData.motionVecTexture = renderGraphBuilder.ReadTexture(in motionVectors);
					passData.source = renderGraphBuilder.ReadTexture(in source);
					CustomPostProcessData customPostProcessData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
					{
						colorFormat = GetPostprocessTextureFormat(hdCamera),
						enableRandomWrite = true,
						name = "CustomPostProcesDestination"
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					customPostProcessData.destination = renderGraphBuilder.UseColorBuffer(in input, 0);
					passData.hdCamera = hdCamera;
					passData.customPostProcess = customPostProcessVolumeComponent;
					passData.postProcessScales = new Vector4(hdCamera.postProcessRTScales.x, hdCamera.postProcessRTScales.y, hdCamera.postProcessRTScalesHistory.z, hdCamera.postProcessRTScalesHistory.w);
					passData.postProcessViewportSize = postProcessViewportSize;
					renderGraphBuilder.SetRenderFunc(delegate(CustomPostProcessData data, RenderGraphContext ctx)
					{
						RTHandle rTHandle = data.source;
						RTHandle rTHandle2 = data.destination;
						RTHandleProperties properties = rTHandle.rtHandleProperties;
						properties.rtHandleScale = data.postProcessScales;
						properties.currentRenderTargetSize = data.postProcessViewportSize;
						properties.previousRenderTargetSize = data.postProcessViewportSize;
						properties.currentViewportSize = data.postProcessViewportSize;
						rTHandle.SetCustomHandleProperties(in properties);
						rTHandle2.SetCustomHandleProperties(in properties);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, data.depthBuffer);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._CameraMotionVectorsTexture, data.motionVecTexture);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._CustomPostProcessInput, data.source);
						data.customPostProcess.Render(ctx.cmd, data.hdCamera, data.source, data.destination);
						rTHandle.ClearCustomHandleProperties();
						rTHandle2.ClearCustomHandleProperties();
					});
					result = true;
					source = passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return result;
		}

		private TextureHandle CustomPostProcessPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectors, List<string> postProcessList, HDProfileId profileId)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.CustomPostProcess))
			{
				return source;
			}
			using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(profileId)))
			{
				DoCustomPostProcess(renderGraph, hdCamera, ref source, depthBuffer, normalBuffer, motionVectors, postProcessList);
				return source;
			}
		}

		private bool GrabTemporalAntialiasingHistoryTextures(HDCamera camera, out RTHandle previous, out RTHandle next, bool postDoF = false)
		{
			HDCameraFrameHistoryType historyType = (postDoF ? HDCameraFrameHistoryType.TemporalAntialiasingPostDoF : HDCameraFrameHistoryType.TemporalAntialiasing);
			return GrabPostProcessHistoryTextures(camera, historyType, "TAA History", GetPostprocessTextureFormat(camera), out previous, out next);
		}

		private bool GrabVelocityMagnitudeHistoryTextures(HDCamera camera, out RTHandle previous, out RTHandle next)
		{
			return GrabPostProcessHistoryTextures(camera, HDCameraFrameHistoryType.TAAMotionVectorMagnitude, "Velocity magnitude", GraphicsFormat.R16_SFloat, out previous, out next);
		}

		private void ReleasePostDoFTAAHistoryTextures(HDCamera camera)
		{
			if (camera.GetCurrentFrameRT(18) != null)
			{
				camera.ReleaseHistoryFrameRT(18);
			}
		}

		private void PrepareTAAPassData(RenderGraph renderGraph, RenderGraphBuilder builder, TemporalAntiAliasingData passData, HDCamera camera, TextureHandle depthBuffer, TextureHandle motionVectors, TextureHandle depthBufferMipChain, TextureHandle sourceTexture, TextureHandle stencilTexture, bool postDoF, string outputName)
		{
			passData.resetPostProcessingHistory = camera.resetPostProcessingHistory;
			float a = 0f;
			float num = 3.5f;
			float z = Mathf.Lerp(0f, 250f, camera.taaMotionVectorRejection * camera.taaMotionVectorRejection * camera.taaMotionVectorRejection);
			float w = 0.7f - Mathf.Lerp(0f, 0.3f, Mathf.SmoothStep(0.5f, 1f, camera.taaAntiFlicker));
			bool flag = camera.IsTAAUEnabled();
			bool flag2 = resGroup == ResolutionGroup.AfterDynamicResUpscale;
			float num2 = camera.taaAntiFlicker;
			float x = ((flag && postDoF) ? 0.25f : camera.taaHistorySharpening);
			if (camera.camera.cameraType == CameraType.SceneView)
			{
				x = 0.25f;
				num2 = 0.7f;
			}
			float y = (postDoF ? num : Mathf.Lerp(a, num, num2));
			float num3 = Mathf.Clamp01((num2 - 0.51f) / 0.49f);
			passData.taaParameters = new Vector4(x, y, z, w);
			float num4 = 0f;
			for (int i = 0; i < 9; i++)
			{
				Vector2 vector = camera.taaJitter;
				float num5 = (float)TAASampleOffsets[i].x + vector.x;
				float num6 = (float)TAASampleOffsets[i].y + vector.y;
				float num7 = num5 * num5 + num6 * num6;
				taaSampleWeights[i] = Mathf.Exp(-2.2727273f * num7);
				num4 += taaSampleWeights[i];
			}
			for (int j = 0; j < 9; j++)
			{
				taaSampleWeights[j] /= num4;
			}
			float num8 = (postDoF ? (camera.taaBaseBlendFactor * 1.5714285f + -19f / 35f) : camera.taaBaseBlendFactor);
			passData.taaParameters1 = new Vector4((camera.camera.cameraType == CameraType.SceneView) ? 0.2f : (1f - num8), taaSampleWeights[0], 2f, num3);
			passData.taaFilterWeights = taaSampleWeights;
			passData.temporalAAMaterial = m_TemporalAAMaterial;
			passData.temporalAAMaterial.shaderKeywords = null;
			if (PostProcessEnableAlpha(camera))
			{
				passData.temporalAAMaterial.EnableKeyword("ENABLE_ALPHA");
			}
			if (camera.taaHistorySharpening == 0f)
			{
				passData.temporalAAMaterial.EnableKeyword("FORCE_BILINEAR_HISTORY");
			}
			if (camera.taaHistorySharpening != 0f && camera.taaAntiRinging && camera.TAAQuality == HDAdditionalCameraData.TAAQualityLevel.High)
			{
				passData.temporalAAMaterial.EnableKeyword("ANTI_RINGING");
			}
			passData.motionVectorRejection = camera.taaMotionVectorRejection > 0f;
			if (passData.motionVectorRejection)
			{
				passData.temporalAAMaterial.EnableKeyword("ENABLE_MV_REJECTION");
			}
			if (num3 > 0f)
			{
				passData.temporalAAMaterial.EnableKeyword("HISTORY_CONTRAST_ANTI_FLICKER");
			}
			passData.runsTAAU = flag;
			passData.runsAfterUpscale = flag2;
			if (flag && !postDoF)
			{
				passData.temporalAAMaterial.EnableKeyword("TAA_UPSCALE");
			}
			else if (postDoF)
			{
				passData.temporalAAMaterial.EnableKeyword("POST_DOF");
			}
			else
			{
				switch (camera.TAAQuality)
				{
				case HDAdditionalCameraData.TAAQualityLevel.Low:
					passData.temporalAAMaterial.EnableKeyword("LOW_QUALITY");
					break;
				case HDAdditionalCameraData.TAAQualityLevel.Medium:
					passData.temporalAAMaterial.EnableKeyword("MEDIUM_QUALITY");
					break;
				case HDAdditionalCameraData.TAAQualityLevel.High:
					passData.temporalAAMaterial.EnableKeyword("HIGH_QUALITY");
					break;
				default:
					passData.temporalAAMaterial.EnableKeyword("MEDIUM_QUALITY");
					break;
				}
			}
			if (flag || flag2)
			{
				passData.temporalAAMaterial.EnableKeyword("DIRECT_STENCIL_SAMPLE");
			}
			new Vector2Int((int)passData.finalViewport.width, (int)passData.finalViewport.height);
			RTHandle previous;
			RTHandle next;
			bool flag3 = GrabTemporalAntialiasingHistoryTextures(camera, out previous, out next, postDoF);
			Vector2Int previousViewportSize = camera.historyRTHandleProperties.previousViewportSize;
			passData.previousScreenSize = new Vector4(previousViewportSize.x, previousViewportSize.y, 1f / (float)previousViewportSize.x, 1f / (float)previousViewportSize.y);
			if (flag || flag2)
			{
				passData.previousScreenSize = new Vector4(camera.finalViewport.width, camera.finalViewport.height, 1f / camera.finalViewport.width, 1f / camera.finalViewport.height);
			}
			passData.source = builder.ReadTexture(in sourceTexture);
			passData.depthBuffer = builder.ReadTexture(in depthBuffer);
			passData.motionVecTexture = builder.ReadTexture(in motionVectors);
			passData.depthMipChain = builder.ReadTexture(in depthBufferMipChain);
			TextureHandle input = renderGraph.ImportTexture(previous);
			passData.prevHistory = builder.ReadTexture(in input);
			passData.resetPostProcessingHistory = passData.resetPostProcessingHistory || !flag3;
			if (passData.resetPostProcessingHistory)
			{
				passData.prevHistory = builder.WriteTexture(in passData.prevHistory);
			}
			input = renderGraph.ImportTexture(next);
			passData.nextHistory = builder.WriteTexture(in input);
			GrabVelocityMagnitudeHistoryTextures(camera, out var previous2, out var next2);
			input = renderGraph.ImportTexture(previous2);
			passData.prevMVLen = builder.ReadTexture(in input);
			TextureHandle nextMVLen;
			if (postDoF)
			{
				nextMVLen = TextureHandle.nullHandle;
			}
			else
			{
				input = renderGraph.ImportTexture(next2);
				nextMVLen = builder.WriteTexture(in input);
			}
			passData.nextMVLen = nextMVLen;
			TextureHandle input2 = ((!flag || !DynamicResolutionHandler.instance.HardwareDynamicResIsEnabled()) ? GetPostprocessOutputHandle(camera, renderGraph, outputName) : GetPostprocessUpsampledOutputHandle(camera, renderGraph, outputName));
			passData.destination = builder.WriteTexture(in input2);
			bool flag4 = camera.resetPostProcessingHistory || flag != camera.previousFrameWasTAAUpsampled;
			passData.prevFinalViewport = ((camera.prevFinalViewport.width < 0f || flag4) ? camera.finalViewport : camera.prevFinalViewport);
			Vector2 vector2 = RTHandles.CalculateRatioAgainstMaxSize(camera.actualWidth, camera.actualHeight);
			Vector2 vector3 = ((flag || flag2) ? new Vector2(passData.prevFinalViewport.width, passData.prevFinalViewport.height) : ((Vector2)(flag4 ? RTHandles.rtHandleProperties.currentViewportSize : camera.historyRTHandleProperties.previousViewportSize)));
			passData.finalViewport = ((flag || flag2) ? camera.finalViewport : new Rect(0f, 0f, RTHandles.rtHandleProperties.currentViewportSize.x, RTHandles.rtHandleProperties.currentViewportSize.y));
			if (flag2)
			{
				vector2 = RTHandles.CalculateRatioAgainstMaxSize((int)camera.finalViewport.width, (int)camera.finalViewport.height);
			}
			Vector4 taaScales = new Vector4(vector3.x / (float)previous.rt.width, vector3.y / (float)previous.rt.height, vector2.x, vector2.y);
			passData.taaScales = taaScales;
			float currentScale = DynamicResolutionHandler.instance.GetCurrentScale();
			float num9 = 0.4f;
			passData.taauParams = new Vector4(1f / (num9 * num9), 1f / currentScale, 0.5f / currentScale, currentScale);
			passData.stencilBuffer = builder.ReadTexture(in stencilTexture);
			passData.msaaIsEnabled = camera.msaaEnabled;
		}

		private TextureHandle DoTemporalAntialiasing(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle motionVectors, TextureHandle depthBufferMipChain, TextureHandle sourceTexture, TextureHandle stencilBuffer, bool postDoF, string outputName)
		{
			TemporalAntiAliasingData passData;
			using RenderGraphBuilder builder = renderGraph.AddRenderPass<TemporalAntiAliasingData>("Temporal Anti-Aliasing", out passData, ProfilingSampler.Get(HDProfileId.TemporalAntialiasing));
			PrepareTAAPassData(renderGraph, builder, passData, hdCamera, depthBuffer, motionVectors, depthBufferMipChain, sourceTexture, stencilBuffer, postDoF, outputName);
			builder.SetRenderFunc(delegate(TemporalAntiAliasingData data, RenderGraphContext ctx)
			{
				RTHandle rTHandle = data.source;
				RTHandle rTHandle2 = data.nextMVLen;
				RTHandle rTHandle3 = data.prevMVLen;
				_ = (RTHandle)data.prevHistory;
				_ = (RTHandle)data.nextHistory;
				if (data.resetPostProcessingHistory)
				{
					MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputTexture, rTHandle);
					tempMaterialPropertyBlock.SetVector(HDShaderIDs._TaaScales, data.taaScales);
					if (data.runsTAAU || data.runsAfterUpscale)
					{
						Rect finalViewport = data.finalViewport;
						HDUtils.DrawFullScreen(ctx.cmd, finalViewport, data.temporalAAMaterial, data.prevHistory, tempMaterialPropertyBlock, 3);
						HDUtils.DrawFullScreen(ctx.cmd, finalViewport, data.temporalAAMaterial, data.nextHistory, tempMaterialPropertyBlock, 3);
					}
					else
					{
						HDUtils.DrawFullScreen(ctx.cmd, data.temporalAAMaterial, data.prevHistory, tempMaterialPropertyBlock, 3);
						HDUtils.DrawFullScreen(ctx.cmd, data.temporalAAMaterial, data.nextHistory, tempMaterialPropertyBlock, 3);
					}
				}
				MaterialPropertyBlock tempMaterialPropertyBlock2 = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				tempMaterialPropertyBlock2.SetInt(HDShaderIDs._StencilMask, 2);
				tempMaterialPropertyBlock2.SetInt(HDShaderIDs._StencilRef, 2);
				tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._CameraMotionVectorsTexture, data.motionVecTexture);
				tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._InputTexture, rTHandle);
				tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._InputHistoryTexture, data.prevHistory);
				if (rTHandle3 != null && data.motionVectorRejection)
				{
					tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._InputVelocityMagnitudeHistory, rTHandle3);
				}
				tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._DepthTexture, data.depthMipChain);
				Vector4 previousScreenSize = data.previousScreenSize;
				tempMaterialPropertyBlock2.SetVector(HDShaderIDs._TaaPostParameters, data.taaParameters);
				tempMaterialPropertyBlock2.SetVector(HDShaderIDs._TaaPostParameters1, data.taaParameters1);
				tempMaterialPropertyBlock2.SetVector(HDShaderIDs._TaaHistorySize, previousScreenSize);
				tempMaterialPropertyBlock2.SetFloatArray(HDShaderIDs._TaaFilterWeights, data.taaFilterWeights);
				tempMaterialPropertyBlock2.SetVector(HDShaderIDs._TaauParameters, data.taauParams);
				tempMaterialPropertyBlock2.SetVector(HDShaderIDs._TaaScales, data.taaScales);
				if (data.runsTAAU || data.runsAfterUpscale)
				{
					CoreUtils.SetRenderTarget(ctx.cmd, data.destination);
				}
				else
				{
					CoreUtils.SetRenderTarget(ctx.cmd, data.destination, data.depthBuffer);
				}
				ctx.cmd.SetRandomWriteTarget(1, data.nextHistory);
				if (rTHandle2 != null && data.motionVectorRejection)
				{
					ctx.cmd.SetRandomWriteTarget(2, rTHandle2);
				}
				Rect finalViewport2 = data.finalViewport;
				finalViewport2.x = 0f;
				finalViewport2.y = 0f;
				if (data.runsTAAU || data.runsAfterUpscale)
				{
					if (data.msaaIsEnabled)
					{
						tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._StencilTexture, ctx.defaultResources.blackTextureXR);
					}
					else
					{
						tempMaterialPropertyBlock2.SetTexture(HDShaderIDs._StencilTexture, data.stencilBuffer, RenderTextureSubElement.Stencil);
					}
					HDUtils.DrawFullScreen(ctx.cmd, finalViewport2, data.temporalAAMaterial, data.destination, tempMaterialPropertyBlock2, 2);
				}
				else
				{
					ctx.cmd.SetViewport(finalViewport2);
					ctx.cmd.DrawProcedural(Matrix4x4.identity, data.temporalAAMaterial, 0, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock2);
					ctx.cmd.DrawProcedural(Matrix4x4.identity, data.temporalAAMaterial, 1, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock2);
				}
				ctx.cmd.ClearRandomWriteTargets();
			});
			return passData.destination;
		}

		private TextureHandle SMAAPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle source)
		{
			SMAAData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SMAAData>("Subpixel Morphological Anti-Aliasing", out passData, ProfilingSampler.Get(HDProfileId.SMAA));
			try
			{
				passData.smaaMaterial = m_SMAAMaterial;
				passData.smaaAreaTex = defaultResources.textures.SMAAAreaTex;
				passData.smaaSearchTex = defaultResources.textures.SMAASearchTex;
				passData.smaaMaterial.shaderKeywords = null;
				passData.smaaRTMetrics = new Vector4(1f / (float)postProcessViewportSize.x, 1f / (float)postProcessViewportSize.y, postProcessViewportSize.x, postProcessViewportSize.y);
				switch (hdCamera.SMAAQuality)
				{
				case HDAdditionalCameraData.SMAAQualityLevel.Low:
					passData.smaaMaterial.EnableKeyword("SMAA_PRESET_LOW");
					break;
				case HDAdditionalCameraData.SMAAQualityLevel.Medium:
					passData.smaaMaterial.EnableKeyword("SMAA_PRESET_MEDIUM");
					break;
				case HDAdditionalCameraData.SMAAQualityLevel.High:
					passData.smaaMaterial.EnableKeyword("SMAA_PRESET_HIGH");
					break;
				default:
					passData.smaaMaterial.EnableKeyword("SMAA_PRESET_HIGH");
					break;
				}
				passData.source = renderGraphBuilder.ReadTexture(in source);
				passData.depthBuffer = renderGraphBuilder.ReadWriteTexture(in depthBuffer);
				SMAAData sMAAData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "SMAA Edge Texture"
				};
				sMAAData.smaaEdgeTex = renderGraphBuilder.CreateTransientTexture(in desc);
				SMAAData sMAAData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
					enableRandomWrite = true,
					clearBuffer = true,
					name = "SMAA Blend Texture"
				};
				sMAAData2.smaaBlendTex = renderGraphBuilder.CreateTransientTexture(in desc);
				TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "SMAA Destination");
				passData.destination = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(SMAAData data, RenderGraphContext ctx)
				{
					data.smaaMaterial.SetVector(HDShaderIDs._SMAARTMetrics, data.smaaRTMetrics);
					data.smaaMaterial.SetTexture(HDShaderIDs._SMAAAreaTex, data.smaaAreaTex);
					data.smaaMaterial.SetTexture(HDShaderIDs._SMAASearchTex, data.smaaSearchTex);
					data.smaaMaterial.SetInt(HDShaderIDs._StencilRef, 4);
					data.smaaMaterial.SetInt(HDShaderIDs._StencilMask, 4);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._InputTexture, data.source);
					HDUtils.DrawFullScreen(ctx.cmd, data.smaaMaterial, data.smaaEdgeTex, data.depthBuffer);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._InputTexture, data.smaaEdgeTex);
					HDUtils.DrawFullScreen(ctx.cmd, data.smaaMaterial, data.smaaBlendTex, data.depthBuffer, null, 1);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._InputTexture, data.source);
					data.smaaMaterial.SetTexture(HDShaderIDs._SMAABlendTex, data.smaaBlendTex);
					HDUtils.DrawFullScreen(ctx.cmd, data.smaaMaterial, data.destination, null, 2);
				});
				return passData.destination;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private DepthOfFieldParameters PrepareDoFParameters(HDCamera hdCamera)
		{
			DepthOfFieldParameters result = default(DepthOfFieldParameters);
			result.dofKernelCS = defaultResources.shaders.depthOfFieldKernelCS;
			result.dofKernelKernel = result.dofKernelCS.FindKernel("KParametricBlurKernel");
			result.dofCoCCS = defaultResources.shaders.depthOfFieldCoCCS;
			result.dofCoCReprojectCS = defaultResources.shaders.depthOfFieldCoCReprojectCS;
			result.dofCoCReprojectKernel = result.dofCoCReprojectCS.FindKernel("KMain");
			result.dofDilateCS = defaultResources.shaders.depthOfFieldDilateCS;
			result.dofDilateKernel = result.dofDilateCS.FindKernel("KMain");
			result.dofMipCS = defaultResources.shaders.depthOfFieldMipCS;
			if (!m_DepthOfField.physicallyBased)
			{
				result.dofMipColorKernel = result.dofMipCS.FindKernel(PostProcessEnableAlpha(hdCamera) ? "KMainColorAlpha" : "KMainColor");
			}
			else
			{
				result.dofMipColorKernel = result.dofMipCS.FindKernel(PostProcessEnableAlpha(hdCamera) ? "KMainColorCopyAlpha" : "KMainColorCopy");
			}
			result.dofMipCoCKernel = result.dofMipCS.FindKernel("KMainCoC");
			result.dofMipSafeCS = defaultResources.shaders.depthOfFieldMipSafeCS;
			result.dofPrefilterCS = defaultResources.shaders.depthOfFieldPrefilterCS;
			result.dofTileMaxCS = defaultResources.shaders.depthOfFieldTileMaxCS;
			result.dofTileMaxKernel = result.dofTileMaxCS.FindKernel("KMain");
			result.dofGatherCS = defaultResources.shaders.depthOfFieldGatherCS;
			result.dofGatherNearKernel = result.dofGatherCS.FindKernel("KMainNear");
			result.dofGatherFarKernel = result.dofGatherCS.FindKernel("KMainFar");
			result.dofCombineCS = defaultResources.shaders.depthOfFieldCombineCS;
			result.dofCombineKernel = result.dofCombineCS.FindKernel("KMain");
			result.dofPrecombineFarCS = defaultResources.shaders.depthOfFieldPreCombineFarCS;
			result.dofPrecombineFarKernel = result.dofPrecombineFarCS.FindKernel("KMainPreCombineFar");
			result.dofClearIndirectArgsCS = defaultResources.shaders.depthOfFieldClearIndirectArgsCS;
			result.dofClearIndirectArgsKernel = result.dofClearIndirectArgsCS.FindKernel("KClear");
			result.dofCircleOfConfusionCS = defaultResources.shaders.dofCircleOfConfusion;
			result.pbDoFCoCMinMaxCS = defaultResources.shaders.dofCoCMinMaxCS;
			result.pbDoFMinMaxKernel = result.pbDoFCoCMinMaxCS.FindKernel("KMainCoCMinMax");
			result.pbDoFDilateCS = defaultResources.shaders.dofMinMaxDilateCS;
			result.pbDoFDilateKernel = result.pbDoFDilateCS.FindKernel("KMain");
			result.pbDoFGatherCS = defaultResources.shaders.dofGatherCS;
			result.pbDoFGatherKernel = result.pbDoFGatherCS.FindKernel("KMain");
			result.pbDoFCombineCS = defaultResources.shaders.dofCombineCS;
			result.pbDoFCombineKernel = result.pbDoFGatherCS.FindKernel("KMain");
			result.minMaxCoCTileSize = 8;
			result.camera = hdCamera;
			result.viewportSize = postProcessViewportSize;
			result.resetPostProcessingHistory = hdCamera.resetPostProcessingHistory;
			result.nearLayerActive = m_DepthOfField.IsNearLayerActive();
			result.farLayerActive = m_DepthOfField.IsFarLayerActive();
			result.highQualityFiltering = m_DepthOfField.highQualityFiltering;
			result.useTiles = !hdCamera.xr.singlePassEnabled;
			result.resolution = m_DepthOfField.resolution;
			float num = (m_DepthOfField.physicallyBased ? 1f : (1f / (float)result.resolution));
			float num2 = (float)postProcessViewportSize.y / 1080f * (num * 2f);
			int b = Mathf.CeilToInt((float)m_DepthOfField.farSampleCount * num2);
			int b2 = Mathf.CeilToInt((float)m_DepthOfField.nearSampleCount * num2);
			result.farSampleCount = Mathf.Max(3, b);
			result.nearSampleCount = Mathf.Max(3, b2);
			result.farMaxBlur = m_DepthOfField.farMaxBlur;
			result.nearMaxBlur = m_DepthOfField.nearMaxBlur;
			int num3 = Mathf.RoundToInt((float)postProcessViewportSize.x * num);
			int num4 = Mathf.RoundToInt((float)postProcessViewportSize.y * num);
			int x = (num3 + 7) / 8;
			int y = (num4 + 7) / 8;
			result.threadGroup8 = new Vector2Int(x, y);
			Camera camera = hdCamera.camera;
			result.physicalCameraCurvature = camera.curvature;
			result.physicalCameraAnamorphism = camera.anamorphism;
			result.physicalCameraAperture = camera.aperture;
			result.physicalCameraBarrelClipping = camera.barrelClipping;
			result.physicalCameraBladeCount = camera.bladeCount;
			result.nearFocusStart = m_DepthOfField.nearFocusStart.value;
			result.nearFocusEnd = m_DepthOfField.nearFocusEnd.value;
			result.farFocusStart = m_DepthOfField.farFocusStart.value;
			result.farFocusEnd = m_DepthOfField.farFocusEnd.value;
			if (m_DepthOfField.focusDistanceMode.value == FocusDistanceMode.Volume)
			{
				result.focusDistance = m_DepthOfField.focusDistance.value;
			}
			else
			{
				result.focusDistance = hdCamera.camera.focusDistance;
			}
			result.focusMode = m_DepthOfField.focusMode.value;
			if (result.focusMode == DepthOfFieldMode.UsePhysicalCamera)
			{
				result.dofCoCKernel = result.dofCoCCS.FindKernel("KMainPhysical");
				result.dofCircleOfConfusionKernel = result.dofCircleOfConfusionCS.FindKernel("KMainCoCPhysical");
			}
			else
			{
				result.dofCoCKernel = result.dofCoCCS.FindKernel("KMainManual");
				result.dofCircleOfConfusionKernel = result.dofCircleOfConfusionCS.FindKernel("KMainCoCManual");
			}
			result.dofPrefilterCS.shaderKeywords = null;
			result.dofPrefilterKernel = result.dofPrefilterCS.FindKernel("KMain");
			result.dofMipSafeCS.shaderKeywords = null;
			result.dofMipSafeKernel = result.dofMipSafeCS.FindKernel("KMain");
			result.dofTileMaxCS.shaderKeywords = null;
			result.dofGatherCS.shaderKeywords = null;
			result.dofCombineCS.shaderKeywords = null;
			result.dofPrecombineFarCS.shaderKeywords = null;
			result.dofCombineCS.shaderKeywords = null;
			result.pbDoFGatherCS.shaderKeywords = null;
			result.dofCoCReprojectCS.shaderKeywords = null;
			result.dofCoCCS.shaderKeywords = null;
			result.dofCircleOfConfusionCS.shaderKeywords = null;
			bool nearLayerActive = result.nearLayerActive;
			bool farLayerActive = result.farLayerActive;
			bool num5 = nearLayerActive && farLayerActive;
			if (m_EnableAlpha)
			{
				result.dofPrefilterCS.EnableKeyword("ENABLE_ALPHA");
				result.dofMipSafeCS.EnableKeyword("ENABLE_ALPHA");
				result.dofGatherCS.EnableKeyword("ENABLE_ALPHA");
				result.dofCombineCS.EnableKeyword("ENABLE_ALPHA");
				result.dofPrecombineFarCS.EnableKeyword("ENABLE_ALPHA");
				result.pbDoFGatherCS.EnableKeyword("ENABLE_ALPHA");
				result.pbDoFCombineCS.EnableKeyword("ENABLE_ALPHA");
			}
			if (result.resolution == DepthOfFieldResolution.Full)
			{
				result.dofPrefilterCS.EnableKeyword("FULL_RES");
				result.dofCombineCS.EnableKeyword("FULL_RES");
			}
			else if (result.highQualityFiltering)
			{
				result.dofPrefilterCS.EnableKeyword("HIGH_QUALITY");
				result.dofCombineCS.EnableKeyword("HIGH_QUALITY");
				result.dofGatherCS.EnableKeyword("LOW_RESOLUTION");
			}
			else
			{
				result.dofPrefilterCS.EnableKeyword("LOW_QUALITY");
				result.dofCombineCS.EnableKeyword("LOW_QUALITY");
				result.dofGatherCS.EnableKeyword("LOW_RESOLUTION");
			}
			if (num5 || nearLayerActive)
			{
				result.dofPrefilterCS.EnableKeyword("NEAR");
				result.dofTileMaxCS.EnableKeyword("NEAR");
				result.dofCombineCS.EnableKeyword("NEAR");
			}
			if (num5 || !nearLayerActive)
			{
				result.dofPrefilterCS.EnableKeyword("FAR");
				result.dofTileMaxCS.EnableKeyword("FAR");
				result.dofCombineCS.EnableKeyword("FAR");
			}
			if (result.useTiles)
			{
				result.dofGatherCS.EnableKeyword("USE_TILES");
			}
			if (m_DepthOfField.physicallyBased)
			{
				result.dofCoCReprojectCS.EnableKeyword("ENABLE_MAX_BLENDING");
				result.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet256SPP();
				result.resolution = (DepthOfFieldResolution)Math.Max((int)result.resolution, 2);
				if (result.resolution != DepthOfFieldResolution.Quarter)
				{
					result.pbDoFGatherCS.EnableKeyword("FORCE_POINT_SAMPLING");
					result.pbDoFCombineCS.EnableKeyword("FORCE_POINT_SAMPLING");
				}
				if (result.highQualityFiltering)
				{
					result.pbDoFGatherCS.EnableKeyword("HIGH_QUALITY");
				}
				result.adaptiveSamplingWeights = (result.highQualityFiltering ? DepthOfField.s_HighQualityAdaptiveSamplingWeights : DepthOfField.s_LowQualityAdaptiveSamplingWeights);
			}
			if (hdCamera.msaaEnabled)
			{
				result.dofCoCCS.EnableKeyword("USE_MIN_DEPTH");
				result.dofCircleOfConfusionCS.EnableKeyword("USE_MIN_DEPTH");
			}
			if (m_DepthOfField.limitManualRangeNearBlur && m_DepthOfField.focusMode == DepthOfFieldMode.Manual && !m_DepthOfField.physicallyBased && m_DepthOfField.IsNearLayerActive())
			{
				result.dofCoCCS.EnableKeyword("FIX_NEAR_BLEND");
			}
			result.useMipSafePath = m_UseSafePath;
			return result;
		}

		private static void GetDoFResolutionScale(in DepthOfFieldParameters dofParameters, out float scale, out float resolutionScale)
		{
			scale = 1f / (float)dofParameters.resolution;
			resolutionScale = (float)dofParameters.viewportSize.y / 1080f * 2f;
		}

		private static float GetDoFResolutionMaxMip(in DepthOfFieldParameters dofParameters)
		{
			return dofParameters.resolution switch
			{
				DepthOfFieldResolution.Full => 4f, 
				DepthOfFieldResolution.Half => 3f, 
				_ => 2f, 
			};
		}

		private static int GetDoFDilationPassCount(in DepthOfFieldParameters dofParameters, in float dofScale, in float nearMaxBlur)
		{
			return Mathf.CeilToInt((nearMaxBlur * dofScale + 2f) / 4f);
		}

		private static void DoDepthOfField(in DepthOfFieldParameters dofParameters, CommandBuffer cmd, RTHandle source, RTHandle destination, RTHandle depthBuffer, RTHandle pingNearRGB, RTHandle pongNearRGB, RTHandle nearCoC, RTHandle nearAlpha, RTHandle dilatedNearCoC, RTHandle pingFarRGB, RTHandle pongFarRGB, RTHandle farCoC, RTHandle fullresCoC, RTHandle[] mips, RTHandle dilationPingPong, RTHandle prevCoCHistory, RTHandle nextCoCHistory, RTHandle motionVecTexture, ComputeBuffer bokehNearKernel, ComputeBuffer bokehFarKernel, ComputeBuffer bokehIndirectCmd, ComputeBuffer nearBokehTileList, ComputeBuffer farBokehTileList, bool taaEnabled, RTHandle depthMinMaxAvgMSAA)
		{
			bool nearLayerActive = dofParameters.nearLayerActive;
			bool farLayerActive = dofParameters.farLayerActive;
			bool useTiles = dofParameters.useTiles;
			int physicalCameraBladeCount = dofParameters.physicalCameraBladeCount;
			float num = (dofParameters.physicalCameraAperture - 0.7f) / 31.3f;
			num *= 360f / (float)physicalCameraBladeCount * (MathF.PI / 180f);
			float value = 1f;
			if (dofParameters.physicalCameraCurvature.y - dofParameters.physicalCameraCurvature.x > 0f)
			{
				value = (dofParameters.physicalCameraAperture - dofParameters.physicalCameraCurvature.x) / (dofParameters.physicalCameraCurvature.y - dofParameters.physicalCameraCurvature.x);
			}
			value = Mathf.Clamp01(value);
			value = Mathf.Lerp(value, 0f, Mathf.Abs(dofParameters.physicalCameraAnamorphism));
			float x = dofParameters.physicalCameraAnamorphism / 4f;
			float z = dofParameters.physicalCameraBarrelClipping / 3f;
			GetDoFResolutionScale(in dofParameters, out var scale, out var resolutionScale);
			new Vector2(scale, scale);
			int num2 = Mathf.RoundToInt((float)dofParameters.viewportSize.x * scale);
			int num3 = Mathf.RoundToInt((float)dofParameters.viewportSize.y * scale);
			cmd.SetGlobalVector(HDShaderIDs._TargetScale, new Vector4((float)dofParameters.resolution, scale, 0f, 0f));
			int farSampleCount = dofParameters.farSampleCount;
			int nearSampleCount = dofParameters.nearSampleCount;
			float num4 = dofParameters.farMaxBlur * resolutionScale;
			float nearMaxBlur = dofParameters.nearMaxBlur * resolutionScale;
			Vector2 vector = (taaEnabled ? new Vector2(dofParameters.camera.postProcessRTScalesHistory.z, dofParameters.camera.postProcessRTScalesHistory.w) : dofParameters.camera.postProcessRTScales);
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldKernel)))
			{
				ComputeShader dofKernelCS = dofParameters.dofKernelCS;
				int dofKernelKernel = dofParameters.dofKernelKernel;
				if (nearLayerActive)
				{
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params1, new Vector4(nearSampleCount, value, physicalCameraBladeCount, num));
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params2, new Vector4(x, 0f, 0f, 0f));
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._BokehKernel, bokehNearKernel);
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, Mathf.CeilToInt((float)(nearSampleCount * nearSampleCount) / 64f), 1, 1);
				}
				if (farLayerActive)
				{
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params1, new Vector4(farSampleCount, value, physicalCameraBladeCount, num));
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params2, new Vector4(x, 0f, 0f, 0f));
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._BokehKernel, bokehFarKernel);
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, Mathf.CeilToInt((float)(farSampleCount * farSampleCount) / 64f), 1, 1);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldCoC)))
			{
				ComputeShader dofKernelCS = dofParameters.dofCoCCS;
				int dofKernelKernel = dofParameters.dofCoCKernel;
				if (dofParameters.focusMode == DepthOfFieldMode.UsePhysicalCamera)
				{
					float num5 = dofParameters.camera.camera.focalLength / 1000f;
					float num6 = dofParameters.camera.camera.focalLength / dofParameters.physicalCameraAperture;
					float focusDistance = dofParameters.focusDistance;
					float y = num6 * num5 / Mathf.Max(focusDistance - num5, 1E-06f);
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params, new Vector4(focusDistance, y, 0f, 0f));
				}
				else
				{
					float nearFocusEnd = dofParameters.nearFocusEnd;
					float x2 = Mathf.Min(dofParameters.nearFocusStart, nearFocusEnd - 1E-05f);
					float num7 = Mathf.Max(dofParameters.farFocusStart, nearFocusEnd);
					float w = Mathf.Max(dofParameters.farFocusEnd, num7 + 1E-05f);
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params, new Vector4(x2, nearFocusEnd, num7, w));
				}
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._CameraDepthTexture, depthBuffer);
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputCoCTexture, fullresCoC);
				if (dofParameters.camera.msaaEnabled)
				{
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._DepthMinMaxAvg, depthMinMaxAvgMSAA);
				}
				cmd.DispatchCompute(dofKernelCS, dofKernelKernel, (dofParameters.viewportSize.x + 7) / 8, (dofParameters.viewportSize.y + 7) / 8, dofParameters.camera.viewCount);
				if (taaEnabled)
				{
					ReprojectCoCHistory(in dofParameters, cmd, dofParameters.camera, prevCoCHistory, nextCoCHistory, motionVecTexture, ref fullresCoC);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldPrefilter)))
			{
				ComputeShader dofKernelCS = dofParameters.dofPrefilterCS;
				int dofKernelKernel = dofParameters.dofPrefilterKernel;
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, source);
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, fullresCoC);
				cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._CoCTargetScale, vector);
				if (nearLayerActive)
				{
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputNearCoCTexture, nearCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputNearTexture, pingNearRGB);
				}
				if (farLayerActive)
				{
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputFarCoCTexture, farCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputFarTexture, pingFarRGB);
				}
				cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
			}
			if (farLayerActive)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldPyramid)))
				{
					int threadGroupsX = ((num2 >> 1) + 7) / 8;
					int threadGroupsY = ((num3 >> 1) + 7) / 8;
					ComputeShader dofKernelCS;
					int dofKernelKernel;
					if (dofParameters.useMipSafePath)
					{
						dofKernelCS = dofParameters.dofMipSafeCS;
						dofKernelKernel = dofParameters.dofMipSafeKernel;
						float num8 = scale;
						for (int i = 0; i < 4; i++)
						{
							num8 *= 0.5f;
							Vector2Int vector2Int = new Vector2Int(Mathf.RoundToInt((float)dofParameters.viewportSize.x * num8), Mathf.RoundToInt((float)dofParameters.viewportSize.y * num8));
							RTHandle rTHandle = mips[i];
							cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._TexelSize, new Vector4(vector2Int.x, vector2Int.y, 1f / (float)vector2Int.x, 1f / (float)vector2Int.y));
							int threadGroupsX2 = (vector2Int.x + 7) / 8;
							int threadGroupsY2 = (vector2Int.y + 7) / 8;
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, pingFarRGB);
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, rTHandle);
							cmd.DispatchCompute(dofKernelCS, dofKernelKernel, threadGroupsX2, threadGroupsY2, dofParameters.camera.viewCount);
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, rTHandle);
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, pingFarRGB, i + 1);
							cmd.DispatchCompute(dofKernelCS, dofKernelKernel, threadGroupsX2, threadGroupsY2, dofParameters.camera.viewCount);
						}
					}
					else
					{
						dofKernelCS = dofParameters.dofMipCS;
						dofKernelKernel = dofParameters.dofMipColorKernel;
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, pingFarRGB, 0);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip1, pingFarRGB, 1);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip2, pingFarRGB, 2);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip3, pingFarRGB, 3);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip4, pingFarRGB, 4);
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, threadGroupsX, threadGroupsY, dofParameters.camera.viewCount);
					}
					dofKernelCS = dofParameters.dofMipCS;
					dofKernelKernel = dofParameters.dofMipCoCKernel;
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, farCoC, 0);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip1, farCoC, 1);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip2, farCoC, 2);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip3, farCoC, 3);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputMip4, farCoC, 4);
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, threadGroupsX, threadGroupsY, dofParameters.camera.viewCount);
				}
			}
			if (nearLayerActive)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldDilate)))
				{
					ComputeShader dofKernelCS = dofParameters.dofDilateCS;
					int dofKernelKernel = dofParameters.dofDilateKernel;
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params, new Vector4(num2 - 1, num3 - 1, 0f, 0f));
					int doFDilationPassCount = GetDoFDilationPassCount(in dofParameters, in scale, in nearMaxBlur);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, nearCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputCoCTexture, dilatedNearCoC);
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
					if (doFDilationPassCount > 1)
					{
						RTHandle a = dilatedNearCoC;
						RTHandle b = dilationPingPong;
						for (int j = 1; j < doFDilationPassCount; j++)
						{
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, a);
							cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputCoCTexture, b);
							cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
							CoreUtils.Swap(ref a, ref b);
						}
						dilatedNearCoC = a;
					}
				}
			}
			if (useTiles)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldTileMax)))
				{
					ComputeShader dofKernelCS = dofParameters.dofClearIndirectArgsCS;
					int dofKernelKernel = dofParameters.dofClearIndirectArgsKernel;
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._IndirectBuffer, bokehIndirectCmd);
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, 1, 1, 1);
					dofKernelCS = dofParameters.dofTileMaxCS;
					dofKernelKernel = dofParameters.dofTileMaxKernel;
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params, new Vector4(num2 - 1, num3 - 1, 0f, 0f));
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._IndirectBuffer, bokehIndirectCmd);
					if (nearLayerActive)
					{
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputNearCoCTexture, dilatedNearCoC);
						cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._NearTileList, nearBokehTileList);
					}
					if (farLayerActive)
					{
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputFarCoCTexture, farCoC);
						cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._FarTileList, farBokehTileList);
					}
					cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, 1);
				}
			}
			if (farLayerActive)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldGatherFar)))
				{
					if (useTiles)
					{
						cmd.SetRenderTarget(pongFarRGB);
						cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.clear);
					}
					ComputeShader dofKernelCS = dofParameters.dofGatherCS;
					int dofKernelKernel = dofParameters.dofGatherFarKernel;
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params1, new Vector4(farSampleCount, num4 * scale, z, num4));
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params2, new Vector4(GetDoFResolutionMaxMip(in dofParameters), 0f, 0f, 0f));
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._TexelSize, new Vector4(num2, num3, 1f / (float)num2, 1f / (float)num3));
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, pingFarRGB);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, farCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, pongFarRGB);
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._BokehKernel, bokehFarKernel);
					if (useTiles)
					{
						cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._TileList, farBokehTileList);
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, bokehIndirectCmd, 12u);
					}
					else
					{
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
					}
				}
			}
			if (nearLayerActive)
			{
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldPreCombine)))
				{
					if (farLayerActive)
					{
						ComputeShader dofKernelCS = dofParameters.dofPrecombineFarCS;
						int dofKernelKernel = dofParameters.dofPrecombineFarKernel;
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, pingNearRGB);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputFarTexture, pongFarRGB);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, farCoC);
						cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, pongNearRGB);
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
						CoreUtils.Swap(ref pingNearRGB, ref pongNearRGB);
					}
				}
				using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldGatherNear)))
				{
					if (useTiles)
					{
						if (!farLayerActive)
						{
							cmd.SetRenderTarget(pongNearRGB);
							cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.clear);
						}
						cmd.SetRenderTarget(nearAlpha);
						cmd.ClearRenderTarget(clearDepth: false, clearColor: true, Color.clear);
					}
					ComputeShader dofKernelCS = dofParameters.dofGatherCS;
					int dofKernelKernel = dofParameters.dofGatherNearKernel;
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._Params1, new Vector4(nearSampleCount, nearMaxBlur * scale, z, nearMaxBlur));
					cmd.SetComputeVectorParam(dofKernelCS, HDShaderIDs._TexelSize, new Vector4(num2, num3, 1f / (float)num2, 1f / (float)num3));
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, pingNearRGB);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, nearCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputDilatedCoCTexture, dilatedNearCoC);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, pongNearRGB);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputAlphaTexture, nearAlpha);
					cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._BokehKernel, bokehNearKernel);
					if (useTiles)
					{
						cmd.SetComputeBufferParam(dofKernelCS, dofKernelKernel, HDShaderIDs._TileList, nearBokehTileList);
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, bokehIndirectCmd, 0u);
					}
					else
					{
						cmd.DispatchCompute(dofKernelCS, dofKernelKernel, dofParameters.threadGroup8.x, dofParameters.threadGroup8.y, dofParameters.camera.viewCount);
					}
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldCombine)))
			{
				ComputeShader dofKernelCS = dofParameters.dofCombineCS;
				int dofKernelKernel = dofParameters.dofCombineKernel;
				if (nearLayerActive)
				{
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputNearTexture, pongNearRGB);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputNearAlphaTexture, nearAlpha);
				}
				if (farLayerActive)
				{
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputFarTexture, pongFarRGB);
					cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputCoCTexture, fullresCoC);
				}
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._InputTexture, source);
				cmd.SetComputeTextureParam(dofKernelCS, dofKernelKernel, HDShaderIDs._OutputTexture, destination);
				cmd.DispatchCompute(dofKernelCS, dofKernelKernel, (dofParameters.viewportSize.x + 7) / 8, (dofParameters.viewportSize.y + 7) / 8, dofParameters.camera.viewCount);
			}
		}

		private static RTHandle CoCAllocatorMipsTrue(string id, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: true, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, id + " CoC History");
		}

		private static RTHandle CoCAllocatorMipsFalse(string id, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: true, RenderTextureMemoryless.None, VRTextureUsage.None, id + " CoC History");
		}

		private bool GrabCoCHistory(HDCamera camera, out RTHandle previous, out RTHandle next, bool useMips = false)
		{
			return GrabPostProcessHistoryTextures(camera, HDCameraFrameHistoryType.DepthOfFieldCoC, "CoC History", GraphicsFormat.R16_SFloat, out previous, out next, useMips);
		}

		private static void ReprojectCoCHistory(in DepthOfFieldParameters parameters, CommandBuffer cmd, HDCamera camera, RTHandle prevCoC, RTHandle nextCoC, RTHandle motionVecTexture, ref RTHandle fullresCoC)
		{
			Vector4 postProcessRTScalesHistory = camera.postProcessRTScalesHistory;
			ComputeShader dofCoCReprojectCS = parameters.dofCoCReprojectCS;
			int dofCoCReprojectKernel = parameters.dofCoCReprojectKernel;
			float num = 0.86f;
			cmd.SetComputeVectorParam(dofCoCReprojectCS, HDShaderIDs._Params, new Vector4(parameters.resetPostProcessingHistory ? 0f : num, postProcessRTScalesHistory.z, postProcessRTScalesHistory.w, 0f));
			cmd.SetComputeTextureParam(dofCoCReprojectCS, dofCoCReprojectKernel, HDShaderIDs._InputCoCTexture, fullresCoC);
			cmd.SetComputeTextureParam(dofCoCReprojectCS, dofCoCReprojectKernel, HDShaderIDs._InputHistoryCoCTexture, prevCoC);
			cmd.SetComputeTextureParam(dofCoCReprojectCS, dofCoCReprojectKernel, HDShaderIDs._OutputCoCTexture, nextCoC);
			cmd.SetComputeTextureParam(dofCoCReprojectCS, dofCoCReprojectKernel, HDShaderIDs._CameraMotionVectorsTexture, motionVecTexture);
			cmd.DispatchCompute(dofCoCReprojectCS, dofCoCReprojectKernel, (parameters.viewportSize.x + 7) / 8, (parameters.viewportSize.y + 7) / 8, camera.viewCount);
			fullresCoC = nextCoC;
		}

		private static void DoPhysicallyBasedDepthOfField(in DepthOfFieldParameters dofParameters, CommandBuffer cmd, RTHandle source, RTHandle destination, RTHandle fullresCoC, RTHandle prevCoCHistory, RTHandle nextCoCHistory, RTHandle motionVecTexture, RTHandle sourcePyramid, RTHandle depthBuffer, RTHandle minMaxCoCPing, RTHandle minMaxCoCPong, RTHandle scaledDof, bool taaEnabled, RTHandle depthMinMaxAvgMSAA)
		{
			Vector2 vector = dofParameters.viewportSize / new Vector2(1920f, 1080f);
			float num = Mathf.Min(vector.x, vector.y) * 2f;
			float num2 = num * dofParameters.farMaxBlur;
			float num3 = num * dofParameters.nearMaxBlur;
			bool flag = dofParameters.focusMode == DepthOfFieldMode.UsePhysicalCamera;
			float num4 = (flag ? 4f : 1f);
			Vector2 vector2 = new Vector2(Mathf.Max(num4 * num2, 0.01f), Mathf.Max(num4 * num3, 0.01f));
			float num5 = Mathf.Max(vector2.x, vector2.y);
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldCoC)))
			{
				ComputeShader dofCircleOfConfusionCS = dofParameters.dofCircleOfConfusionCS;
				int dofCircleOfConfusionKernel = dofParameters.dofCircleOfConfusionKernel;
				if (flag)
				{
					float num6 = ((dofParameters.camera.camera.gateFit != Camera.GateFitMode.Horizontal) ? (0.5f / dofParameters.camera.camera.sensorSize.y * (float)dofParameters.viewportSize.y) : (0.5f / dofParameters.camera.camera.sensorSize.x * (float)dofParameters.viewportSize.x));
					float num7 = dofParameters.camera.camera.focalLength / 1000f;
					float num8 = dofParameters.camera.camera.focalLength / dofParameters.physicalCameraAperture;
					float focusDistance = dofParameters.focusDistance;
					float num9 = num6 * (num8 * num7) / Mathf.Max(focusDistance - num7, 1E-06f);
					float w = num9 * (1f - focusDistance / dofParameters.camera.camera.farClipPlane);
					float z = num9 * focusDistance * (dofParameters.camera.camera.farClipPlane - dofParameters.camera.camera.nearClipPlane) / (dofParameters.camera.camera.farClipPlane * dofParameters.camera.camera.nearClipPlane);
					cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params, new Vector4(vector2.x, vector2.y, z, w));
				}
				else
				{
					float nearFocusEnd = dofParameters.nearFocusEnd;
					float num10 = Mathf.Min(dofParameters.nearFocusStart, nearFocusEnd - 1E-05f);
					float num11 = Mathf.Max(dofParameters.farFocusStart, nearFocusEnd);
					float num12 = Mathf.Max(dofParameters.farFocusEnd, num11 + 1E-05f);
					cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params, new Vector4(num11, nearFocusEnd, 1f / (num12 - num11), 1f / (num10 - nearFocusEnd)));
					cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params2, new Vector4(vector2.y, vector2.x, 0f, 0f));
				}
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._CameraDepthTexture, depthBuffer);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, fullresCoC);
				if (dofParameters.camera.msaaEnabled)
				{
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._DepthMinMaxAvg, depthMinMaxAvgMSAA);
				}
				cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, (dofParameters.viewportSize.x + 7) / 8, (dofParameters.viewportSize.y + 7) / 8, dofParameters.camera.viewCount);
				if (taaEnabled)
				{
					ReprojectCoCHistory(in dofParameters, cmd, dofParameters.camera, prevCoCHistory, nextCoCHistory, motionVecTexture, ref fullresCoC);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldPyramid)))
			{
				if (sourcePyramid != null)
				{
					ComputeShader dofCircleOfConfusionCS = dofParameters.dofMipCS;
					int dofCircleOfConfusionKernel = dofParameters.dofMipColorKernel;
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputTexture, source, 0);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, sourcePyramid, 0);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputMip1, sourcePyramid, 1);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputMip2, sourcePyramid, 2);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputMip3, sourcePyramid, 3);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputMip4, sourcePyramid, 4);
					int threadGroupsX = ((dofParameters.viewportSize.x >> 1) + 7) / 8;
					int threadGroupsY = ((dofParameters.viewportSize.y >> 1) + 7) / 8;
					cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, threadGroupsX, threadGroupsY, dofParameters.camera.viewCount);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldDilate)))
			{
				int minMaxCoCTileSize = dofParameters.minMaxCoCTileSize;
				int threadGroupsX2 = (dofParameters.viewportSize.x / minMaxCoCTileSize + 7) / 8;
				int threadGroupsY2 = (dofParameters.viewportSize.y / minMaxCoCTileSize + 7) / 8;
				ComputeShader dofCircleOfConfusionCS = dofParameters.pbDoFCoCMinMaxCS;
				int dofCircleOfConfusionKernel = dofParameters.pbDoFMinMaxKernel;
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputTexture, fullresCoC, 0);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, minMaxCoCPing, 0);
				cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, threadGroupsX2, threadGroupsY2, dofParameters.camera.viewCount);
				dofCircleOfConfusionCS = dofParameters.pbDoFDilateCS;
				dofCircleOfConfusionKernel = dofParameters.pbDoFDilateKernel;
				int num13 = (int)Mathf.Max(Mathf.Ceil(vector2.y / (float)dofParameters.minMaxCoCTileSize), 1f);
				for (int i = 0; i < num13; i++)
				{
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputTexture, minMaxCoCPing, 0);
					cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, minMaxCoCPong, 0);
					cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, threadGroupsX2, threadGroupsY2, dofParameters.camera.viewCount);
					CoreUtils.Swap(ref minMaxCoCPing, ref minMaxCoCPong);
				}
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldGatherNear)))
			{
				ComputeShader dofCircleOfConfusionCS = dofParameters.pbDoFGatherCS;
				int dofCircleOfConfusionKernel = dofParameters.pbDoFGatherKernel;
				float x = Mathf.Max(dofParameters.nearSampleCount, dofParameters.farSampleCount);
				float z2 = dofParameters.physicalCameraAnamorphism / 4f;
				float x2 = 1f + Mathf.Ceil(Mathf.Log(num5, 2f));
				cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params, new Vector4(x, num5, z2, 0f));
				cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params2, new Vector4(x2, 3f, 1f / (float)dofParameters.resolution, (float)dofParameters.resolution));
				cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params3, new Vector4(dofParameters.adaptiveSamplingWeights.x, dofParameters.adaptiveSamplingWeights.y, 0f, 0f));
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputTexture, (sourcePyramid != null) ? sourcePyramid : source);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputCoCTexture, fullresCoC);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, scaledDof);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._TileList, minMaxCoCPing, 0);
				BlueNoise.BindDitheredTextureSet(cmd, dofParameters.ditheredTextureSet);
				int threadGroupsX3 = (dofParameters.viewportSize.x / (int)dofParameters.resolution + 7) / 8;
				int threadGroupsY3 = (dofParameters.viewportSize.y / (int)dofParameters.resolution + 7) / 8;
				cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, threadGroupsX3, threadGroupsY3, dofParameters.camera.viewCount);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.DepthOfFieldCombine)))
			{
				ComputeShader dofCircleOfConfusionCS = dofParameters.pbDoFCombineCS;
				int dofCircleOfConfusionKernel = dofParameters.pbDoFCombineKernel;
				float x3 = Mathf.Max(dofParameters.nearSampleCount, dofParameters.farSampleCount);
				float z3 = dofParameters.physicalCameraAnamorphism / 4f;
				Mathf.Ceil(Mathf.Log(num5, 2f));
				cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params, new Vector4(x3, num5, z3, 0f));
				cmd.SetComputeVectorParam(dofCircleOfConfusionCS, HDShaderIDs._Params2, new Vector4(dofParameters.adaptiveSamplingWeights.x, dofParameters.adaptiveSamplingWeights.y, 0f, 0f));
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputTexture, source);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputCoCTexture, fullresCoC);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._InputNearTexture, scaledDof);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._TileList, minMaxCoCPing, 0);
				cmd.SetComputeTextureParam(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, HDShaderIDs._OutputTexture, destination);
				cmd.DispatchCompute(dofCircleOfConfusionCS, dofCircleOfConfusionKernel, (dofParameters.viewportSize.x + 7) / 8, (dofParameters.viewportSize.y + 7) / 8, dofParameters.camera.viewCount);
			}
		}

		private TextureHandle DepthOfFieldPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle motionVectors, TextureHandle depthBufferMipChain, TextureHandle source, TextureHandle depthMinMaxAvgMSAA, TextureHandle stencilTexture)
		{
			bool flag = false;
			bool flag2 = hdCamera.camera.cameraType == CameraType.SceneView;
			bool flag3 = m_AntialiasingFS && hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.TemporalAntialiasing;
			bool orthographic = hdCamera.camera.orthographic;
			if (m_DLSSPassEnabled && currentAsset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings.DLSSInjectionPoint == DynamicResolutionHandler.UpsamplerScheduleType.BeforePost)
			{
				flag3 = true;
			}
			bool flag4 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && hdCamera.IsPathTracingEnabled() && hdCamera.camera.cameraType != CameraType.Preview && m_DepthOfField.focusMode == DepthOfFieldMode.UsePhysicalCamera;
			if (m_DepthOfField.IsActive() && !flag2 && m_DepthOfFieldFS && !flag4 && !orthographic)
			{
				if (flag3 && hdCamera.dofHistoryIsValid != m_DepthOfField.physicallyBased)
				{
					hdCamera.resetPostProcessingHistory = true;
				}
				DepthOfFieldParameters dofParameters = PrepareDoFParameters(hdCamera);
				bool physicallyBased = m_DepthOfField.physicallyBased;
				RTHandle previous;
				RTHandle next;
				bool flag5 = GrabCoCHistory(hdCamera, out previous, out next, physicallyBased);
				TextureHandle input = renderGraph.ImportTexture(previous);
				TextureHandle input2 = renderGraph.ImportTexture(next);
				DepthofFieldData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DepthofFieldData>("Depth of Field", out passData, ProfilingSampler.Get(HDProfileId.DepthOfField));
				try
				{
					passData.source = renderGraphBuilder.ReadTexture(in source);
					passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
					passData.parameters = dofParameters;
					passData.prevCoC = renderGraphBuilder.ReadTexture(in input);
					passData.nextCoC = renderGraphBuilder.ReadWriteTexture(in input2);
					if (hdCamera.msaaEnabled)
					{
						passData.depthMinMaxAvgMSAA = renderGraphBuilder.ReadTexture(in depthMinMaxAvgMSAA);
					}
					GetDoFResolutionScale(in passData.parameters, out var scale, out var resolutionScale);
					Vector2 scale2 = new Vector2(scale, scale);
					passData.parameters.resetPostProcessingHistory = passData.parameters.resetPostProcessingHistory || !flag5;
					TextureHandle input3 = GetPostprocessOutputHandle(hdCamera, renderGraph, "DoF Destination");
					passData.destination = renderGraphBuilder.WriteTexture(in input3);
					passData.motionVecTexture = renderGraphBuilder.ReadTexture(in motionVectors);
					passData.taaEnabled = flag3;
					if (!m_DepthOfField.physicallyBased)
					{
						TextureDesc desc;
						if (passData.parameters.nearLayerActive)
						{
							DepthofFieldData depthofFieldData = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GetPostprocessTextureFormat(hdCamera),
								enableRandomWrite = true,
								name = "Ping Near RGB"
							};
							depthofFieldData.pingNearRGB = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData2 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GetPostprocessTextureFormat(hdCamera),
								enableRandomWrite = true,
								name = "Pong Near RGB"
							};
							depthofFieldData2.pongNearRGB = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData3 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GraphicsFormat.R16_SFloat,
								enableRandomWrite = true,
								name = "Near CoC"
							};
							depthofFieldData3.nearCoC = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData4 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GraphicsFormat.R16_SFloat,
								enableRandomWrite = true,
								name = "Near Alpha"
							};
							depthofFieldData4.nearAlpha = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData5 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GraphicsFormat.R16_SFloat,
								enableRandomWrite = true,
								name = "Dilated Near CoC"
							};
							depthofFieldData5.dilatedNearCoC = renderGraphBuilder.CreateTransientTexture(in desc);
						}
						else
						{
							passData.pingNearRGB = TextureHandle.nullHandle;
							passData.pongNearRGB = TextureHandle.nullHandle;
							passData.nearCoC = TextureHandle.nullHandle;
							passData.nearAlpha = TextureHandle.nullHandle;
							passData.dilatedNearCoC = TextureHandle.nullHandle;
						}
						if (passData.parameters.farLayerActive)
						{
							DepthofFieldData depthofFieldData6 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GetPostprocessTextureFormat(hdCamera),
								useMipMap = true,
								enableRandomWrite = true,
								name = "Ping Far RGB"
							};
							depthofFieldData6.pingFarRGB = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData7 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GetPostprocessTextureFormat(hdCamera),
								enableRandomWrite = true,
								name = "Pong Far RGB"
							};
							depthofFieldData7.pongFarRGB = renderGraphBuilder.CreateTransientTexture(in desc);
							DepthofFieldData depthofFieldData8 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GraphicsFormat.R16_SFloat,
								useMipMap = true,
								enableRandomWrite = true,
								name = "Far CoC"
							};
							depthofFieldData8.farCoC = renderGraphBuilder.CreateTransientTexture(in desc);
						}
						else
						{
							passData.pingFarRGB = TextureHandle.nullHandle;
							passData.pongFarRGB = TextureHandle.nullHandle;
							passData.farCoC = TextureHandle.nullHandle;
						}
						DepthofFieldData depthofFieldData9 = passData;
						desc = new TextureDesc(Vector2.one, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
						{
							colorFormat = GraphicsFormat.R16_SFloat,
							enableRandomWrite = true,
							name = "Full res CoC"
						};
						TextureHandle input4 = renderGraph.CreateTexture(in desc);
						depthofFieldData9.fullresCoC = renderGraphBuilder.ReadWriteTexture(in input4);
						TextureHandle input5 = passData.fullresCoC;
						Vector2 scales = hdCamera.postProcessRTScales;
						if (passData.taaEnabled)
						{
							input5 = passData.nextCoC;
							scales = hdCamera.postProcessRTScalesHistory;
						}
						float nearMaxBlur = passData.parameters.nearMaxBlur * resolutionScale;
						int doFDilationPassCount = GetDoFDilationPassCount(in dofParameters, in scale, in nearMaxBlur);
						passData.dilationPingPongRT = TextureHandle.nullHandle;
						if (doFDilationPassCount > 1)
						{
							DepthofFieldData depthofFieldData10 = passData;
							desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GraphicsFormat.R16_SFloat,
								enableRandomWrite = true,
								name = "Dilation ping pong CoC"
							};
							depthofFieldData10.dilationPingPongRT = renderGraphBuilder.CreateTransientTexture(in desc);
						}
						float num = scale;
						for (int i = 0; i < 4; i++)
						{
							num *= 0.5f;
							new Vector2Int(Mathf.RoundToInt((float)postProcessViewportSize.x * num), Mathf.RoundToInt((float)postProcessViewportSize.y * num));
							TextureHandle[] mips = passData.mips;
							int num2 = i;
							desc = new TextureDesc(new Vector2(num, num), IsDynamicResUpscaleTargetEnabled(), xrReady: true)
							{
								colorFormat = GetPostprocessTextureFormat(hdCamera),
								enableRandomWrite = true,
								name = "CoC Mip"
							};
							mips[num2] = renderGraphBuilder.CreateTransientTexture(in desc);
						}
						DepthofFieldData depthofFieldData11 = passData;
						ComputeBufferDesc desc2 = new ComputeBufferDesc(dofParameters.nearSampleCount * dofParameters.nearSampleCount, 4)
						{
							name = "Bokeh Near Kernel"
						};
						depthofFieldData11.bokehNearKernel = renderGraphBuilder.CreateTransientComputeBuffer(in desc2);
						DepthofFieldData depthofFieldData12 = passData;
						desc2 = new ComputeBufferDesc(dofParameters.farSampleCount * dofParameters.farSampleCount, 4)
						{
							name = "Bokeh Far Kernel"
						};
						depthofFieldData12.bokehFarKernel = renderGraphBuilder.CreateTransientComputeBuffer(in desc2);
						DepthofFieldData depthofFieldData13 = passData;
						desc2 = new ComputeBufferDesc(6, 4, ComputeBufferType.DrawIndirect)
						{
							name = "Bokeh Indirect Cmd"
						};
						depthofFieldData13.bokehIndirectCmd = renderGraphBuilder.CreateTransientComputeBuffer(in desc2);
						DepthofFieldData depthofFieldData14 = passData;
						desc2 = new ComputeBufferDesc(dofParameters.threadGroup8.x * dofParameters.threadGroup8.y, 4, ComputeBufferType.Append)
						{
							name = "Bokeh Near Tile List"
						};
						depthofFieldData14.nearBokehTileList = renderGraphBuilder.CreateTransientComputeBuffer(in desc2);
						DepthofFieldData depthofFieldData15 = passData;
						desc2 = new ComputeBufferDesc(dofParameters.threadGroup8.x * dofParameters.threadGroup8.y, 4, ComputeBufferType.Append)
						{
							name = "Bokeh Far Tile List"
						};
						depthofFieldData15.farBokehTileList = renderGraphBuilder.CreateTransientComputeBuffer(in desc2);
						renderGraphBuilder.SetRenderFunc(delegate(DepthofFieldData data, RenderGraphContext ctx)
						{
							RTHandle[] tempArray = ctx.renderGraphPool.GetTempArray<RTHandle>(4);
							for (int j = 0; j < 4; j++)
							{
								tempArray[j] = data.mips[j];
							}
							((ComputeBuffer)data.nearBokehTileList).SetCounterValue(0u);
							((ComputeBuffer)data.farBokehTileList).SetCounterValue(0u);
							DoDepthOfField(in data.parameters, ctx.cmd, data.source, data.destination, data.depthBuffer, data.pingNearRGB, data.pongNearRGB, data.nearCoC, data.nearAlpha, data.dilatedNearCoC, data.pingFarRGB, data.pongFarRGB, data.farCoC, data.fullresCoC, tempArray, data.dilationPingPongRT, data.prevCoC, data.nextCoC, data.motionVecTexture, data.bokehNearKernel, data.bokehFarKernel, data.bokehIndirectCmd, data.nearBokehTileList, data.farBokehTileList, data.taaEnabled, data.depthMinMaxAvgMSAA);
						});
						source = passData.destination;
						PushFullScreenDebugTexture(renderGraph, input5, scales, FullScreenDebugMode.DepthOfFieldCoc);
					}
					else
					{
						DepthofFieldData depthofFieldData16 = passData;
						TextureHandle input4 = GetPostprocessOutputHandle(renderGraph, "Full res CoC", GraphicsFormat.R16_SFloat);
						depthofFieldData16.fullresCoC = renderGraphBuilder.ReadWriteTexture(in input4);
						TextureHandle input6 = passData.fullresCoC;
						Vector2 scales2 = hdCamera.postProcessRTScales;
						if (passData.taaEnabled)
						{
							input6 = passData.nextCoC;
							scales2 = hdCamera.postProcessRTScalesHistory;
						}
						DepthofFieldData depthofFieldData17 = passData;
						TextureDesc desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
						{
							colorFormat = GetPostprocessTextureFormat(hdCamera),
							enableRandomWrite = true,
							name = "Scaled DoF"
						};
						depthofFieldData17.pongFarRGB = renderGraphBuilder.CreateTransientTexture(in desc);
						DepthofFieldData depthofFieldData18 = passData;
						input4 = GetPostprocessOutputHandle(renderGraph, "DoF Source Pyramid", GetPostprocessTextureFormat(hdCamera), useMipMap: true);
						depthofFieldData18.pingFarRGB = renderGraphBuilder.CreateTransientTexture(in input4);
						ScaleFunc func = (Vector2Int size) => new Vector2Int((size.x + 7) / 8, (size.y + 7) / 8);
						DepthofFieldData depthofFieldData19 = passData;
						desc = new TextureDesc(func, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
						{
							colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
							useMipMap = false,
							enableRandomWrite = true,
							name = "CoC Min Max Tiles"
						};
						depthofFieldData19.pingNearRGB = renderGraphBuilder.CreateTransientTexture(in desc);
						DepthofFieldData depthofFieldData20 = passData;
						desc = new TextureDesc(func, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
						{
							colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
							useMipMap = false,
							enableRandomWrite = true,
							name = "CoC Min Max Tiles"
						};
						depthofFieldData20.pongNearRGB = renderGraphBuilder.CreateTransientTexture(in desc);
						renderGraphBuilder.SetRenderFunc(delegate(DepthofFieldData data, RenderGraphContext ctx)
						{
							DoPhysicallyBasedDepthOfField(in data.parameters, ctx.cmd, data.source, data.destination, data.fullresCoC, data.prevCoC, data.nextCoC, data.motionVecTexture, data.pingFarRGB, data.depthBuffer, data.pingNearRGB, data.pongNearRGB, data.pongFarRGB, data.taaEnabled, data.depthMinMaxAvgMSAA);
						});
						source = passData.destination;
						PushFullScreenDebugTexture(renderGraph, input6, scales2, FullScreenDebugMode.DepthOfFieldCoc);
					}
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				if (flag3 && m_DepthOfField.physicallyBased)
				{
					source = DoTemporalAntialiasing(renderGraph, hdCamera, depthBuffer, motionVectors, depthBufferMipChain, source, stencilTexture, postDoF: true, "Post-DoF TAA Destination");
					hdCamera.dofHistoryIsValid = true;
					flag = true;
				}
				else
				{
					hdCamera.dofHistoryIsValid = false;
				}
			}
			if (!flag)
			{
				ReleasePostDoFTAAHistoryTextures(hdCamera);
			}
			return source;
		}

		private void LensFlareComputeOcclusionDataDrivenPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle sunOcclusionTexture, bool taaEnabled)
		{
			if (!m_LensFlareDataDataDrivenFS || LensFlareCommonSRP.Instance.IsEmpty())
			{
				return;
			}
			_ = LensFlareCommonSRP.occlusionRT;
			TextureHandle input = renderGraph.ImportTexture(LensFlareCommonSRP.occlusionRT);
			LensFlareData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<LensFlareData>("Lens Flare Compute Occlusion", out passData, ProfilingSampler.Get(HDProfileId.LensFlareComputeOcclusionDataDriven));
			try
			{
				passData.source = renderGraphBuilder.WriteTexture(in input);
				passData.parameters = PrepareLensFlareParameters(hdCamera);
				passData.viewport = postProcessViewportSize;
				passData.hdCamera = hdCamera;
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				if (RenderPipelineManager.currentPipeline is IVolumetricCloud volumetricCloud && volumetricCloud.IsVolumetricCloudUsable())
				{
					passData.sunOcclusion = renderGraphBuilder.ReadTexture(in sunOcclusionTexture);
				}
				else
				{
					passData.sunOcclusion = TextureHandle.nullHandle;
				}
				passData.taaEnabled = taaEnabled;
				CloudSettings cloudSettings;
				CloudRenderer cloudRenderer;
				bool flag = m_SkyManager.TryGetCloudSettings(hdCamera, out cloudSettings, out cloudRenderer);
				CloudLayer cloudLayer = cloudSettings as CloudLayer;
				passData.hasCloudLayer = flag && (bool)cloudLayer && LensFlareCommonSRP.IsCloudLayerOpacityNeeded(hdCamera.camera);
				if (passData.hasCloudLayer && LensFlareCommonSRP.IsCloudLayerOpacityNeeded(hdCamera.camera))
				{
					passData.hasCloudLayer &= cloudSettings.active && cloudLayer.opacity.value > 0f;
					if (passData.hasCloudLayer && skyManager.cloudOpacity.IsValid())
					{
						LensFlareData lensFlareData = passData;
						TextureHandle input2 = skyManager.cloudOpacity;
						lensFlareData.cloudOpacityTexture = renderGraphBuilder.ReadTexture(in input2);
					}
				}
				renderGraphBuilder.SetRenderFunc(delegate(LensFlareData data, RenderGraphContext ctx)
				{
					float actualWidth = data.viewport.x;
					float actualHeight = data.viewport.y;
					LensFlareCommonSRP.ComputeOcclusion(data.parameters.lensFlareShader, data.hdCamera.camera, actualWidth, actualHeight, data.parameters.usePanini, data.parameters.paniniDistance, data.parameters.paniniCropToFit, ShaderConfig.s_CameraRelativeRendering != 0, data.hdCamera.mainViewConstants.worldSpaceCameraPos, data.hdCamera.mainViewConstants.nonJitteredViewProjMatrix, ctx.cmd, data.taaEnabled, data.hasCloudLayer, data.cloudOpacityTexture, data.sunOcclusion, HDShaderIDs._FlareOcclusionTex, HDShaderIDs._FlareCloudOpacity, HDShaderIDs._FlareOcclusionIndex, HDShaderIDs._FlareTex, HDShaderIDs._FlareColorValue, HDShaderIDs._FlareSunOcclusionTex, HDShaderIDs._FlareData0, HDShaderIDs._FlareData1, HDShaderIDs._FlareData2, HDShaderIDs._FlareData3, HDShaderIDs._FlareData4);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void LensFlareMergeOcclusionDataDrivenPass(RenderGraph renderGraph, HDCamera hdCamera, bool taaEnabled)
		{
			if (!m_LensFlareDataDataDrivenFS || LensFlareCommonSRP.Instance.IsEmpty())
			{
				return;
			}
			TextureHandle input = renderGraph.ImportTexture(LensFlareCommonSRP.occlusionRT);
			LensFlareData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<LensFlareData>("Lens Flare Merge Occlusion", out passData, ProfilingSampler.Get(HDProfileId.LensFlareMergeOcclusionDataDriven));
			passData.source = renderGraphBuilder.WriteTexture(in input);
			passData.hdCamera = hdCamera;
			passData.parameters = PrepareLensFlareParameters(hdCamera);
			passData.viewport = new Vector2Int(LensFlareCommonSRP.maxLensFlareWithOcclusion, 1);
			renderGraphBuilder.SetRenderFunc(delegate(LensFlareData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetComputeTextureParam(data.parameters.lensFlareMergeOcclusion, data.parameters.mergeOcclusionKernel, HDShaderIDs._LensFlareOcclusion, LensFlareCommonSRP.occlusionRT);
				ctx.cmd.DispatchCompute(data.parameters.lensFlareMergeOcclusion, data.parameters.mergeOcclusionKernel, HDUtils.DivRoundUp(LensFlareCommonSRP.maxLensFlareWithOcclusion, 8), HDUtils.DivRoundUp(LensFlareCommonSRP.maxLensFlareWithOcclusionTemporalSample, 8), data.hdCamera.viewCount);
			});
		}

		private TextureHandle LensFlareDataDrivenPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source, TextureHandle depthBuffer, TextureHandle sunOcclusionTexture, bool taaEnabled)
		{
			if (m_LensFlareDataDataDrivenFS && !LensFlareCommonSRP.Instance.IsEmpty())
			{
				LensFlareData passData;
				using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<LensFlareData>("Lens Flare", out passData, ProfilingSampler.Get(HDProfileId.LensFlareDataDriven));
				TextureHandle input = renderGraph.ImportTexture(LensFlareCommonSRP.occlusionRT);
				passData.source = renderGraphBuilder.WriteTexture(in source);
				passData.parameters = PrepareLensFlareParameters(hdCamera);
				passData.viewport = postProcessViewportSize;
				passData.hdCamera = hdCamera;
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				passData.taaEnabled = taaEnabled;
				passData.occlusion = renderGraphBuilder.ReadTexture(in input);
				GetPostprocessUpsampledOutputHandle(hdCamera, renderGraph, "Lens Flare Destination");
				renderGraphBuilder.SetRenderFunc(delegate(LensFlareData data, RenderGraphContext ctx)
				{
					float actualWidth = data.viewport.x;
					float actualHeight = data.viewport.y;
					ctx.cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, data.depthBuffer);
					LensFlareCommonSRP.DoLensFlareDataDrivenCommon(data.parameters.lensFlareShader, data.hdCamera.camera, actualWidth, actualHeight, data.parameters.usePanini, data.parameters.paniniDistance, data.parameters.paniniCropToFit, ShaderConfig.s_CameraRelativeRendering != 0, data.hdCamera.mainViewConstants.worldSpaceCameraPos, data.hdCamera.mainViewConstants.nonJitteredViewProjMatrix, ctx.cmd, data.taaEnabled, data.hasCloudLayer, data.cloudOpacityTexture, data.sunOcclusion, data.source, (Light a, Camera b, Vector3 c) => GetLensFlareLightAttenuation(a, b, c), HDShaderIDs._FlareOcclusionRemapTex, HDShaderIDs._FlareOcclusionTex, HDShaderIDs._FlareOcclusionIndex, HDShaderIDs._FlareCloudOpacity, HDShaderIDs._FlareSunOcclusionTex, HDShaderIDs._FlareTex, HDShaderIDs._FlareColorValue, HDShaderIDs._FlareData0, HDShaderIDs._FlareData1, HDShaderIDs._FlareData2, HDShaderIDs._FlareData3, HDShaderIDs._FlareData4, data.parameters.skipCopy);
				});
				PushFullScreenDebugTexture(renderGraph, source, hdCamera.postProcessRTScales, FullScreenDebugMode.LensFlareDataDriven);
			}
			return source;
		}

		private LensFlareParameters PrepareLensFlareParameters(HDCamera camera)
		{
			LensFlareParameters result = default(LensFlareParameters);
			result.lensFlares = LensFlareCommonSRP.Instance;
			result.lensFlareShader = m_LensFlareDataDrivenShader;
			result.lensFlareMergeOcclusion = m_LensFlareMergeOcclusionDataDrivenCS;
			result.mergeOcclusionKernel = m_LensFlareMergeOcclusionDataDrivenCS.FindKernel("MainCS");
			result.skipCopy = m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.LensFlareDataDriven;
			PaniniProjection component = camera.volumeStack.GetComponent<PaniniProjection>();
			if ((bool)component)
			{
				result.usePanini = component.IsActive();
				result.paniniDistance = component.distance.value;
				result.paniniCropToFit = component.cropToFit.value;
			}
			else
			{
				result.usePanini = false;
				result.paniniDistance = 0f;
				result.paniniCropToFit = 1f;
			}
			return result;
		}

		private static float GetLensFlareLightAttenuation(Light light, Camera cam, Vector3 wo)
		{
			if (light.TryGetComponent<HDAdditionalLightData>(out var component))
			{
				return component.type switch
				{
					HDLightType.Directional => LensFlareCommonSRP.ShapeAttenuationDirLight(component.transform.forward, wo), 
					HDLightType.Point => LensFlareCommonSRP.ShapeAttenuationPointLight(), 
					HDLightType.Spot => component.spotLightShape switch
					{
						SpotLightShape.Cone => LensFlareCommonSRP.ShapeAttenuationSpotConeLight(component.transform.forward, wo, light.spotAngle, component.innerSpotPercent01), 
						SpotLightShape.Box => LensFlareCommonSRP.ShapeAttenuationSpotBoxLight(component.transform.forward, wo), 
						SpotLightShape.Pyramid => LensFlareCommonSRP.ShapeAttenuationSpotPyramidLight(component.transform.forward, wo), 
						_ => throw new Exception($"GetLensFlareLightAttenuation Unknown SpotLightShape: {typeof(SpotLightShape)}: {component.type}"), 
					}, 
					HDLightType.Area => component.areaLightShape switch
					{
						AreaLightShape.Tube => LensFlareCommonSRP.ShapeAttenuationAreaTubeLight(component.transform.position, component.transform.right, component.shapeWidth, cam), 
						AreaLightShape.Rectangle => LensFlareCommonSRP.ShapeAttenuationAreaRectangleLight(component.transform.forward, wo), 
						AreaLightShape.Disc => LensFlareCommonSRP.ShapeAttenuationAreaDiscLight(component.transform.forward, wo), 
						_ => throw new Exception($"GetLensFlareLightAttenuation Unknown AreaLightShape {typeof(AreaLightShape)}: {component.type}"), 
					}, 
					_ => throw new Exception($"GetLensFlareLightAttenuation HDLightType Unknown {typeof(HDLightType)}: {component.type}"), 
				};
			}
			return 1f;
		}

		private void PrepareMotionBlurPassData(RenderGraph renderGraph, in RenderGraphBuilder builder, MotionBlurData data, HDCamera hdCamera, TextureHandle source, TextureHandle motionVectors, TextureHandle depthTexture)
		{
			data.camera = hdCamera;
			data.viewportSize = postProcessViewportSize;
			int num = 32;
			if (m_MotionBlurSupportsScattering)
			{
				num = 16;
			}
			int num2 = Mathf.CeilToInt((float)postProcessViewportSize.x / (float)num);
			int num3 = Mathf.CeilToInt((float)postProcessViewportSize.y / (float)num);
			data.tileTargetSize = new Vector4(num2, num3, 1f / (float)num2, 1f / (float)num3);
			float magnitude = new Vector2(postProcessViewportSize.x, postProcessViewportSize.y).magnitude;
			data.motionBlurParams0 = new Vector4(magnitude, magnitude * magnitude, m_MotionBlur.minimumVelocity.value, m_MotionBlur.minimumVelocity.value * m_MotionBlur.minimumVelocity.value);
			data.motionBlurParams1 = new Vector4(m_MotionBlur.intensity.value, m_MotionBlur.maximumVelocity.value / magnitude, 0.25f, m_MotionBlur.cameraRotationVelocityClamp.value);
			uint sampleCount = (uint)m_MotionBlur.sampleCount;
			data.motionBlurParams2 = new Vector4(m_MotionBlurSupportsScattering ? (sampleCount + (sampleCount & 1)) : sampleCount, num, m_MotionBlur.depthComparisonExtent.value, m_MotionBlur.cameraMotionBlur.value ? 0f : 1f);
			data.motionVecPrepCS = defaultResources.shaders.motionBlurMotionVecPrepCS;
			data.motionVecPrepKernel = data.motionVecPrepCS.FindKernel("MotionVecPreppingCS");
			data.motionVecPrepCS.shaderKeywords = null;
			if (!m_MotionBlur.cameraMotionBlur.value)
			{
				data.motionVecPrepCS.EnableKeyword("CAMERA_DISABLE_CAMERA");
			}
			else
			{
				switch (m_MotionBlur.specialCameraClampMode.value)
				{
				case CameraClampMode.None:
					data.motionVecPrepCS.EnableKeyword("NO_SPECIAL_CLAMP");
					break;
				case CameraClampMode.Rotation:
					data.motionVecPrepCS.EnableKeyword("CAMERA_ROT_CLAMP");
					break;
				case CameraClampMode.Translation:
					data.motionVecPrepCS.EnableKeyword("CAMERA_TRANS_CLAMP");
					break;
				case CameraClampMode.SeparateTranslationAndRotation:
					data.motionVecPrepCS.EnableKeyword("CAMERA_SEPARATE_CLAMP");
					break;
				case CameraClampMode.FullCameraMotionVector:
					data.motionVecPrepCS.EnableKeyword("CAMERA_FULL_CLAMP");
					break;
				}
			}
			data.motionBlurParams3 = new Vector4(m_MotionBlur.cameraTranslationVelocityClamp.value, m_MotionBlur.cameraVelocityClamp.value, 0f, 0f);
			data.tileGenCS = defaultResources.shaders.motionBlurGenTileCS;
			data.tileGenCS.shaderKeywords = null;
			if (m_MotionBlurSupportsScattering)
			{
				data.tileGenCS.EnableKeyword("SCATTERING");
			}
			data.tileGenKernel = data.tileGenCS.FindKernel("TileGenPass");
			data.tileNeighbourhoodCS = defaultResources.shaders.motionBlurNeighborhoodTileCS;
			data.tileNeighbourhoodCS.shaderKeywords = null;
			if (m_MotionBlurSupportsScattering)
			{
				data.tileNeighbourhoodCS.EnableKeyword("SCATTERING");
			}
			data.tileNeighbourhoodKernel = data.tileNeighbourhoodCS.FindKernel("TileNeighbourhood");
			data.tileMergeCS = defaultResources.shaders.motionBlurMergeTileCS;
			data.tileMergeKernel = data.tileMergeCS.FindKernel("TileMerge");
			data.motionBlurCS = defaultResources.shaders.motionBlurCS;
			data.motionBlurCS.shaderKeywords = null;
			CoreUtils.SetKeyword(data.motionBlurCS, "ENABLE_ALPHA", PostProcessEnableAlpha(hdCamera));
			data.motionBlurKernel = data.motionBlurCS.FindKernel("MotionBlurCS");
			data.motionblurSupportScattering = m_MotionBlurSupportsScattering;
			data.source = builder.ReadTexture(in source);
			data.motionVecTexture = builder.ReadTexture(in motionVectors);
			data.depthBuffer = builder.ReadTexture(in depthTexture);
			Vector2 scale = new Vector2(data.tileTargetSize.x / (float)postProcessViewportSize.x, data.tileTargetSize.y / (float)postProcessViewportSize.y);
			RenderGraphBuilder renderGraphBuilder = builder;
			TextureDesc desc = new TextureDesc(Vector2.one, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				enableRandomWrite = true,
				name = "Prepped Motion Vectors"
			};
			data.preppedMotionVec = renderGraphBuilder.CreateTransientTexture(in desc);
			renderGraphBuilder = builder;
			desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				enableRandomWrite = true,
				name = "MinMax Tile Motion Vectors"
			};
			data.minMaxTileVel = renderGraphBuilder.CreateTransientTexture(in desc);
			renderGraphBuilder = builder;
			desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				enableRandomWrite = true,
				name = "Max Neighborhood Tile"
			};
			data.maxTileNeigbourhood = renderGraphBuilder.CreateTransientTexture(in desc);
			data.tileToScatterMax = TextureHandle.nullHandle;
			data.tileToScatterMin = TextureHandle.nullHandle;
			if (data.motionblurSupportScattering)
			{
				renderGraphBuilder = builder;
				desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_UInt,
					enableRandomWrite = true,
					name = "Tile to Scatter Max"
				};
				data.tileToScatterMax = renderGraphBuilder.CreateTransientTexture(in desc);
				renderGraphBuilder = builder;
				desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
				{
					colorFormat = GraphicsFormat.R16_SFloat,
					enableRandomWrite = true,
					name = "Tile to Scatter Min"
				};
				data.tileToScatterMin = renderGraphBuilder.CreateTransientTexture(in desc);
			}
			renderGraphBuilder = builder;
			TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "Motion Blur Destination");
			data.destination = renderGraphBuilder.WriteTexture(in input);
		}

		private static void DoMotionBlur(MotionBlurData data, CommandBuffer cmd)
		{
			int num = 32;
			if (data.motionblurSupportScattering)
			{
				num = 16;
			}
			int num2 = 8;
			int num3 = 8;
			int threadGroupsX;
			int threadGroupsY;
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.MotionBlurMotionVecPrep)))
			{
				ComputeShader motionVecPrepCS = data.motionVecPrepCS;
				int motionVecPrepKernel = data.motionVecPrepKernel;
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._MotionVecAndDepth, data.preppedMotionVec);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._CameraDepthTexture, data.depthBuffer);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams, data.motionBlurParams0);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams1, data.motionBlurParams1);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams2, data.motionBlurParams2);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams3, data.motionBlurParams3);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._CameraMotionVectorsTexture, data.motionVecTexture);
				cmd.SetComputeMatrixParam(motionVecPrepCS, HDShaderIDs._PrevVPMatrixNoTranslation, data.camera.mainViewConstants.prevViewProjMatrixNoCameraTrans);
				cmd.SetComputeMatrixParam(motionVecPrepCS, HDShaderIDs._CurrVPMatrixNoTranslation, data.camera.mainViewConstants.viewProjectionNoCameraTrans);
				threadGroupsX = (data.viewportSize.x + (num2 - 1)) / num2;
				threadGroupsY = (data.viewportSize.y + (num3 - 1)) / num3;
				cmd.DispatchCompute(motionVecPrepCS, motionVecPrepKernel, threadGroupsX, threadGroupsY, data.camera.viewCount);
			}
			ProfilingScope profilingScope2 = new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.MotionBlurTileMinMax));
			try
			{
				ComputeShader motionVecPrepCS = data.tileGenCS;
				int motionVecPrepKernel = data.tileGenKernel;
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileMinMaxMotionVec, data.minMaxTileVel);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._MotionVecAndDepth, data.preppedMotionVec);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams, data.motionBlurParams0);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams1, data.motionBlurParams1);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams2, data.motionBlurParams2);
				if (data.motionblurSupportScattering)
				{
					cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMax, data.tileToScatterMax);
					cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMin, data.tileToScatterMin);
				}
				threadGroupsX = (data.viewportSize.x + (num - 1)) / num;
				threadGroupsY = (data.viewportSize.y + (num - 1)) / num;
				cmd.DispatchCompute(motionVecPrepCS, motionVecPrepKernel, threadGroupsX, threadGroupsY, data.camera.viewCount);
			}
			finally
			{
				((IDisposable)profilingScope2).Dispose();
			}
			profilingScope2 = new ProfilingScope(cmd, data.motionblurSupportScattering ? ProfilingSampler.Get(HDProfileId.MotionBlurTileScattering) : ProfilingSampler.Get(HDProfileId.MotionBlurTileNeighbourhood));
			try
			{
				ComputeShader motionVecPrepCS = data.tileNeighbourhoodCS;
				int motionVecPrepKernel = data.tileNeighbourhoodKernel;
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._TileTargetSize, data.tileTargetSize);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileMinMaxMotionVec, data.minMaxTileVel);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileMaxNeighbourhood, data.maxTileNeigbourhood);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams, data.motionBlurParams0);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams1, data.motionBlurParams1);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams2, data.motionBlurParams2);
				if (data.motionblurSupportScattering)
				{
					cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMax, data.tileToScatterMax);
					cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMin, data.tileToScatterMin);
				}
				num2 = 8;
				num3 = 8;
				threadGroupsX = ((int)data.tileTargetSize.x + (num2 - 1)) / num2;
				threadGroupsY = ((int)data.tileTargetSize.y + (num3 - 1)) / num3;
				cmd.DispatchCompute(motionVecPrepCS, motionVecPrepKernel, threadGroupsX, threadGroupsY, data.camera.viewCount);
			}
			finally
			{
				((IDisposable)profilingScope2).Dispose();
			}
			if (data.motionblurSupportScattering)
			{
				ComputeShader motionVecPrepCS = data.tileMergeCS;
				int motionVecPrepKernel = data.tileMergeKernel;
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._TileTargetSize, data.tileTargetSize);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMax, data.tileToScatterMax);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileToScatterMin, data.tileToScatterMin);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileMaxNeighbourhood, data.maxTileNeigbourhood);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams, data.motionBlurParams0);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams1, data.motionBlurParams1);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams2, data.motionBlurParams2);
				cmd.DispatchCompute(motionVecPrepCS, motionVecPrepKernel, threadGroupsX, threadGroupsY, data.camera.viewCount);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.MotionBlurKernel)))
			{
				ComputeShader motionVecPrepCS = data.motionBlurCS;
				int motionVecPrepKernel = data.motionBlurKernel;
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._TileTargetSize, data.tileTargetSize);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._MotionVecAndDepth, data.preppedMotionVec);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._OutputTexture, data.destination);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._TileMaxNeighbourhood, data.maxTileNeigbourhood);
				cmd.SetComputeTextureParam(motionVecPrepCS, motionVecPrepKernel, HDShaderIDs._InputTexture, data.source);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams, data.motionBlurParams0);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams1, data.motionBlurParams1);
				cmd.SetComputeVectorParam(motionVecPrepCS, HDShaderIDs._MotionBlurParams2, data.motionBlurParams2);
				num2 = 16;
				num3 = 16;
				threadGroupsX = (data.viewportSize.x + (num2 - 1)) / num2;
				threadGroupsY = (data.viewportSize.y + (num3 - 1)) / num3;
				cmd.DispatchCompute(motionVecPrepCS, motionVecPrepKernel, threadGroupsX, threadGroupsY, data.camera.viewCount);
			}
		}

		private TextureHandle MotionBlurPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthTexture, TextureHandle motionVectors, TextureHandle source)
		{
			if (m_MotionBlur.IsActive() && m_AnimatedMaterialsEnabled && !hdCamera.resetPostProcessingHistory && m_MotionBlurFS)
			{
				if (hdCamera.xr.enabled && !m_Asset.currentPlatformRenderPipelineSettings.xrSettings.allowMotionBlur)
				{
					return source;
				}
				MotionBlurData passData;
				RenderGraphBuilder builder = renderGraph.AddRenderPass<MotionBlurData>("Motion Blur", out passData, ProfilingSampler.Get(HDProfileId.MotionBlur));
				try
				{
					PrepareMotionBlurPassData(renderGraph, in builder, passData, hdCamera, source, motionVectors, depthTexture);
					builder.SetRenderFunc(delegate(MotionBlurData data, RenderGraphContext ctx)
					{
						DoMotionBlur(data, ctx.cmd);
					});
					source = passData.destination;
				}
				finally
				{
					((IDisposable)builder).Dispose();
				}
			}
			return source;
		}

		private void SetCurrentResolutionGroup(RenderGraph renderGraph, HDCamera camera, ResolutionGroup newResGroup)
		{
			if (resGroup != newResGroup)
			{
				resGroup = newResGroup;
				camera.SetPostProcessScreenSize(postProcessViewportSize.x, postProcessViewportSize.y);
				UpdatePostProcessScreenSize(renderGraph, camera, postProcessViewportSize.x, postProcessViewportSize.y);
			}
		}

		private Vector2 CalcViewExtents(HDCamera camera)
		{
			float num = camera.camera.fieldOfView * (MathF.PI / 180f);
			float num2 = (float)postProcessViewportSize.x / (float)postProcessViewportSize.y;
			float num3 = Mathf.Tan(0.5f * num);
			return new Vector2(num2 * num3, num3);
		}

		private Vector2 CalcCropExtents(HDCamera camera, float d)
		{
			float num = 1f + d;
			Vector2 vector = CalcViewExtents(camera);
			float num2 = Mathf.Sqrt(vector.x * vector.x + 1f);
			float num3 = 1f / num2;
			float num4 = num3 + d;
			return vector * num3 * (num / num4);
		}

		private TextureHandle PaniniProjectionPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			bool flag = hdCamera.camera.cameraType == CameraType.SceneView;
			if (m_PaniniProjection.IsActive() && !flag && m_PaniniProjectionFS)
			{
				PaniniProjectionData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PaniniProjectionData>("Panini Projection", out passData, ProfilingSampler.Get(HDProfileId.PaniniProjection));
				try
				{
					passData.width = postProcessViewportSize.x;
					passData.height = postProcessViewportSize.y;
					passData.viewCount = hdCamera.viewCount;
					passData.paniniProjectionCS = defaultResources.shaders.paniniProjectionCS;
					passData.paniniProjectionCS.shaderKeywords = null;
					float value = m_PaniniProjection.distance.value;
					Vector2 vector = CalcViewExtents(hdCamera);
					Vector2 vector2 = CalcCropExtents(hdCamera, value);
					float a = vector2.x / vector.x;
					float b = vector2.y / vector.y;
					float value2 = Mathf.Min(a, b);
					float num = value;
					float w = Mathf.Lerp(1f, Mathf.Clamp01(value2), m_PaniniProjection.cropToFit.value);
					if (1f - Mathf.Abs(num) > float.Epsilon)
					{
						passData.paniniProjectionCS.EnableKeyword("GENERIC");
					}
					else
					{
						passData.paniniProjectionCS.EnableKeyword("UNITDISTANCE");
					}
					if (PostProcessEnableAlpha(hdCamera))
					{
						passData.paniniProjectionCS.EnableKeyword("ENABLE_ALPHA");
					}
					passData.paniniParams = new Vector4(vector.x, vector.y, num, w);
					passData.paniniProjectionKernel = passData.paniniProjectionCS.FindKernel("KMain");
					passData.source = renderGraphBuilder.ReadTexture(in source);
					PaniniProjectionData paniniProjectionData = passData;
					TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "Panini Projection Destination");
					paniniProjectionData.destination = renderGraphBuilder.WriteTexture(in input);
					renderGraphBuilder.SetRenderFunc(delegate(PaniniProjectionData data, RenderGraphContext ctx)
					{
						ComputeShader paniniProjectionCS = data.paniniProjectionCS;
						int paniniProjectionKernel = data.paniniProjectionKernel;
						ctx.cmd.SetComputeVectorParam(paniniProjectionCS, HDShaderIDs._Params, data.paniniParams);
						ctx.cmd.SetComputeTextureParam(paniniProjectionCS, paniniProjectionKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeTextureParam(paniniProjectionCS, paniniProjectionKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.DispatchCompute(paniniProjectionCS, paniniProjectionKernel, (data.width + 7) / 8, (data.height + 7) / 8, data.viewCount);
					});
					source = passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return source;
		}

		private void PrepareBloomData(RenderGraph renderGraph, in RenderGraphBuilder builder, BloomData passData, HDCamera camera, TextureHandle source)
		{
			passData.viewCount = camera.viewCount;
			passData.bloomPrefilterCS = defaultResources.shaders.bloomPrefilterCS;
			passData.bloomPrefilterKernel = passData.bloomPrefilterCS.FindKernel("KMain");
			passData.bloomPrefilterCS.shaderKeywords = null;
			if (m_Bloom.highQualityPrefiltering)
			{
				passData.bloomPrefilterCS.EnableKeyword("HIGH_QUALITY");
			}
			else
			{
				passData.bloomPrefilterCS.EnableKeyword("LOW_QUALITY");
			}
			if (PostProcessEnableAlpha(camera))
			{
				passData.bloomPrefilterCS.EnableKeyword("ENABLE_ALPHA");
			}
			passData.bloomBlurCS = defaultResources.shaders.bloomBlurCS;
			passData.bloomBlurKernel = passData.bloomBlurCS.FindKernel("KMain");
			passData.bloomDownsampleKernel = passData.bloomBlurCS.FindKernel("KDownsample");
			passData.bloomUpsampleCS = defaultResources.shaders.bloomUpsampleCS;
			passData.bloomUpsampleCS.shaderKeywords = null;
			bool flag = m_Bloom.highQualityFiltering;
			if (postProcessViewportSize.x < 800 || postProcessViewportSize.y < 450)
			{
				flag = false;
			}
			if (flag)
			{
				passData.bloomUpsampleCS.EnableKeyword("HIGH_QUALITY");
			}
			else
			{
				passData.bloomUpsampleCS.EnableKeyword("LOW_QUALITY");
			}
			passData.bloomUpsampleKernel = passData.bloomUpsampleCS.FindKernel("KMain");
			passData.bloomScatterParam = Mathf.Lerp(0.05f, 0.95f, m_Bloom.scatter.value);
			passData.thresholdParams = GetBloomThresholdParams();
			BloomResolution resolution = m_Bloom.resolution;
			float num = 1f / ((float)resolution / 2f);
			float num2 = 1f / ((float)resolution / 2f);
			if (postProcessViewportSize.x < 800 || postProcessViewportSize.y < 450)
			{
				num = 1f;
				num2 = 1f;
			}
			if (m_Bloom.anamorphic.value)
			{
				float num3 = camera.camera.anamorphism * 0.5f;
				num *= ((num3 < 0f) ? (1f + num3) : 1f);
				num2 *= ((num3 > 0f) ? (1f - num3) : 1f);
			}
			int value = Mathf.FloorToInt(Mathf.Log(Mathf.Max(postProcessViewportSize.x, postProcessViewportSize.y), 2f) - 2f - (float)((resolution != BloomResolution.Half) ? 1 : 0));
			passData.bloomMipCount = Mathf.Clamp(value, 1, 16);
			RenderGraphBuilder renderGraphBuilder;
			TextureDesc desc;
			for (int i = 0; i < passData.bloomMipCount; i++)
			{
				float num4 = 1f / Mathf.Pow(2f, (float)i + 1f);
				float num5 = num * num4;
				float num6 = num2 * num4;
				int num7;
				int num8;
				if (camera.DynResRequest.hardwareEnabled)
				{
					num7 = Mathf.Max(1, Mathf.CeilToInt(num5 * (float)postProcessViewportSize.x));
					num8 = Mathf.Max(1, Mathf.CeilToInt(num6 * (float)postProcessViewportSize.y));
				}
				else
				{
					num7 = Mathf.Max(1, Mathf.RoundToInt(num5 * (float)postProcessViewportSize.x));
					num8 = Mathf.Max(1, Mathf.RoundToInt(num6 * (float)postProcessViewportSize.y));
				}
				Vector2 scale = new Vector2(num5, num6);
				new Vector2Int(num7, num8);
				passData.bloomMipInfo[i] = new Vector4(num7, num8, num5, num6);
				TextureHandle[] mipsDown = passData.mipsDown;
				int num9 = i;
				renderGraphBuilder = builder;
				desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
				{
					colorFormat = GetPostprocessTextureFormat(camera),
					enableRandomWrite = true,
					name = "BloomMipDown"
				};
				mipsDown[num9] = renderGraphBuilder.CreateTransientTexture(in desc);
				if (i != 0)
				{
					TextureHandle[] mipsUp = passData.mipsUp;
					int num10 = i;
					renderGraphBuilder = builder;
					desc = new TextureDesc(scale, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
					{
						colorFormat = GetPostprocessTextureFormat(camera),
						enableRandomWrite = true,
						name = "BloomMipUp"
					};
					mipsUp[num10] = renderGraphBuilder.CreateTransientTexture(in desc);
				}
			}
			m_BloomBicubicParams = new Vector4(passData.bloomMipInfo[0].x, passData.bloomMipInfo[0].y, 1f / passData.bloomMipInfo[0].x, 1f / passData.bloomMipInfo[0].y);
			Vector2 scale2 = new Vector2(passData.bloomMipInfo[0].z, passData.bloomMipInfo[0].w);
			m_BloomBicubicParams.x /= RTHandles.rtHandleProperties.rtHandleScale.x;
			m_BloomBicubicParams.y /= RTHandles.rtHandleProperties.rtHandleScale.y;
			m_BloomBicubicParams.z *= RTHandles.rtHandleProperties.rtHandleScale.x;
			m_BloomBicubicParams.w *= RTHandles.rtHandleProperties.rtHandleScale.y;
			TextureHandle[] mipsUp2 = passData.mipsUp;
			renderGraphBuilder = builder;
			desc = new TextureDesc(scale2, IsDynamicResUpscaleTargetEnabled(), xrReady: true)
			{
				name = "Bloom final mip up",
				colorFormat = GetPostprocessTextureFormat(camera),
				useMipMap = false,
				enableRandomWrite = true
			};
			TextureHandle input = renderGraph.CreateTexture(in desc);
			mipsUp2[0] = renderGraphBuilder.WriteTexture(in input);
			passData.source = builder.ReadTexture(in source);
		}

		private TextureHandle BloomPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			bool num = m_Bloom.IsActive() && m_BloomFS;
			TextureHandle result = renderGraph.defaultResources.blackTextureXR;
			if (num)
			{
				BloomData passData;
				RenderGraphBuilder builder = renderGraph.AddRenderPass<BloomData>("Bloom", out passData, ProfilingSampler.Get(HDProfileId.Bloom));
				try
				{
					PrepareBloomData(renderGraph, in builder, passData, hdCamera, source);
					builder.SetRenderFunc(delegate(BloomData data, RenderGraphContext ctx)
					{
						RTHandle sourceRT = data.source;
						Vector2Int size2 = new Vector2Int((int)data.bloomMipInfo[0].x, (int)data.bloomMipInfo[0].y);
						ComputeShader bloomPrefilterCS = data.bloomPrefilterCS;
						int bloomPrefilterKernel = data.bloomPrefilterKernel;
						ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._InputTexture, sourceRT);
						ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._OutputTexture, data.mipsUp[0]);
						ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._TexelSize, new Vector4(size2.x, size2.y, 1f / (float)size2.x, 1f / (float)size2.y));
						ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._BloomThreshold, data.thresholdParams);
						DispatchWithGuardBands(ctx.cmd, bloomPrefilterCS, bloomPrefilterKernel, in size2, in data.viewCount);
						bloomPrefilterCS = data.bloomBlurCS;
						bloomPrefilterKernel = data.bloomBlurKernel;
						ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._InputTexture, data.mipsUp[0]);
						ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._OutputTexture, data.mipsDown[0]);
						ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._TexelSize, new Vector4(size2.x, size2.y, 1f / (float)size2.x, 1f / (float)size2.y));
						DispatchWithGuardBands(ctx.cmd, bloomPrefilterCS, bloomPrefilterKernel, in size2, in data.viewCount);
						bloomPrefilterKernel = data.bloomDownsampleKernel;
						for (int i = 0; i < data.bloomMipCount - 1; i++)
						{
							TextureHandle textureHandle = data.mipsDown[i];
							TextureHandle textureHandle2 = data.mipsDown[i + 1];
							Vector2Int size3 = new Vector2Int((int)data.bloomMipInfo[i + 1].x, (int)data.bloomMipInfo[i + 1].y);
							ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._InputTexture, textureHandle);
							ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._OutputTexture, textureHandle2);
							ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._TexelSize, new Vector4(size3.x, size3.y, 1f / (float)size3.x, 1f / (float)size3.y));
							DispatchWithGuardBands(ctx.cmd, bloomPrefilterCS, bloomPrefilterKernel, in size3, in data.viewCount);
						}
						bloomPrefilterCS = data.bloomUpsampleCS;
						bloomPrefilterKernel = data.bloomUpsampleKernel;
						for (int num2 = data.bloomMipCount - 2; num2 >= 0; num2--)
						{
							TextureHandle textureHandle3 = ((num2 == data.bloomMipCount - 2) ? data.mipsDown : data.mipsUp)[num2 + 1];
							TextureHandle textureHandle4 = data.mipsDown[num2];
							TextureHandle textureHandle5 = data.mipsUp[num2];
							Vector2Int size4 = new Vector2Int((int)data.bloomMipInfo[num2].x, (int)data.bloomMipInfo[num2].y);
							Vector2Int vector2Int = new Vector2Int((int)data.bloomMipInfo[num2 + 1].x, (int)data.bloomMipInfo[num2 + 1].y);
							ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._InputLowTexture, textureHandle3);
							ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._InputHighTexture, textureHandle4);
							ctx.cmd.SetComputeTextureParam(bloomPrefilterCS, bloomPrefilterKernel, HDShaderIDs._OutputTexture, textureHandle5);
							ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._Params, new Vector4(data.bloomScatterParam, 0f, 0f, 0f));
							ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._BloomBicubicParams, new Vector4(vector2Int.x, vector2Int.y, 1f / (float)vector2Int.x, 1f / (float)vector2Int.y));
							ctx.cmd.SetComputeVectorParam(bloomPrefilterCS, HDShaderIDs._TexelSize, new Vector4(size4.x, size4.y, 1f / (float)size4.x, 1f / (float)size4.y));
							DispatchWithGuardBands(ctx.cmd, bloomPrefilterCS, bloomPrefilterKernel, in size4, in data.viewCount);
						}
						void DispatchWithGuardBands(CommandBuffer cmd, ComputeShader shader, int kernelId, in Vector2Int size, in int viewCount)
						{
							int num3 = size.x;
							int num4 = size.y;
							if (num3 < sourceRT.rt.width && num3 % 8 < 4)
							{
								num3 += 4;
							}
							if (num4 < sourceRT.rt.height && num4 % 8 < 4)
							{
								num4 += 4;
							}
							cmd.DispatchCompute(shader, kernelId, (num3 + 7) / 8, (num4 + 7) / 8, viewCount);
						}
					});
					result = passData.mipsUp[0];
				}
				finally
				{
					((IDisposable)builder).Dispose();
				}
			}
			return result;
		}

		internal void PrepareColorGradingParameters(ColorGradingPassData passData)
		{
			passData.tonemappingMode = (m_TonemappingFS ? m_Tonemapping.mode.value : TonemappingMode.None);
			bool flag = m_Tonemapping.IsActive() && m_TonemappingFS;
			if (HDROutputActiveForCameraType(m_CurrCameraType) && m_TonemappingFS)
			{
				passData.tonemappingMode = m_Tonemapping.GetHDRTonemappingMode();
				flag = m_TonemappingFS && passData.tonemappingMode != TonemappingMode.None;
			}
			passData.builderCS = defaultResources.shaders.lutBuilder3DCS;
			passData.builderKernel = passData.builderCS.FindKernel("KBuild");
			passData.builderCS.shaderKeywords = null;
			if (flag)
			{
				switch (passData.tonemappingMode)
				{
				case TonemappingMode.Neutral:
					passData.builderCS.EnableKeyword("TONEMAPPING_NEUTRAL");
					break;
				case TonemappingMode.ACES:
					passData.builderCS.EnableKeyword(m_Tonemapping.useFullACES.value ? "TONEMAPPING_ACES_FULL" : "TONEMAPPING_ACES_APPROX");
					break;
				case TonemappingMode.Custom:
					passData.builderCS.EnableKeyword("TONEMAPPING_CUSTOM");
					break;
				case TonemappingMode.External:
					passData.builderCS.EnableKeyword("TONEMAPPING_EXTERNAL");
					break;
				}
			}
			else
			{
				passData.builderCS.EnableKeyword("TONEMAPPING_NONE");
			}
			if (HDROutputActiveForCameraType(m_CurrCameraType) && m_TonemappingFS)
			{
				HDROutputUtils.ConfigureHDROutput(passData.builderCS, HDROutputSettings.main.displayColorGamut, HDROutputUtils.Operation.ColorConversion);
				GetHDROutputParameters(m_Tonemapping, out passData.hdroutParameters, out passData.hdroutParameters2);
			}
			if (m_GlobalSettings.colorGradingSpace == ColorGradingSpace.sRGB)
			{
				passData.builderCS.EnableKeyword("GRADE_IN_SRGB");
			}
			else if (m_GlobalSettings.colorGradingSpace == ColorGradingSpace.AcesCg)
			{
				passData.builderCS.EnableKeyword("GRADE_IN_ACESCG");
			}
			passData.lutSize = m_LutSize;
			passData.lmsColorBalance = GetColorBalanceCoeffs(m_WhiteBalance.temperature.value, m_WhiteBalance.tint.value);
			passData.hueSatCon = new Vector4(m_ColorAdjustments.hueShift.value / 360f, m_ColorAdjustments.saturation.value / 100f + 1f, m_ColorAdjustments.contrast.value / 100f + 1f, 0f);
			passData.channelMixerR = new Vector4(m_ChannelMixer.redOutRedIn.value / 100f, m_ChannelMixer.redOutGreenIn.value / 100f, m_ChannelMixer.redOutBlueIn.value / 100f, 0f);
			passData.channelMixerG = new Vector4(m_ChannelMixer.greenOutRedIn.value / 100f, m_ChannelMixer.greenOutGreenIn.value / 100f, m_ChannelMixer.greenOutBlueIn.value / 100f, 0f);
			passData.channelMixerB = new Vector4(m_ChannelMixer.blueOutRedIn.value / 100f, m_ChannelMixer.blueOutGreenIn.value / 100f, m_ChannelMixer.blueOutBlueIn.value / 100f, 0f);
			ComputeShadowsMidtonesHighlights(out passData.shadows, out passData.midtones, out passData.highlights, out passData.shadowsHighlightsLimits);
			ComputeLiftGammaGain(out passData.lift, out passData.gamma, out passData.gain);
			ComputeSplitToning(out passData.splitShadows, out passData.splitHighlights);
			passData.curves = m_Curves;
			if (passData.tonemappingMode == TonemappingMode.Custom)
			{
				passData.hableCurve = m_HableCurve;
				passData.hableCurve.Init(m_Tonemapping.toeStrength.value, m_Tonemapping.toeLength.value, m_Tonemapping.shoulderStrength.value, m_Tonemapping.shoulderLength.value, m_Tonemapping.shoulderAngle.value, m_Tonemapping.gamma.value);
			}
			else if (passData.tonemappingMode == TonemappingMode.External)
			{
				passData.externalLuT = m_Tonemapping.lutTexture.value;
				passData.lutContribution = m_Tonemapping.lutContribution.value;
			}
			passData.colorFilter = m_ColorAdjustments.colorFilter.value.linear;
			passData.miscParams = new Vector4(m_ColorGradingFS ? 1f : 0f, 0f, 0f, 0f);
		}

		private static Vector3 GetColorBalanceCoeffs(float temperature, float tint)
		{
			float num = temperature / 65f;
			float num2 = tint / 65f;
			float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
			float y = ColorUtils.StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = ColorUtils.CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		public static bool HDRDataDetectedProperly()
		{
			if (HDROutputSettings.main.minToneMapLuminance >= 0 && HDROutputSettings.main.maxToneMapLuminance > 0)
			{
				return HDROutputSettings.main.paperWhiteNits > 0f;
			}
			return false;
		}

		private static void GetHDROutputParameters(Tonemapping tonemappingComponent, out Vector4 hdrOutputParameters1, out Vector4 hdrOutputParameters2)
		{
			ColorGamut displayColorGamut = HDROutputSettings.main.displayColorGamut;
			int num = HDROutputSettings.main.minToneMapLuminance;
			int num2 = HDROutputSettings.main.maxToneMapLuminance;
			float num3 = HDROutputSettings.main.paperWhiteNits;
			int num4 = 0;
			float y = 0f;
			if ((num < 0 || num2 <= 0) && tonemappingComponent.detectBrightnessLimits.value)
			{
				num = 0;
				num2 = 1000;
				Debug.LogWarning("The platform failed to detect min and max nits, minNits: 0 and maxNits: 1000 are used as default, but it is heavily suggested that the title provides a calibration screen to manually set the limits.");
			}
			if (num3 <= 0f && tonemappingComponent.detectPaperWhite.value)
			{
				num3 = 300f;
				Debug.LogWarning("The platform failed to detect paper white values, paperwhite: 300 will be used as default, but it is heavily suggested that the title provides a calibration screen to manually set the value.");
			}
			TonemappingMode hDRTonemappingMode = tonemappingComponent.GetHDRTonemappingMode();
			if (hDRTonemappingMode == TonemappingMode.Neutral)
			{
				y = tonemappingComponent.hueShiftAmount.value;
				if (tonemappingComponent.neutralHDRRangeReductionMode.value == NeutralRangeReductionMode.BT2390)
				{
					num4 = 2;
				}
				if (tonemappingComponent.neutralHDRRangeReductionMode.value == NeutralRangeReductionMode.Reinhard)
				{
					num4 = 1;
				}
			}
			if (hDRTonemappingMode == TonemappingMode.ACES)
			{
				num4 = (int)tonemappingComponent.acesPreset.value;
			}
			if (!tonemappingComponent.detectPaperWhite.value)
			{
				num3 = tonemappingComponent.paperWhite.value;
			}
			if (!tonemappingComponent.detectBrightnessLimits.value)
			{
				num = (int)tonemappingComponent.minNits.value;
				num2 = (int)tonemappingComponent.maxNits.value;
			}
			hdrOutputParameters1 = new Vector4(num, num2, num3, 1f / num3);
			hdrOutputParameters2 = new Vector4(num4, y, num3, (float)ColorGamutUtility.GetColorPrimaries(displayColorGamut));
		}

		private void ComputeShadowsMidtonesHighlights(out Vector4 shadows, out Vector4 midtones, out Vector4 highlights, out Vector4 limits)
		{
			shadows = m_ShadowsMidtonesHighlights.shadows.value;
			shadows.x = Mathf.GammaToLinearSpace(shadows.x);
			shadows.y = Mathf.GammaToLinearSpace(shadows.y);
			shadows.z = Mathf.GammaToLinearSpace(shadows.z);
			float num = shadows.w * ((Mathf.Sign(shadows.w) < 0f) ? 1f : 4f);
			shadows.x = Mathf.Max(shadows.x + num, 0f);
			shadows.y = Mathf.Max(shadows.y + num, 0f);
			shadows.z = Mathf.Max(shadows.z + num, 0f);
			shadows.w = 0f;
			midtones = m_ShadowsMidtonesHighlights.midtones.value;
			midtones.x = Mathf.GammaToLinearSpace(midtones.x);
			midtones.y = Mathf.GammaToLinearSpace(midtones.y);
			midtones.z = Mathf.GammaToLinearSpace(midtones.z);
			num = midtones.w * ((Mathf.Sign(midtones.w) < 0f) ? 1f : 4f);
			midtones.x = Mathf.Max(midtones.x + num, 0f);
			midtones.y = Mathf.Max(midtones.y + num, 0f);
			midtones.z = Mathf.Max(midtones.z + num, 0f);
			midtones.w = 0f;
			highlights = m_ShadowsMidtonesHighlights.highlights.value;
			highlights.x = Mathf.GammaToLinearSpace(highlights.x);
			highlights.y = Mathf.GammaToLinearSpace(highlights.y);
			highlights.z = Mathf.GammaToLinearSpace(highlights.z);
			num = highlights.w * ((Mathf.Sign(highlights.w) < 0f) ? 1f : 4f);
			highlights.x = Mathf.Max(highlights.x + num, 0f);
			highlights.y = Mathf.Max(highlights.y + num, 0f);
			highlights.z = Mathf.Max(highlights.z + num, 0f);
			highlights.w = 0f;
			limits = new Vector4(m_ShadowsMidtonesHighlights.shadowsStart.value, m_ShadowsMidtonesHighlights.shadowsEnd.value, m_ShadowsMidtonesHighlights.highlightsStart.value, m_ShadowsMidtonesHighlights.highlightsEnd.value);
		}

		private void ComputeLiftGammaGain(out Vector4 lift, out Vector4 gamma, out Vector4 gain)
		{
			lift = m_LiftGammaGain.lift.value;
			lift.x = Mathf.GammaToLinearSpace(lift.x) * 0.15f;
			lift.y = Mathf.GammaToLinearSpace(lift.y) * 0.15f;
			lift.z = Mathf.GammaToLinearSpace(lift.z) * 0.15f;
			Color color = lift;
			float num = ColorUtils.Luminance(in color);
			lift.x = lift.x - num + lift.w;
			lift.y = lift.y - num + lift.w;
			lift.z = lift.z - num + lift.w;
			lift.w = 0f;
			gamma = m_LiftGammaGain.gamma.value;
			gamma.x = Mathf.GammaToLinearSpace(gamma.x) * 0.8f;
			gamma.y = Mathf.GammaToLinearSpace(gamma.y) * 0.8f;
			gamma.z = Mathf.GammaToLinearSpace(gamma.z) * 0.8f;
			color = gamma;
			float num2 = ColorUtils.Luminance(in color);
			gamma.w += 1f;
			gamma.x = 1f / Mathf.Max(gamma.x - num2 + gamma.w, 0.001f);
			gamma.y = 1f / Mathf.Max(gamma.y - num2 + gamma.w, 0.001f);
			gamma.z = 1f / Mathf.Max(gamma.z - num2 + gamma.w, 0.001f);
			gamma.w = 0f;
			gain = m_LiftGammaGain.gain.value;
			gain.x = Mathf.GammaToLinearSpace(gain.x) * 0.8f;
			gain.y = Mathf.GammaToLinearSpace(gain.y) * 0.8f;
			gain.z = Mathf.GammaToLinearSpace(gain.z) * 0.8f;
			color = gain;
			float num3 = ColorUtils.Luminance(in color);
			gain.w += 1f;
			gain.x = gain.x - num3 + gain.w;
			gain.y = gain.y - num3 + gain.w;
			gain.z = gain.z - num3 + gain.w;
			gain.w = 0f;
		}

		private void ComputeSplitToning(out Vector4 shadows, out Vector4 highlights)
		{
			shadows = m_SplitToning.shadows.value;
			highlights = m_SplitToning.highlights.value;
			shadows.w = m_SplitToning.balance.value / 100f;
			highlights.w = 0f;
		}

		private TextureHandle ColorGradingPass(RenderGraph renderGraph)
		{
			TextureHandle input = renderGraph.ImportTexture(m_GradingAndTonemappingLUT);
			int num = ComputeLUTHash();
			if (num == m_LutHash && !m_Curves.AnyPropertiesIsOverridden())
			{
				return input;
			}
			m_LutHash = num;
			ColorGradingPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ColorGradingPassData>("Color Grading", out passData, ProfilingSampler.Get(HDProfileId.ColorGradingLUTBuilder));
			PrepareColorGradingParameters(passData);
			passData.logLut = renderGraphBuilder.WriteTexture(in input);
			renderGraphBuilder.SetRenderFunc(delegate(ColorGradingPassData data, RenderGraphContext ctx)
			{
				ComputeShader builderCS = data.builderCS;
				int builderKernel = data.builderKernel;
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._OutputTexture, data.logLut);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Size, new Vector4(data.lutSize, 1f / ((float)data.lutSize - 1f), 0f, 0f));
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ColorBalance, data.lmsColorBalance);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ColorFilter, data.colorFilter);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ChannelMixerRed, data.channelMixerR);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ChannelMixerGreen, data.channelMixerG);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ChannelMixerBlue, data.channelMixerB);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._HueSatCon, data.hueSatCon);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Lift, data.lift);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Gamma, data.gamma);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Gain, data.gain);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Shadows, data.shadows);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Midtones, data.midtones);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Highlights, data.highlights);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ShaHiLimits, data.shadowsHighlightsLimits);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._SplitShadows, data.splitShadows);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._SplitHighlights, data.splitHighlights);
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveMaster, data.curves.master.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveRed, data.curves.red.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveGreen, data.curves.green.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveBlue, data.curves.blue.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveHueVsHue, data.curves.hueVsHue.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveHueVsSat, data.curves.hueVsSat.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveLumVsSat, data.curves.lumVsSat.value.GetTexture());
				ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._CurveSatVsSat, data.curves.satVsSat.value.GetTexture());
				if (data.tonemappingMode == TonemappingMode.Custom)
				{
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._CustomToneCurve, data.hableCurve.uniforms.curve);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ToeSegmentA, data.hableCurve.uniforms.toeSegmentA);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ToeSegmentB, data.hableCurve.uniforms.toeSegmentB);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._MidSegmentA, data.hableCurve.uniforms.midSegmentA);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._MidSegmentB, data.hableCurve.uniforms.midSegmentB);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ShoSegmentA, data.hableCurve.uniforms.shoSegmentA);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._ShoSegmentB, data.hableCurve.uniforms.shoSegmentB);
				}
				else if (data.tonemappingMode == TonemappingMode.External)
				{
					ctx.cmd.SetComputeTextureParam(builderCS, builderKernel, HDShaderIDs._LogLut3D, data.externalLuT);
					ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._LogLut3D_Params, new Vector4(1f / (float)data.lutSize, (float)data.lutSize - 1f, data.lutContribution, 0f));
				}
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._HDROutputParams, data.hdroutParameters);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._HDROutputParams2, data.hdroutParameters2);
				ctx.cmd.SetComputeVectorParam(builderCS, HDShaderIDs._Params, data.miscParams);
				uint num2 = 4u;
				uint num3 = 4u;
				uint num4 = 4u;
				ctx.cmd.DispatchCompute(builderCS, builderKernel, (int)((data.lutSize + num2 - 1) / num2), (int)((data.lutSize + num3 - 1) / num3), (int)((data.lutSize + num4 - 1) / num4));
			});
			return passData.logLut;
		}

		private UberPostFeatureFlags GetUberFeatureFlags(HDCamera camera, bool isSceneView)
		{
			UberPostFeatureFlags uberPostFeatureFlags = UberPostFeatureFlags.None;
			if (m_ChromaticAberration.IsActive() && m_ChromaticAberrationFS)
			{
				uberPostFeatureFlags |= UberPostFeatureFlags.ChromaticAberration;
			}
			if (m_Vignette.IsActive() && m_VignetteFS)
			{
				uberPostFeatureFlags |= UberPostFeatureFlags.Vignette;
			}
			if (m_LensDistortion.IsActive() && !isSceneView && m_LensDistortionFS)
			{
				uberPostFeatureFlags |= UberPostFeatureFlags.LensDistortion;
			}
			if (PostProcessEnableAlpha(camera))
			{
				uberPostFeatureFlags |= UberPostFeatureFlags.EnableAlpha;
			}
			return uberPostFeatureFlags;
		}

		private void PrepareLensDistortionParameters(UberPostPassData data, UberPostFeatureFlags flags)
		{
			if ((flags & UberPostFeatureFlags.LensDistortion) == UberPostFeatureFlags.LensDistortion)
			{
				data.uberPostCS.EnableKeyword("LENS_DISTORTION");
				float b = 1.6f * Mathf.Max(Mathf.Abs(m_LensDistortion.intensity.value * 100f), 1f);
				float num = MathF.PI / 180f * Mathf.Min(160f, b);
				float y = 2f * Mathf.Tan(num * 0.5f);
				Vector2 vector = m_LensDistortion.center.value * 2f - Vector2.one;
				data.lensDistortionParams1 = new Vector4(vector.x, vector.y, Mathf.Max(m_LensDistortion.xMultiplier.value, 0.0001f), Mathf.Max(m_LensDistortion.yMultiplier.value, 0.0001f));
				data.lensDistortionParams2 = new Vector4((m_LensDistortion.intensity.value >= 0f) ? num : (1f / num), y, 1f / m_LensDistortion.scale.value, m_LensDistortion.intensity.value * 100f);
			}
		}

		private void PrepareChromaticAberrationParameters(UberPostPassData data, UberPostFeatureFlags flags)
		{
			if ((flags & UberPostFeatureFlags.ChromaticAberration) != UberPostFeatureFlags.ChromaticAberration)
			{
				return;
			}
			data.uberPostCS.EnableKeyword("CHROMATIC_ABERRATION");
			Texture texture = m_ChromaticAberration.spectralLut.value;
			if (texture == null)
			{
				if (m_InternalSpectralLut == null)
				{
					m_InternalSpectralLut = new Texture2D(3, 1, GraphicsFormat.R8G8B8A8_SRGB, TextureCreationFlags.None)
					{
						name = "Chromatic Aberration Spectral LUT",
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0,
						hideFlags = HideFlags.DontSave
					};
					m_InternalSpectralLut.SetPixels(new Color[3]
					{
						new Color(1f, 0f, 0f, 1f),
						new Color(0f, 1f, 0f, 1f),
						new Color(0f, 0f, 1f, 1f)
					});
					m_InternalSpectralLut.Apply();
				}
				texture = m_InternalSpectralLut;
			}
			data.spectralLut = texture;
			data.chromaticAberrationParameters = new Vector4(m_ChromaticAberration.intensity.value * 0.05f, m_ChromaticAberration.maxSamples, 0f, 0f);
		}

		private void PrepareVignetteParameters(UberPostPassData data, UberPostFeatureFlags flags)
		{
			if ((flags & UberPostFeatureFlags.Vignette) == UberPostFeatureFlags.Vignette)
			{
				data.uberPostCS.EnableKeyword("VIGNETTE");
				if (m_Vignette.mode.value == VignetteMode.Procedural)
				{
					float z = (1f - m_Vignette.roundness.value) * 6f + m_Vignette.roundness.value;
					data.vignetteParams1 = new Vector4(m_Vignette.center.value.x, m_Vignette.center.value.y, 0f, 0f);
					data.vignetteParams2 = new Vector4(m_Vignette.intensity.value * 3f, m_Vignette.smoothness.value * 5f, z, m_Vignette.rounded.value ? 1f : 0f);
					data.vignetteColor = m_Vignette.color.value;
					data.vignetteMask = Texture2D.blackTexture;
				}
				else
				{
					Color value = m_Vignette.color.value;
					value.a = Mathf.Clamp01(m_Vignette.opacity.value);
					data.vignetteParams1 = new Vector4(0f, 0f, 1f, 0f);
					data.vignetteColor = value;
					data.vignetteMask = m_Vignette.mask.value;
				}
			}
		}

		private Vector4 GetBloomThresholdParams()
		{
			float num = Mathf.GammaToLinearSpace(m_Bloom.threshold.value);
			float num2 = num * 0.5f + 1E-05f;
			return new Vector4(num, num - num2, num2 * 2f, 0.25f / num2);
		}

		private void PrepareUberBloomParameters(UberPostPassData data, HDCamera camera)
		{
			float num = Mathf.Pow(2f, m_Bloom.intensity.value) - 1f;
			Color color = m_Bloom.tint.value.linear;
			float num2 = ColorUtils.Luminance(in color);
			color = ((num2 > 0f) ? (color * (1f / num2)) : Color.white);
			Texture texture = ((m_Bloom.dirtTexture.value == null) ? Texture2D.blackTexture : m_Bloom.dirtTexture.value);
			int num3 = ((m_Bloom.dirtTexture.value != null && m_Bloom.dirtIntensity.value > 0f) ? 1 : 0);
			float num4 = (float)texture.width / (float)texture.height;
			float num5 = (float)postProcessViewportSize.x / (float)postProcessViewportSize.y;
			Vector4 bloomDirtTileOffset = new Vector4(1f, 1f, 0f, 0f);
			float y = m_Bloom.dirtIntensity.value * num;
			if (num4 > num5)
			{
				bloomDirtTileOffset.x = num5 / num4;
				bloomDirtTileOffset.z = (1f - bloomDirtTileOffset.x) * 0.5f;
			}
			else if (num5 > num4)
			{
				bloomDirtTileOffset.y = num4 / num5;
				bloomDirtTileOffset.w = (1f - bloomDirtTileOffset.y) * 0.5f;
			}
			data.bloomDirtTexture = texture;
			data.bloomParams = new Vector4(num, y, 1f, num3);
			data.bloomTint = color;
			data.bloomDirtTileOffset = bloomDirtTileOffset;
			data.bloomThreshold = GetBloomThresholdParams();
			data.bloomBicubicParams = m_BloomBicubicParams;
		}

		private void PrepareAlphaScaleParameters(UberPostPassData data, HDCamera camera)
		{
			if (PostProcessEnableAlpha(camera))
			{
				data.alphaScaleBias = CompositionManager.GetAlphaScaleAndBiasForCamera(camera);
			}
			else
			{
				data.alphaScaleBias = new Vector4(1f, 0f, 0f, 0f);
			}
		}

		private TextureHandle UberPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle logLut, TextureHandle bloomTexture, TextureHandle source)
		{
			bool isSceneView = hdCamera.camera.cameraType == CameraType.SceneView;
			UberPostFeatureFlags uberFeatureFlags = GetUberFeatureFlags(hdCamera, isSceneView);
			if (uberFeatureFlags == UberPostFeatureFlags.None && !m_ColorGradingFS && !m_BloomFS && m_CurrentDebugDisplaySettings.data.fullScreenDebugMode != FullScreenDebugMode.ColorLog)
			{
				return source;
			}
			UberPostPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UberPostPassData>("Uber Post", out passData, ProfilingSampler.Get(HDProfileId.UberPost));
			TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "Uber Post Destination");
			passData.uberPostCS = defaultResources.shaders.uberPostCS;
			passData.uberPostCS.shaderKeywords = null;
			passData.uberPostKernel = passData.uberPostCS.FindKernel("Uber");
			if (m_ScreenCoordOverride)
			{
				passData.uberPostCS.EnableKeyword("SCREEN_COORD_OVERRIDE");
			}
			if (PostProcessEnableAlpha(hdCamera))
			{
				passData.uberPostCS.EnableKeyword("ENABLE_ALPHA");
			}
			if (hdCamera.DynResRequest.enabled && hdCamera.DynResRequest.filter == DynamicResUpscaleFilter.EdgeAdaptiveScalingUpres && DynamicResolutionHandler.instance.upsamplerSchedule == DynamicResolutionHandler.UpsamplerScheduleType.AfterPost && !hdCamera.IsDLSSEnabled())
			{
				passData.uberPostCS.EnableKeyword("GAMMA2_OUTPUT");
			}
			if (HDROutputActiveForCameraType(m_CurrCameraType))
			{
				HDROutputUtils.ConfigureHDROutput(passData.uberPostCS, HDROutputSettings.main.displayColorGamut, HDROutputUtils.Operation.ColorConversion);
			}
			passData.outputColorLog = m_CurrentDebugDisplaySettings.data.fullScreenDebugMode == FullScreenDebugMode.ColorLog;
			passData.isSearchingInHierarchy = CoreUtils.IsSceneFilteringEnabled();
			passData.width = postProcessViewportSize.x;
			passData.height = postProcessViewportSize.y;
			passData.viewCount = hdCamera.viewCount;
			float z = Mathf.Pow(2f, m_ColorAdjustments.postExposure.value);
			passData.logLutSettings = new Vector4(1f / (float)m_LutSize, (float)m_LutSize - 1f, z, (m_ColorGradingFS || m_TonemappingFS) ? 1 : 0);
			PrepareLensDistortionParameters(passData, uberFeatureFlags);
			PrepareChromaticAberrationParameters(passData, uberFeatureFlags);
			PrepareVignetteParameters(passData, uberFeatureFlags);
			PrepareUberBloomParameters(passData, hdCamera);
			PrepareAlphaScaleParameters(passData, hdCamera);
			passData.source = renderGraphBuilder.ReadTexture(in source);
			passData.bloomTexture = renderGraphBuilder.ReadTexture(in bloomTexture);
			passData.logLut = renderGraphBuilder.ReadTexture(in logLut);
			passData.destination = renderGraphBuilder.WriteTexture(in input);
			renderGraphBuilder.SetRenderFunc(delegate(UberPostPassData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._LogLut3D, data.logLut);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._LogLut3D_Params, data.logLutSettings);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._DistortionParams1, data.lensDistortionParams1);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._DistortionParams2, data.lensDistortionParams2);
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._ChromaSpectralLut, data.spectralLut);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._ChromaParams, data.chromaticAberrationParameters);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._VignetteParams1, data.vignetteParams1);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._VignetteParams2, data.vignetteParams2);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._VignetteColor, data.vignetteColor);
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._VignetteMask, data.vignetteMask);
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._BloomTexture, data.bloomTexture);
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._BloomDirtTexture, data.bloomDirtTexture);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._BloomParams, data.bloomParams);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._BloomTint, data.bloomTint);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._BloomBicubicParams, data.bloomBicubicParams);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._BloomDirtScaleOffset, data.bloomDirtTileOffset);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._BloomThreshold, data.bloomThreshold);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, HDShaderIDs._AlphaScaleBias, data.alphaScaleBias);
				ctx.cmd.SetComputeVectorParam(data.uberPostCS, "_DebugFlags", new Vector4(data.outputColorLog ? 1 : 0, 0f, 0f, data.isSearchingInHierarchy ? 1 : 0));
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._InputTexture, data.source);
				ctx.cmd.SetComputeTextureParam(data.uberPostCS, data.uberPostKernel, HDShaderIDs._OutputTexture, data.destination);
				ctx.cmd.DispatchCompute(data.uberPostCS, data.uberPostKernel, (data.width + 7) / 8, (data.height + 7) / 8, data.viewCount);
			});
			source = passData.destination;
			return source;
		}

		private TextureHandle FXAAPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (hdCamera.DynResRequest.enabled && hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.FastApproximateAntialiasing && m_AntialiasingFS)
			{
				FXAAData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<FXAAData>("FXAA", out passData, ProfilingSampler.Get(HDProfileId.FXAA));
				try
				{
					passData.fxaaCS = defaultResources.shaders.FXAACS;
					passData.fxaaKernel = passData.fxaaCS.FindKernel("FXAA");
					passData.width = postProcessViewportSize.x;
					passData.height = postProcessViewportSize.y;
					passData.viewCount = hdCamera.viewCount;
					passData.source = renderGraphBuilder.ReadTexture(in source);
					FXAAData fXAAData = passData;
					TextureHandle input = GetPostprocessOutputHandle(hdCamera, renderGraph, "FXAA Destination");
					fXAAData.destination = renderGraphBuilder.WriteTexture(in input);
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						GetHDROutputParameters(m_Tonemapping, out passData.hdroutParameters, out var _);
					}
					passData.fxaaCS.shaderKeywords = null;
					if (PostProcessEnableAlpha(hdCamera))
					{
						passData.fxaaCS.EnableKeyword("ENABLE_ALPHA");
					}
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						passData.fxaaCS.EnableKeyword("HDR_INPUT");
					}
					renderGraphBuilder.SetRenderFunc(delegate(FXAAData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeTextureParam(data.fxaaCS, data.fxaaKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeTextureParam(data.fxaaCS, data.fxaaKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.SetComputeVectorParam(data.fxaaCS, HDShaderIDs._HDROutputParams, data.hdroutParameters);
						ctx.cmd.DispatchCompute(data.fxaaCS, data.fxaaKernel, (data.width + 7) / 8, (data.height + 7) / 8, data.viewCount);
					});
					source = passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return source;
		}

		private TextureHandle ContrastAdaptiveSharpeningPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (hdCamera.DynResRequest.enabled && hdCamera.DynResRequest.filter == DynamicResUpscaleFilter.ContrastAdaptiveSharpen)
			{
				CASData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CASData>("Contrast Adaptive Sharpen", out passData, ProfilingSampler.Get(HDProfileId.ContrastAdaptiveSharpen));
				try
				{
					passData.casCS = defaultResources.shaders.contrastAdaptiveSharpenCS;
					passData.casCS.shaderKeywords = null;
					passData.initKernel = passData.casCS.FindKernel("KInitialize");
					passData.mainKernel = passData.casCS.FindKernel("KMain");
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						passData.casCS.EnableKeyword("HDR_INPUT");
					}
					passData.viewCount = hdCamera.viewCount;
					passData.inputWidth = postProcessViewportSize.x;
					passData.inputHeight = postProcessViewportSize.y;
					passData.outputWidth = Mathf.RoundToInt(hdCamera.finalViewport.width);
					passData.outputHeight = Mathf.RoundToInt(hdCamera.finalViewport.height);
					passData.source = renderGraphBuilder.ReadTexture(in source);
					CASData cASData = passData;
					TextureHandle input = GetPostprocessUpsampledOutputHandle(hdCamera, renderGraph, "Contrast Adaptive Sharpen Destination");
					cASData.destination = renderGraphBuilder.WriteTexture(in input);
					CASData cASData2 = passData;
					ComputeBufferDesc desc = new ComputeBufferDesc(2, 16)
					{
						name = "Cas Parameters"
					};
					cASData2.casParametersBuffer = renderGraphBuilder.CreateTransientComputeBuffer(in desc);
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						GetHDROutputParameters(m_Tonemapping, out passData.hdroutParams, out var _);
					}
					renderGraphBuilder.SetRenderFunc(delegate(CASData data, RenderGraphContext ctx)
					{
						ctx.cmd.SetComputeFloatParam(data.casCS, HDShaderIDs._Sharpness, 1f);
						ctx.cmd.SetComputeTextureParam(data.casCS, data.mainKernel, HDShaderIDs._InputTexture, data.source);
						ctx.cmd.SetComputeVectorParam(data.casCS, HDShaderIDs._InputTextureDimensions, new Vector4(data.inputWidth, data.inputHeight));
						ctx.cmd.SetComputeTextureParam(data.casCS, data.mainKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.SetComputeVectorParam(data.casCS, HDShaderIDs._OutputTextureDimensions, new Vector4(data.outputWidth, data.outputHeight));
						ctx.cmd.SetComputeBufferParam(data.casCS, data.initKernel, "CasParameters", data.casParametersBuffer);
						ctx.cmd.SetComputeBufferParam(data.casCS, data.mainKernel, "CasParameters", data.casParametersBuffer);
						ctx.cmd.SetComputeVectorParam(data.casCS, HDShaderIDs._HDROutputParams, data.hdroutParams);
						ctx.cmd.DispatchCompute(data.casCS, data.initKernel, 1, 1, 1);
						int threadGroupsX = HDUtils.DivRoundUp(data.outputWidth, 16);
						int threadGroupsY = HDUtils.DivRoundUp(data.outputHeight, 16);
						ctx.cmd.DispatchCompute(data.casCS, data.mainKernel, threadGroupsX, threadGroupsY, data.viewCount);
					});
					source = passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				SetCurrentResolutionGroup(renderGraph, hdCamera, ResolutionGroup.AfterDynamicResUpscale);
			}
			return source;
		}

		private TextureHandle EdgeAdaptiveSpatialUpsampling(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source)
		{
			if (hdCamera.DynResRequest.enabled && hdCamera.DynResRequest.filter == DynamicResUpscaleFilter.EdgeAdaptiveScalingUpres)
			{
				EASUData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<EASUData>("Edge Adaptive Spatial Upsampling", out passData, ProfilingSampler.Get(HDProfileId.EdgeAdaptiveSpatialUpsampling));
				try
				{
					passData.easuCS = defaultResources.shaders.edgeAdaptiveSpatialUpsamplingCS;
					passData.easuCS.shaderKeywords = null;
					if (PostProcessEnableAlpha(hdCamera))
					{
						passData.easuCS.EnableKeyword("ENABLE_ALPHA");
					}
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						passData.easuCS.EnableKeyword("HDR_INPUT");
					}
					passData.mainKernel = passData.easuCS.FindKernel("KMain");
					passData.viewCount = hdCamera.viewCount;
					passData.inputWidth = hdCamera.actualWidth;
					passData.inputHeight = hdCamera.actualHeight;
					passData.outputWidth = Mathf.RoundToInt(hdCamera.finalViewport.width);
					passData.outputHeight = Mathf.RoundToInt(hdCamera.finalViewport.height);
					passData.source = renderGraphBuilder.ReadTexture(in source);
					EASUData eASUData = passData;
					TextureHandle input = GetPostprocessUpsampledOutputHandle(hdCamera, renderGraph, "Edge Adaptive Spatial Upsampling");
					eASUData.destination = renderGraphBuilder.WriteTexture(in input);
					if (HDROutputActiveForCameraType(m_CurrCameraType))
					{
						GetHDROutputParameters(m_Tonemapping, out passData.hdroutParams, out var _);
					}
					renderGraphBuilder.SetRenderFunc(delegate(EASUData data, RenderGraphContext ctx)
					{
						RenderTexture renderTexture = data.source;
						Vector4 vector = new Vector4(renderTexture.width, renderTexture.height);
						if (DynamicResolutionHandler.instance.HardwareDynamicResIsEnabled())
						{
							Vector2Int vector2Int = DynamicResolutionHandler.instance.ApplyScalesOnSize(new Vector2Int(RTHandles.maxWidth, RTHandles.maxHeight));
							vector = new Vector4(vector2Int.x, vector2Int.y);
						}
						ctx.cmd.SetComputeTextureParam(data.easuCS, data.mainKernel, HDShaderIDs._InputTexture, data.source);
						FSRUtils.SetEasuConstants(ctx.cmd, new Vector2(data.inputWidth, data.inputHeight), vector, new Vector2(data.outputWidth, data.outputHeight));
						ctx.cmd.SetComputeTextureParam(data.easuCS, data.mainKernel, HDShaderIDs._OutputTexture, data.destination);
						ctx.cmd.SetComputeVectorParam(data.easuCS, HDShaderIDs._EASUOutputSize, new Vector4(data.outputWidth, data.outputHeight, 1f / (float)data.outputWidth, 1f / (float)data.outputHeight));
						ctx.cmd.SetComputeVectorParam(data.easuCS, HDShaderIDs._HDROutputParams, data.hdroutParams);
						int threadGroupsX = HDUtils.DivRoundUp(data.outputWidth, 8);
						int threadGroupsY = HDUtils.DivRoundUp(data.outputHeight, 8);
						ctx.cmd.DispatchCompute(data.easuCS, data.mainKernel, threadGroupsX, threadGroupsY, data.viewCount);
					});
					source = passData.destination;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				SetCurrentResolutionGroup(renderGraph, hdCamera, ResolutionGroup.AfterDynamicResUpscale);
			}
			return source;
		}

		private void FinalPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle afterPostProcessTexture, TextureHandle alphaTexture, TextureHandle finalRT, TextureHandle source, TextureHandle uiBuffer, BlueNoise blueNoise, bool flipY, CubemapFace cubemapFace, bool postProcessIsFinalPass)
		{
			FinalPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<FinalPassData>("Final Pass", out passData, ProfilingSampler.Get(HDProfileId.FinalPost));
			passData.postProcessEnabled = m_PostProcessEnabled;
			passData.performUpsampling = !hdCamera.IsDLSSEnabled() && DynamicResolutionHandler.instance.upsamplerSchedule == DynamicResolutionHandler.UpsamplerScheduleType.AfterPost;
			passData.finalPassMaterial = m_FinalPassMaterial;
			passData.hdCamera = hdCamera;
			passData.blueNoise = blueNoise;
			passData.flipY = flipY;
			passData.random = m_Random;
			passData.enableAlpha = PostProcessEnableAlpha(hdCamera);
			passData.keepAlpha = m_KeepAlpha;
			passData.dynamicResIsOn = hdCamera.canDoDynamicResolution && hdCamera.DynResRequest.enabled;
			passData.dynamicResFilter = hdCamera.DynResRequest.filter;
			passData.drsSettings = currentAsset.currentPlatformRenderPipelineSettings.dynamicResolutionSettings;
			passData.useFXAA = hdCamera.antialiasing == HDAdditionalCameraData.AntialiasingMode.FastApproximateAntialiasing && !passData.dynamicResIsOn && m_AntialiasingFS;
			passData.filmGrainEnabled = m_FilmGrain.IsActive() && m_FilmGrainFS;
			if (m_FilmGrain.type.value != FilmGrainLookup.Custom)
			{
				passData.filmGrainTexture = defaultResources.textures.filmGrainTex[(int)m_FilmGrain.type.value];
			}
			else
			{
				passData.filmGrainTexture = m_FilmGrain.texture.value;
			}
			passData.filmGrainIntensity = m_FilmGrain.intensity.value;
			passData.filmGrainResponse = m_FilmGrain.response.value;
			passData.hdrOutputIsActive = HDROutputActiveForCameraType(m_CurrCameraType);
			passData.ditheringEnabled = hdCamera.dithering && m_DitheringFS;
			passData.source = renderGraphBuilder.ReadTexture(in source);
			passData.afterPostProcessTexture = renderGraphBuilder.ReadTexture(in afterPostProcessTexture);
			passData.alphaTexture = renderGraphBuilder.ReadTexture(in alphaTexture);
			passData.destination = renderGraphBuilder.WriteTexture(in finalRT);
			passData.uiBuffer = renderGraphBuilder.ReadTexture(in uiBuffer);
			passData.cubemapFace = cubemapFace;
			passData.postProcessIsFinalPass = postProcessIsFinalPass;
			if (passData.hdrOutputIsActive)
			{
				GetHDROutputParameters(m_Tonemapping, out passData.hdroutParameters, out passData.hdroutParameters2);
			}
			renderGraphBuilder.SetRenderFunc(delegate(FinalPassData data, RenderGraphContext ctx)
			{
				Material finalPassMaterial = data.finalPassMaterial;
				finalPassMaterial.shaderKeywords = null;
				finalPassMaterial.SetTexture(HDShaderIDs._InputTexture, data.source);
				if (data.dynamicResIsOn)
				{
					if (data.performUpsampling)
					{
						switch (data.dynamicResFilter)
						{
						case DynamicResUpscaleFilter.CatmullRom:
							finalPassMaterial.EnableKeyword("CATMULL_ROM_4");
							break;
						case DynamicResUpscaleFilter.ContrastAdaptiveSharpen:
							finalPassMaterial.EnableKeyword("BYPASS");
							break;
						case DynamicResUpscaleFilter.EdgeAdaptiveScalingUpres:
						{
							float num = 0.92f;
							if (data.drsSettings.fsrOverrideSharpness)
							{
								num = (data.hdCamera.fsrOverrideSharpness ? data.hdCamera.fsrSharpness : data.drsSettings.fsrSharpness);
							}
							if ((double)num > 0.0)
							{
								finalPassMaterial.EnableKeyword("RCAS");
								FSRUtils.SetRcasConstantsLinear(ctx.cmd, num);
							}
							else
							{
								finalPassMaterial.EnableKeyword("BYPASS");
							}
							break;
						}
						}
					}
					else
					{
						finalPassMaterial.EnableKeyword("BYPASS");
					}
				}
				if (data.postProcessEnabled)
				{
					if (data.useFXAA)
					{
						finalPassMaterial.EnableKeyword("FXAA");
					}
					if (data.filmGrainEnabled && data.filmGrainTexture != null)
					{
						float z = (float)data.random.NextDouble();
						float w = (float)data.random.NextDouble();
						finalPassMaterial.EnableKeyword("GRAIN");
						finalPassMaterial.SetTexture(HDShaderIDs._GrainTexture, data.filmGrainTexture);
						finalPassMaterial.SetVector(HDShaderIDs._GrainParams, new Vector2(data.filmGrainIntensity * 4f, data.filmGrainResponse));
						float x = data.hdCamera.finalViewport.width / (float)data.filmGrainTexture.width;
						float y = data.hdCamera.finalViewport.height / (float)data.filmGrainTexture.height;
						finalPassMaterial.SetVector(HDShaderIDs._GrainTextureParams, new Vector4(x, y, z, w));
					}
					if (data.ditheringEnabled)
					{
						Texture2DArray textureArray16L = data.blueNoise.textureArray16L;
						int num2 = (int)data.hdCamera.GetCameraFrameCount() % textureArray16L.depth;
						finalPassMaterial.EnableKeyword("DITHER");
						finalPassMaterial.SetTexture(HDShaderIDs._BlueNoiseTexture, textureArray16L);
						finalPassMaterial.SetVector(HDShaderIDs._DitherParams, new Vector3(data.hdCamera.finalViewport.width / (float)textureArray16L.width, data.hdCamera.finalViewport.height / (float)textureArray16L.height, num2));
					}
				}
				RTHandle rTHandle = data.alphaTexture;
				finalPassMaterial.SetTexture(HDShaderIDs._AlphaTexture, rTHandle);
				finalPassMaterial.SetFloat(HDShaderIDs._KeepAlpha, data.keepAlpha ? 1f : 0f);
				if (data.enableAlpha)
				{
					finalPassMaterial.EnableKeyword("ENABLE_ALPHA");
				}
				else
				{
					finalPassMaterial.DisableKeyword("ENABLE_ALPHA");
				}
				bool hdrOutputIsActive = data.hdrOutputIsActive;
				int num3;
				if (hdrOutputIsActive)
				{
					num3 = (data.postProcessIsFinalPass ? 1 : 0);
					if (num3 != 0)
					{
						HDROutputUtils.ConfigureHDROutput(data.finalPassMaterial, HDROutputSettings.main.displayColorGamut, HDROutputUtils.Operation.ColorEncoding);
						finalPassMaterial.SetVector(HDShaderIDs._HDROutputParams, data.hdroutParameters);
						finalPassMaterial.SetVector(HDShaderIDs._HDROutputParams2, data.hdroutParameters2);
						goto IL_0357;
					}
				}
				else
				{
					num3 = 0;
				}
				if (hdrOutputIsActive)
				{
					data.finalPassMaterial.EnableKeyword("HDR_INPUT");
					finalPassMaterial.SetVector(HDShaderIDs._HDROutputParams, data.hdroutParameters);
					finalPassMaterial.SetVector(HDShaderIDs._HDROutputParams2, data.hdroutParameters2);
				}
				goto IL_0357;
				IL_0357:
				finalPassMaterial.SetTexture(HDShaderIDs._UITexture, data.uiBuffer);
				finalPassMaterial.SetVector(HDShaderIDs._UVTransform, data.flipY ? new Vector4(1f, -1f, 0f, 1f) : new Vector4(1f, 1f, 0f, 0f));
				finalPassMaterial.SetVector(HDShaderIDs._ViewPortSize, new Vector4(data.hdCamera.finalViewport.width, data.hdCamera.finalViewport.height, 1f / data.hdCamera.finalViewport.width, 1f / data.hdCamera.finalViewport.height));
				Rect finalViewport = data.hdCamera.finalViewport;
				if (!data.postProcessIsFinalPass)
				{
					float x2 = (finalViewport.y = 0f);
					finalViewport.x = x2;
				}
				if (num3 != 0 && data.hdCamera.frameSettings.IsEnabled(FrameSettingsField.AfterPostprocess))
				{
					finalPassMaterial.EnableKeyword("APPLY_AFTER_POST");
					finalPassMaterial.SetTexture(HDShaderIDs._AfterPostProcessTexture, data.afterPostProcessTexture);
				}
				else if (!data.hdrOutputIsActive && data.hdCamera.frameSettings.IsEnabled(FrameSettingsField.AfterPostprocess))
				{
					finalPassMaterial.EnableKeyword("APPLY_AFTER_POST");
					finalPassMaterial.SetTexture(HDShaderIDs._AfterPostProcessTexture, data.afterPostProcessTexture);
				}
				else
				{
					finalPassMaterial.SetTexture(HDShaderIDs._AfterPostProcessTexture, TextureXR.GetBlackTexture());
				}
				HDUtils.DrawFullScreen(ctx.cmd, finalViewport, finalPassMaterial, data.destination, data.cubemapFace);
			});
		}

		private void InitializePrepass(HDRenderPipelineAsset hdAsset)
		{
			m_DepthResolveMaterial = CoreUtils.CreateEngineMaterial(asset.renderPipelineResources.shaders.depthValuesPS);
			m_CameraMotionVectorsMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.cameraMotionVectorsPS);
			m_DecalNormalBufferMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.decalNormalBufferPS);
			m_DownsampleDepthMaterialHalfresCheckerboard = CoreUtils.CreateEngineMaterial(defaultResources.shaders.downsampleDepthPS);
			m_DownsampleDepthMaterialGather = CoreUtils.CreateEngineMaterial(defaultResources.shaders.downsampleDepthPS);
			m_DownsampleDepthMaterialGather.EnableKeyword("GATHER_DOWNSAMPLE");
			m_GBufferOutput = default(GBufferOutput);
			m_GBufferOutput.mrt = new TextureHandle[RenderGraph.kMaxMRTCount];
			m_DBufferOutput = default(DBufferOutput);
			m_DBufferOutput.mrt = new TextureHandle[4];
			m_GPUCopy = new GPUCopy(defaultResources.shaders.copyChannelCS);
		}

		private void CleanupPrepass()
		{
			CoreUtils.Destroy(m_DepthResolveMaterial);
			CoreUtils.Destroy(m_CameraMotionVectorsMaterial);
			CoreUtils.Destroy(m_DecalNormalBufferMaterial);
			CoreUtils.Destroy(m_DownsampleDepthMaterialHalfresCheckerboard);
			CoreUtils.Destroy(m_DownsampleDepthMaterialGather);
		}

		private bool NeedClearGBuffer(HDCamera hdCamera)
		{
			if (!m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled())
			{
				return hdCamera.frameSettings.IsEnabled(FrameSettingsField.ClearGBuffers);
			}
			return true;
		}

		private TextureHandle CreateDepthBuffer(RenderGraph renderGraph, bool clear, MSAASamples msaaSamples)
		{
			bool flag = msaaSamples != MSAASamples.None;
			FastMemoryDesc fastMemoryDesc = default(FastMemoryDesc);
			fastMemoryDesc.inFastMemory = true;
			fastMemoryDesc.residencyFraction = 1f;
			fastMemoryDesc.flags = FastMemoryFlags.SpillTop;
			TextureDesc textureDesc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true);
			textureDesc.depthBufferBits = DepthBits.Depth32;
			textureDesc.bindTextureMS = flag;
			textureDesc.msaaSamples = msaaSamples;
			textureDesc.clearBuffer = clear;
			textureDesc.name = (flag ? "CameraDepthStencilMSAA" : "CameraDepthStencil");
			textureDesc.disableFallBackToImportedTexture = true;
			textureDesc.fallBackToBlackTexture = true;
			textureDesc.fastMemoryDesc = fastMemoryDesc;
			TextureDesc desc = textureDesc;
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle CreateNormalBuffer(RenderGraph renderGraph, HDCamera hdCamera, MSAASamples msaaSamples)
		{
			bool flag = msaaSamples != MSAASamples.None;
			FastMemoryDesc fastMemoryDesc = default(FastMemoryDesc);
			fastMemoryDesc.inFastMemory = true;
			fastMemoryDesc.residencyFraction = 1f;
			fastMemoryDesc.flags = FastMemoryFlags.SpillTop;
			TextureDesc textureDesc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true);
			textureDesc.colorFormat = GraphicsFormat.R8G8B8A8_UNorm;
			textureDesc.clearBuffer = NeedClearGBuffer(hdCamera);
			textureDesc.clearColor = Color.black;
			textureDesc.bindTextureMS = flag;
			textureDesc.msaaSamples = msaaSamples;
			textureDesc.enableRandomWrite = !flag;
			textureDesc.name = (flag ? "NormalBufferMSAA" : "NormalBuffer");
			textureDesc.fallBackToBlackTexture = true;
			textureDesc.fastMemoryDesc = fastMemoryDesc;
			TextureDesc desc = textureDesc;
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle CreateRenderingLayersBuffer(RenderGraph renderGraph, MSAASamples msaaSamples, bool decalLayers)
		{
			bool flag = msaaSamples != MSAASamples.None;
			bool enableRandomWrite = decalLayers && !flag;
			TextureDesc textureDesc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true);
			textureDesc.colorFormat = GraphicsFormat.R8G8B8A8_UNorm;
			textureDesc.clearBuffer = true;
			textureDesc.clearColor = Color.clear;
			textureDesc.bindTextureMS = false;
			textureDesc.msaaSamples = msaaSamples;
			textureDesc.enableRandomWrite = enableRandomWrite;
			textureDesc.name = (flag ? "RenderingLayersBufferMSAA" : "RenderingLayersBuffer");
			TextureDesc desc = textureDesc;
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle CreateDepthAsColorBuffer(RenderGraph renderGraph, MSAASamples msaaSamples)
		{
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R32_SFloat,
				clearBuffer = true,
				clearColor = Color.black,
				bindTextureMS = true,
				msaaSamples = msaaSamples,
				name = "DepthAsColorMSAA"
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle CreateMotionVectorBuffer(RenderGraph renderGraph, bool clear, MSAASamples msaaSamples)
		{
			bool flag = msaaSamples != MSAASamples.None;
			TextureDesc textureDesc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true);
			textureDesc.colorFormat = Builtin.GetMotionVectorFormat();
			textureDesc.bindTextureMS = flag;
			textureDesc.msaaSamples = msaaSamples;
			textureDesc.clearBuffer = clear;
			textureDesc.clearColor = Color.clear;
			textureDesc.name = (flag ? "Motion Vectors MSAA" : "Motion Vectors");
			TextureDesc desc = textureDesc;
			return renderGraph.CreateTexture(in desc);
		}

		private void BindMotionVectorPassColorBuffers(in RenderGraphBuilder builder, in PrepassOutput prepassOutput, HDCamera hdCamera)
		{
			bool num = hdCamera.msaaSamples != MSAASamples.None;
			bool flag = hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers);
			int num2 = 0;
			if (num)
			{
				builder.UseColorBuffer(in prepassOutput.depthAsColor, num2++);
			}
			builder.UseColorBuffer(in prepassOutput.motionVectorsBuffer, num2++);
			if (flag)
			{
				builder.UseColorBuffer(in prepassOutput.renderingLayersBuffer, num2++);
			}
			builder.UseColorBuffer(in prepassOutput.normalBuffer, num2++);
		}

		private PrepassOutput RenderPrepass(RenderGraph renderGraph, TextureHandle colorBuffer, TextureHandle sssBuffer, TextureHandle vtFeedbackBuffer, CullingResults cullingResults, CullingResults customPassCullingResults, HDCamera hdCamera, AOVRequestData aovRequest, List<RTHandle> aovBuffers)
		{
			m_IsDepthBufferCopyValid = false;
			PrepassOutput prepassOutput = default(PrepassOutput);
			prepassOutput.gbuffer = m_GBufferOutput;
			prepassOutput.dbuffer = m_DBufferOutput;
			bool msaaEnabled = hdCamera.msaaEnabled;
			bool flag = hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers);
			bool flag2 = flag || hdCamera.frameSettings.IsEnabled(FrameSettingsField.LightLayers);
			bool flag3 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors);
			prepassOutput.motionVectorsBuffer = (flag3 ? CreateMotionVectorBuffer(renderGraph, msaaEnabled, hdCamera.msaaSamples) : renderGraph.defaultResources.blackTextureXR);
			prepassOutput.depthBuffer = CreateDepthBuffer(renderGraph, hdCamera.clearDepth, hdCamera.msaaSamples);
			prepassOutput.stencilBuffer = prepassOutput.depthBuffer;
			prepassOutput.renderingLayersBuffer = (flag2 ? CreateRenderingLayersBuffer(renderGraph, hdCamera.msaaSamples, flag) : renderGraph.defaultResources.blackTextureXR);
			RenderXROcclusionMeshes(renderGraph, hdCamera, colorBuffer, prepassOutput.depthBuffer);
			using (new XRSinglePassScope(renderGraph, hdCamera))
			{
				RenderCustomPass(renderGraph, hdCamera, colorBuffer, in prepassOutput, customPassCullingResults, cullingResults, CustomPassInjectionPoint.BeforeRendering, aovRequest, aovBuffers);
				RenderRayTracingDepthPrepass(renderGraph, cullingResults, hdCamera, prepassOutput.depthBuffer);
				ApplyCameraMipBias(hdCamera);
				bool num = RenderDepthPrepass(renderGraph, cullingResults, hdCamera, ref prepassOutput);
				ResetCameraMipBias(hdCamera);
				if (!num)
				{
					RenderObjectsMotionVectors(renderGraph, cullingResults, hdCamera, in prepassOutput);
				}
				bool flag4 = msaaEnabled;
				if (flag4)
				{
					RenderCameraMotionVectors(renderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.motionVectorsBuffer);
				}
				PreRenderSky(renderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.normalBuffer);
				PreRenderVolumetricClouds(renderGraph, hdCamera);
				ResolvePrepassBuffers(renderGraph, hdCamera, ref prepassOutput);
				ApplyCameraMipBias(hdCamera);
				RenderDBuffer(renderGraph, hdCamera, ref prepassOutput, cullingResults);
				RenderGBuffer(renderGraph, sssBuffer, vtFeedbackBuffer, ref prepassOutput, cullingResults, hdCamera);
				if (num)
				{
					RenderObjectsMotionVectors(renderGraph, cullingResults, hdCamera, in prepassOutput);
				}
				DecalNormalPatch(renderGraph, hdCamera, ref prepassOutput);
				if (RenderCustomPass(renderGraph, hdCamera, colorBuffer, in prepassOutput, customPassCullingResults, cullingResults, CustomPassInjectionPoint.AfterOpaqueDepthAndNormal, aovRequest, aovBuffers))
				{
					m_IsDepthBufferCopyValid = false;
				}
				bool flag5 = (SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation4 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation5 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation5NGGC || SystemInfo.graphicsDeviceType == GraphicsDeviceType.XboxOne || SystemInfo.graphicsDeviceType == GraphicsDeviceType.XboxOneD3D12 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.GameCoreXboxOne || SystemInfo.graphicsDeviceType == GraphicsDeviceType.GameCoreXboxSeries) && hdCamera.frameSettings.IsEnabled(FrameSettingsField.LowResTransparent) && hdCamera.isLowResScaleHalf;
				ResetCameraMipBias(hdCamera);
				DownsampleDepthForLowResTransparency(renderGraph, hdCamera, flag5, ref prepassOutput);
				GenerateDepthPyramid(renderGraph, hdCamera, flag5, ref prepassOutput);
				if (!flag4)
				{
					RenderCameraMotionVectors(renderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.resolvedMotionVectorsBuffer);
				}
				BuildCoarseStencilAndResolveIfNeeded(renderGraph, hdCamera, resolveOnly: true, ref prepassOutput);
				RenderTransparencyOverdraw(renderGraph, prepassOutput.depthBuffer, cullingResults, hdCamera);
				return prepassOutput;
			}
		}

		private void RenderRayTracingDepthPrepass(RenderGraph renderGraph, CullingResults cull, HDCamera hdCamera, TextureHandle depthBuffer)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) || !hdCamera.volumeStack.GetComponent<RecursiveRendering>().enable.value || !GetRayTracingState() || !GetRayTracingClusterState())
			{
				return;
			}
			RayTracingDepthPrepassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RayTracingDepthPrepassData>("RayTracing Depth Prepass", out passData, ProfilingSampler.Get(HDProfileId.RayTracingDepthPrepass));
			try
			{
				passData.frameSettings = hdCamera.frameSettings;
				passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
				RayTracingDepthPrepassData rayTracingDepthPrepassData = passData;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cull, hdCamera.camera, m_RayTracingPrepassNames);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				rayTracingDepthPrepassData.opaqueRenderList = renderGraphBuilder.UseRendererList(in input);
				RayTracingDepthPrepassData rayTracingDepthPrepassData2 = passData;
				desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, m_RayTracingPrepassNames);
				input = renderGraph.CreateRendererList(in desc);
				rayTracingDepthPrepassData2.transparentRenderList = renderGraphBuilder.UseRendererList(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RayTracingDepthPrepassData data, RenderGraphContext context)
				{
					DrawOpaqueRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.opaqueRenderList);
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.transparentRenderList);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private bool RenderDepthPrepass(RenderGraph renderGraph, CullingResults cull, HDCamera hdCamera, ref PrepassOutput output)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				output.depthAsColor = CreateDepthAsColorBuffer(renderGraph, hdCamera.msaaSamples);
				output.normalBuffer = CreateNormalBuffer(renderGraph, hdCamera, hdCamera.msaaSamples);
				return false;
			}
			bool msaaEnabled = hdCamera.msaaEnabled;
			bool flag = hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers);
			bool flag2 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals);
			bool flag3 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.DepthPrepassWithDeferredRendering);
			bool flag4 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ObjectMotionVectors);
			bool excludeObjectMotionVectors = flag3 && flag4;
			bool result = hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred && !flag3;
			if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred)
			{
				string passName = (flag3 ? "Full Depth Prepass (Deferred)" : (flag2 ? "Partial Depth Prepass (Deferred - Decal + AlphaTest)" : "Partial Depth Prepass (Deferred - AlphaTest)"));
				DrawRendererListPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DrawRendererListPassData>(passName, out passData, ProfilingSampler.Get(HDProfileId.DeferredDepthPrepass));
				try
				{
					renderGraphBuilder.AllowRendererListCulling(value: false);
					passData.frameSettings = hdCamera.frameSettings;
					DrawRendererListPassData drawRendererListPassData = passData;
					RendererListDesc desc = CreateOpaqueRendererListDesc(cull, hdCamera.camera, m_DepthOnlyPassNames, PerObjectData.None, flag3 ? HDRenderQueue.k_RenderQueue_AllOpaque : (flag2 ? HDRenderQueue.k_RenderQueue_OpaqueDecalAndAlphaTest : HDRenderQueue.k_RenderQueue_OpaqueAlphaTest), m_AlphaToMaskBlock, null, excludeObjectMotionVectors);
					RendererListHandle input = renderGraph.CreateRendererList(in desc);
					drawRendererListPassData.rendererList = renderGraphBuilder.UseRendererList(in input);
					output.depthBuffer = renderGraphBuilder.UseDepthBuffer(in output.depthBuffer, DepthAccess.ReadWrite);
					if (flag)
					{
						renderGraphBuilder.UseColorBuffer(in output.renderingLayersBuffer, 0);
					}
					renderGraphBuilder.SetRenderFunc(delegate(DrawRendererListPassData data, RenderGraphContext context)
					{
						DrawOpaqueRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.rendererList);
					});
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			string passName2 = ((hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred) ? "Forward Depth Prepass (Deferred ForwardOnly)" : "Forward Depth Prepass");
			DrawRendererListPassData passData2;
			RenderGraphBuilder renderGraphBuilder2 = renderGraph.AddRenderPass<DrawRendererListPassData>(passName2, out passData2, ProfilingSampler.Get(HDProfileId.ForwardDepthPrepass));
			try
			{
				passData2.frameSettings = hdCamera.frameSettings;
				renderGraphBuilder2.AllowRendererListCulling(value: false);
				output.depthBuffer = renderGraphBuilder2.UseDepthBuffer(in output.depthBuffer, DepthAccess.ReadWrite);
				int num = 0;
				TextureHandle input2;
				if (msaaEnabled)
				{
					input2 = CreateDepthAsColorBuffer(renderGraph, hdCamera.msaaSamples);
					output.depthAsColor = renderGraphBuilder2.UseColorBuffer(in input2, num++);
				}
				input2 = CreateNormalBuffer(renderGraph, hdCamera, hdCamera.msaaSamples);
				output.normalBuffer = renderGraphBuilder2.UseColorBuffer(in input2, num++);
				if (flag)
				{
					renderGraphBuilder2.UseColorBuffer(in output.renderingLayersBuffer, num++);
				}
				if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Forward)
				{
					RenderStateBlock? renderStateBlock = (hdCamera.msaaEnabled ? null : new RenderStateBlock?(m_AlphaToMaskBlock));
					DrawRendererListPassData drawRendererListPassData2 = passData2;
					Camera camera = hdCamera.camera;
					ShaderTagId[] depthOnlyAndDepthForwardOnlyPassNames = m_DepthOnlyAndDepthForwardOnlyPassNames;
					RenderStateBlock? stateBlock = renderStateBlock;
					bool excludeObjectMotionVectors2 = flag4;
					RendererListDesc desc = CreateOpaqueRendererListDesc(cull, camera, depthOnlyAndDepthForwardOnlyPassNames, PerObjectData.None, null, stateBlock, null, excludeObjectMotionVectors2);
					RendererListHandle input = renderGraph.CreateRendererList(in desc);
					drawRendererListPassData2.rendererList = renderGraphBuilder2.UseRendererList(in input);
				}
				else if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred)
				{
					DrawRendererListPassData drawRendererListPassData3 = passData2;
					Camera camera2 = hdCamera.camera;
					ShaderTagId[] depthForwardOnlyPassNames = m_DepthForwardOnlyPassNames;
					RenderStateBlock? stateBlock = m_AlphaToMaskBlock;
					bool excludeObjectMotionVectors2 = flag4;
					RendererListDesc desc = CreateOpaqueRendererListDesc(cull, camera2, depthForwardOnlyPassNames, PerObjectData.None, null, stateBlock, null, excludeObjectMotionVectors2);
					RendererListHandle input = renderGraph.CreateRendererList(in desc);
					drawRendererListPassData3.rendererList = renderGraphBuilder2.UseRendererList(in input);
				}
				renderGraphBuilder2.SetRenderFunc(delegate(DrawRendererListPassData data, RenderGraphContext context)
				{
					DrawOpaqueRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.rendererList);
				});
				return result;
			}
			finally
			{
				((IDisposable)renderGraphBuilder2).Dispose();
			}
		}

		private void RenderObjectsMotionVectors(RenderGraph renderGraph, CullingResults cull, HDCamera hdCamera, in PrepassOutput output)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.ObjectMotionVectors) || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return;
			}
			DrawRendererListPassData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<DrawRendererListPassData>("Objects Motion Vectors Rendering", out passData, ProfilingSampler.Get(HDProfileId.ObjectsMotionVector));
			try
			{
				hdCamera.camera.depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
				passData.frameSettings = hdCamera.frameSettings;
				builder.UseDepthBuffer(in output.depthBuffer, DepthAccess.ReadWrite);
				BindMotionVectorPassColorBuffers(in builder, in output, hdCamera);
				RenderStateBlock? renderStateBlock = null;
				if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred || !hdCamera.msaaEnabled)
				{
					renderStateBlock = m_AlphaToMaskBlock;
				}
				DrawRendererListPassData drawRendererListPassData = passData;
				Camera camera = hdCamera.camera;
				ShaderTagId s_MotionVectorsName = HDShaderPassNames.s_MotionVectorsName;
				RenderStateBlock? stateBlock = renderStateBlock;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cull, camera, s_MotionVectorsName, PerObjectData.MotionVectors, null, stateBlock);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				drawRendererListPassData.rendererList = builder.UseRendererList(in input);
				builder.SetRenderFunc(delegate(DrawRendererListPassData data, RenderGraphContext context)
				{
					ref FrameSettings frameSettings = ref data.frameSettings;
					RendererList rendererList = data.rendererList;
					DrawOpaqueRendererList(in context, in frameSettings, in rendererList);
				});
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private void SetupGBufferTargets(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle sssBuffer, TextureHandle vtFeedbackBuffer, ref PrepassOutput prepassOutput, FrameSettings frameSettings, RenderGraphBuilder builder)
		{
			bool flag = NeedClearGBuffer(hdCamera);
			bool num = frameSettings.IsEnabled(FrameSettingsField.LightLayers);
			bool flag2 = frameSettings.IsEnabled(FrameSettingsField.Shadowmask);
			int num2 = 0;
			prepassOutput.depthBuffer = builder.UseDepthBuffer(in prepassOutput.depthBuffer, DepthAccess.ReadWrite);
			prepassOutput.gbuffer.mrt[num2] = builder.UseColorBuffer(in sssBuffer, num2++);
			prepassOutput.gbuffer.mrt[num2] = builder.UseColorBuffer(in prepassOutput.normalBuffer, num2++);
			FastMemoryDesc fastMemoryDesc = default(FastMemoryDesc);
			fastMemoryDesc.inFastMemory = true;
			fastMemoryDesc.residencyFraction = 1f;
			fastMemoryDesc.flags = FastMemoryFlags.SpillTop;
			bool clearBuffer = flag || hdCamera.IsSSREnabled();
			TextureHandle[] mrt = prepassOutput.gbuffer.mrt;
			int num3 = num2;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
				clearBuffer = clearBuffer,
				clearColor = Color.clear,
				name = "GBuffer2",
				fastMemoryDesc = fastMemoryDesc
			};
			TextureHandle input = renderGraph.CreateTexture(in desc);
			mrt[num3] = builder.UseColorBuffer(in input, num2++);
			TextureHandle[] mrt2 = prepassOutput.gbuffer.mrt;
			int num4 = num2;
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = Builtin.GetLightingBufferFormat(),
				clearBuffer = flag,
				clearColor = Color.clear,
				name = "GBuffer3",
				fastMemoryDesc = fastMemoryDesc
			};
			input = renderGraph.CreateTexture(in desc);
			mrt2[num4] = builder.UseColorBuffer(in input, num2++);
			prepassOutput.gbuffer.lightLayersTextureIndex = -1;
			prepassOutput.gbuffer.shadowMaskTextureIndex = -1;
			if (num)
			{
				prepassOutput.gbuffer.mrt[num2] = builder.UseColorBuffer(in prepassOutput.renderingLayersBuffer, num2);
				prepassOutput.gbuffer.lightLayersTextureIndex = num2++;
			}
			if (flag2)
			{
				TextureHandle[] mrt3 = prepassOutput.gbuffer.mrt;
				int num5 = num2;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = Builtin.GetShadowMaskBufferFormat(),
					clearBuffer = flag,
					clearColor = Color.clear,
					name = "ShadowMasks"
				};
				input = renderGraph.CreateTexture(in desc);
				mrt3[num5] = builder.UseColorBuffer(in input, num2);
				prepassOutput.gbuffer.shadowMaskTextureIndex = num2++;
			}
			prepassOutput.gbuffer.gBufferCount = num2;
		}

		private static void BindDBufferGlobalData(in DBufferOutput dBufferOutput, in RenderGraphContext ctx)
		{
			for (int i = 0; i < dBufferOutput.dBufferCount; i++)
			{
				ctx.cmd.SetGlobalTexture(HDShaderIDs._DBufferTexture[i], dBufferOutput.mrt[i]);
			}
		}

		private static GBufferOutput ReadGBuffer(GBufferOutput gBufferOutput, RenderGraphBuilder builder)
		{
			for (int i = 0; i < gBufferOutput.gBufferCount; i++)
			{
				gBufferOutput.mrt[i] = builder.ReadTexture(in gBufferOutput.mrt[i]);
			}
			return gBufferOutput;
		}

		private void RenderGBuffer(RenderGraph renderGraph, TextureHandle sssBuffer, TextureHandle vtFeedbackBuffer, ref PrepassOutput prepassOutput, CullingResults cull, HDCamera hdCamera)
		{
			if (hdCamera.frameSettings.litShaderMode != LitShaderMode.Deferred || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				prepassOutput.gbuffer.gBufferCount = 0;
				return;
			}
			GBufferPassData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<GBufferPassData>("GBuffer", out passData, ProfilingSampler.Get(HDProfileId.GBuffer));
			try
			{
				builder.AllowRendererListCulling(value: false);
				SetupGBufferTargets(renderGraph, hdCamera, sssBuffer, vtFeedbackBuffer, ref prepassOutput, passData.frameSettings = hdCamera.frameSettings, builder);
				GBufferPassData gBufferPassData = passData;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cull, hdCamera.camera, HDShaderPassNames.s_GBufferName, m_CurrentRendererConfigurationBakedLighting);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				gBufferPassData.rendererList = builder.UseRendererList(in input);
				passData.dBuffer = ReadDBuffer(prepassOutput.dbuffer, builder);
				builder.SetRenderFunc(delegate(GBufferPassData data, RenderGraphContext context)
				{
					ColorWriteMask value = (data.frameSettings.IsEnabled(FrameSettingsField.LightLayers) ? ColorWriteMask.Alpha : ColorWriteMask.All);
					context.cmd.SetGlobalInteger(HDShaderIDs._LightLayersMaskBuffer4, (int)value);
					context.cmd.SetGlobalInteger(HDShaderIDs._LightLayersMaskBuffer5, 15);
					BindDBufferGlobalData(in data.dBuffer, in context);
					ref FrameSettings frameSettings = ref data.frameSettings;
					RendererList rendererList = data.rendererList;
					DrawOpaqueRendererList(in context, in frameSettings, in rendererList);
				});
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private void ResolvePrepassBuffers(RenderGraph renderGraph, HDCamera hdCamera, ref PrepassOutput output)
		{
			if (hdCamera.msaaSamples == MSAASamples.None)
			{
				output.resolvedNormalBuffer = output.normalBuffer;
				output.resolvedDepthBuffer = output.depthBuffer;
				output.resolvedMotionVectorsBuffer = output.motionVectorsBuffer;
				return;
			}
			ResolvePrepassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolvePrepassData>("Resolve Prepass MSAA", out passData);
			try
			{
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32G32B32A32_SFloat,
					name = "DepthValuesBuffer"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				passData.needMotionVectors = hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors);
				passData.depthResolveMaterial = m_DepthResolveMaterial;
				passData.depthResolvePassIndex = SampleCountToPassIndex(hdCamera.msaaSamples);
				TextureHandle input2 = CreateDepthBuffer(renderGraph, clear: true, MSAASamples.None);
				output.resolvedDepthBuffer = renderGraphBuilder.UseDepthBuffer(in input2, DepthAccess.Write);
				output.depthValuesMSAA = renderGraphBuilder.UseColorBuffer(in input, 0);
				input2 = CreateNormalBuffer(renderGraph, hdCamera, MSAASamples.None);
				output.resolvedNormalBuffer = renderGraphBuilder.UseColorBuffer(in input2, 1);
				if (passData.needMotionVectors)
				{
					input2 = CreateMotionVectorBuffer(renderGraph, clear: false, MSAASamples.None);
					output.resolvedMotionVectorsBuffer = renderGraphBuilder.UseColorBuffer(in input2, 2);
				}
				else
				{
					output.resolvedMotionVectorsBuffer = TextureHandle.nullHandle;
				}
				passData.normalBufferMSAA = renderGraphBuilder.ReadTexture(in output.normalBuffer);
				passData.depthAsColorBufferMSAA = renderGraphBuilder.ReadTexture(in output.depthAsColor);
				if (passData.needMotionVectors)
				{
					passData.motionVectorBufferMSAA = renderGraphBuilder.ReadTexture(in output.motionVectorsBuffer);
				}
				renderGraphBuilder.SetRenderFunc(delegate(ResolvePrepassData data, RenderGraphContext context)
				{
					data.depthResolveMaterial.SetTexture(HDShaderIDs._NormalTextureMS, data.normalBufferMSAA);
					data.depthResolveMaterial.SetTexture(HDShaderIDs._DepthTextureMS, data.depthAsColorBufferMSAA);
					if (data.needMotionVectors)
					{
						data.depthResolveMaterial.SetTexture(HDShaderIDs._MotionVectorTextureMS, data.motionVectorBufferMSAA);
					}
					CoreUtils.SetKeyword(context.cmd, "_HAS_MOTION_VECTORS", data.needMotionVectors);
					context.cmd.DrawProcedural(Matrix4x4.identity, data.depthResolveMaterial, data.depthResolvePassIndex, MeshTopology.Triangles, 3, 1);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void CopyDepthBufferIfNeeded(RenderGraph renderGraph, HDCamera hdCamera, ref PrepassOutput output)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				output.depthPyramidTexture = renderGraph.defaultResources.blackTextureXR;
			}
			else
			{
				if (m_IsDepthBufferCopyValid)
				{
					return;
				}
				CopyDepthPassData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CopyDepthPassData>("Copy depth buffer", out passData, ProfilingSampler.Get(HDProfileId.CopyDepthBuffer));
				try
				{
					Vector2Int depthMipChainSize = hdCamera.depthMipChainSize;
					passData.inputDepth = renderGraphBuilder.ReadTexture(in output.resolvedDepthBuffer);
					CopyDepthPassData copyDepthPassData = passData;
					TextureDesc desc = new TextureDesc(depthMipChainSize.x, depthMipChainSize.y, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R32_SFloat,
						enableRandomWrite = true,
						name = "CameraDepthBufferMipChain"
					};
					TextureHandle input = renderGraph.CreateTexture(in desc);
					copyDepthPassData.outputDepth = renderGraphBuilder.WriteTexture(in input);
					passData.GPUCopy = m_GPUCopy;
					passData.width = hdCamera.actualWidth;
					passData.height = hdCamera.actualHeight;
					output.depthPyramidTexture = passData.outputDepth;
					renderGraphBuilder.SetRenderFunc(delegate(CopyDepthPassData data, RenderGraphContext context)
					{
						data.GPUCopy.SampleCopyChannel_xyzw2x(context.cmd, data.inputDepth, data.outputDepth, new RectInt(0, 0, data.width, data.height));
					});
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
				m_IsDepthBufferCopyValid = true;
			}
		}

		private void BuildCoarseStencilAndResolveIfNeeded(RenderGraph renderGraph, HDCamera hdCamera, bool resolveOnly, ref PrepassOutput output)
		{
			ResolveStencilPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolveStencilPassData>("Resolve Stencil", out passData, ProfilingSampler.Get(HDProfileId.BuildCoarseStencilAndResolveIfNeeded));
			try
			{
				bool msaaEnabled = hdCamera.msaaEnabled;
				int num = SampleCountToPassIndex(hdCamera.msaaSamples);
				passData.hdCamera = hdCamera;
				passData.resolveOnly = resolveOnly;
				passData.resolveIsNecessary = (GetFeatureVariantsEnabled(hdCamera.frameSettings) || hdCamera.IsSSREnabled() || hdCamera.IsSSREnabled(transparent: true)) && msaaEnabled;
				passData.resolveStencilCS = defaultResources.shaders.resolveStencilCS;
				if (passData.resolveIsNecessary && resolveOnly)
				{
					passData.resolveKernel = num - 1 + 7;
				}
				else
				{
					passData.resolveKernel = (passData.resolveIsNecessary ? (num + 3) : num);
				}
				passData.inputDepth = renderGraphBuilder.ReadTexture(in output.depthBuffer);
				ResolveStencilPassData resolveStencilPassData = passData;
				ComputeBufferDesc desc = new ComputeBufferDesc(HDUtils.DivRoundUp(m_MaxCameraWidth, 8) * HDUtils.DivRoundUp(m_MaxCameraHeight, 8) * m_MaxViewCount, 4)
				{
					name = "CoarseStencilBuffer"
				};
				ComputeBufferHandle input = renderGraph.CreateComputeBuffer(in desc);
				resolveStencilPassData.coarseStencilBuffer = renderGraphBuilder.WriteComputeBuffer(in input);
				if (passData.resolveIsNecessary)
				{
					ResolveStencilPassData resolveStencilPassData2 = passData;
					TextureDesc desc2 = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R8G8_UInt,
						enableRandomWrite = true,
						name = "StencilBufferResolved"
					};
					TextureHandle input2 = renderGraph.CreateTexture(in desc2);
					resolveStencilPassData2.resolvedStencil = renderGraphBuilder.WriteTexture(in input2);
				}
				else
				{
					passData.resolvedStencil = output.stencilBuffer;
				}
				renderGraphBuilder.SetRenderFunc(delegate(ResolveStencilPassData data, RenderGraphContext context)
				{
					if (!data.resolveOnly || data.resolveIsNecessary)
					{
						ComputeShader resolveStencilCS = data.resolveStencilCS;
						context.cmd.SetComputeBufferParam(resolveStencilCS, data.resolveKernel, HDShaderIDs._CoarseStencilBuffer, data.coarseStencilBuffer);
						context.cmd.SetComputeTextureParam(resolveStencilCS, data.resolveKernel, HDShaderIDs._StencilTexture, data.inputDepth, 0, RenderTextureSubElement.Stencil);
						if (data.resolveIsNecessary)
						{
							context.cmd.SetComputeTextureParam(resolveStencilCS, data.resolveKernel, HDShaderIDs._OutputStencilBuffer, data.resolvedStencil);
						}
						int threadGroupsX = HDUtils.DivRoundUp(data.hdCamera.actualWidth, 8);
						int threadGroupsY = HDUtils.DivRoundUp(data.hdCamera.actualHeight, 8);
						context.cmd.DispatchCompute(resolveStencilCS, data.resolveKernel, threadGroupsX, threadGroupsY, data.hdCamera.viewCount);
					}
				});
				if (msaaEnabled)
				{
					output.stencilBuffer = passData.resolvedStencil;
				}
				output.coarseStencilBuffer = passData.coarseStencilBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void SetupDBufferTargets(RenderGraph renderGraph, bool use4RTs, ref PrepassOutput output, RenderGraphBuilder builder)
		{
			Decal.GetMaterialDBufferDescription(out var RTFormat);
			output.dbuffer.dBufferCount = (use4RTs ? 4 : 3);
			for (int i = 0; i < output.dbuffer.dBufferCount; i++)
			{
				TextureHandle[] mrt = output.dbuffer.mrt;
				int num = i;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = RTFormat[i],
					name = s_DBufferNames[i],
					clearBuffer = true,
					clearColor = s_DBufferClearColors[i]
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				mrt[num] = builder.UseColorBuffer(in input, i);
			}
			builder.UseDepthBuffer(in output.resolvedDepthBuffer, DepthAccess.Write);
		}

		private static DBufferOutput ReadDBuffer(DBufferOutput dBufferOutput, RenderGraphBuilder builder)
		{
			for (int i = 0; i < dBufferOutput.dBufferCount; i++)
			{
				dBufferOutput.mrt[i] = builder.ReadTexture(in dBufferOutput.mrt[i]);
			}
			return dBufferOutput;
		}

		private void RenderDBuffer(RenderGraph renderGraph, HDCamera hdCamera, ref PrepassOutput output, CullingResults cullingResults)
		{
			bool perChannelMask = m_Asset.currentPlatformRenderPipelineSettings.decalSettings.perChannelMask;
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				TextureHandle textureHandle = (output.depthPyramidTexture = renderGraph.defaultResources.blackTextureXR);
				output.dbuffer.dBufferCount = (perChannelMask ? 4 : 3);
				for (int i = 0; i < output.dbuffer.dBufferCount; i++)
				{
					output.dbuffer.mrt[i] = textureHandle;
				}
				return;
			}
			bool flag = SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation4 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation5 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.PlayStation5NGGC || SystemInfo.graphicsDeviceType == GraphicsDeviceType.XboxOne || SystemInfo.graphicsDeviceType == GraphicsDeviceType.XboxOneD3D12 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.GameCoreXboxOne || SystemInfo.graphicsDeviceType == GraphicsDeviceType.GameCoreXboxSeries;
			if (!flag)
			{
				CopyDepthBufferIfNeeded(renderGraph, hdCamera, ref output);
			}
			if (hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred && !hdCamera.frameSettings.IsEnabled(FrameSettingsField.DepthPrepassWithDeferredRendering))
			{
				m_IsDepthBufferCopyValid = false;
			}
			RenderDBufferPassData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<RenderDBufferPassData>("DBufferRender", out passData, ProfilingSampler.Get(HDProfileId.DBufferRender));
			try
			{
				builder.AllowRendererListCulling(value: false);
				RenderDBufferPassData renderDBufferPassData = passData;
				RendererListDesc desc = new RendererListDesc(m_MeshDecalsPassNames, cullingResults, hdCamera.camera)
				{
					sortingCriteria = (SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.OptimizeStateChanges | SortingCriteria.CanvasOrder | SortingCriteria.RendererPriority),
					rendererConfiguration = PerObjectData.None,
					renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque
				};
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				renderDBufferPassData.meshDecalsRendererList = builder.UseRendererList(in input);
				RenderDBufferPassData renderDBufferPassData2 = passData;
				desc = new RendererListDesc(m_VfxDecalsPassNames, cullingResults, hdCamera.camera)
				{
					sortingCriteria = (SortingCriteria.SortingLayer | SortingCriteria.RenderQueue | SortingCriteria.CanvasOrder),
					rendererConfiguration = PerObjectData.None,
					renderQueueRange = HDRenderQueue.k_RenderQueue_AllOpaque
				};
				input = renderGraph.CreateRendererList(in desc);
				renderDBufferPassData2.vfxDecalsRendererList = builder.UseRendererList(in input);
				SetupDBufferTargets(renderGraph, perChannelMask, ref output, builder);
				passData.decalBuffer = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers) ? builder.ReadTexture(in output.renderingLayersBuffer) : renderGraph.defaultResources.blackTextureXR);
				passData.depthTexture = (flag ? builder.ReadTexture(in output.resolvedDepthBuffer) : builder.ReadTexture(in output.depthPyramidTexture));
				builder.SetRenderFunc(delegate(RenderDBufferPassData data, RenderGraphContext context)
				{
					context.cmd.SetGlobalTexture(HDShaderIDs._DecalPrepassTexture, data.decalBuffer);
					context.cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, data.depthTexture);
					CoreUtils.DrawRendererList(context.renderContext, context.cmd, data.meshDecalsRendererList);
					CoreUtils.DrawRendererList(context.renderContext, context.cmd, data.vfxDecalsRendererList);
					DecalSystem.instance.RenderIntoDBuffer(context.cmd);
					context.cmd.ClearRandomWriteTargets();
				});
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private void DecalNormalPatch(RenderGraph renderGraph, HDCamera hdCamera, ref PrepassOutput output)
		{
			if ((SystemInfo.graphicsDeviceType == GraphicsDeviceType.Metal && SystemInfo.graphicsDeviceName.Contains("Intel")) || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) || hdCamera.msaaSamples != MSAASamples.None || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return;
			}
			DBufferNormalPatchData passData;
			using RenderGraphBuilder builder = renderGraph.AddRenderPass<DBufferNormalPatchData>("DBuffer Normal (forward)", out passData, ProfilingSampler.Get(HDProfileId.DBufferNormal));
			passData.dBufferCount = (m_Asset.currentPlatformRenderPipelineSettings.decalSettings.perChannelMask ? 4 : 3);
			passData.decalNormalBufferMaterial = m_DecalNormalBufferMaterial;
			switch (hdCamera.frameSettings.litShaderMode)
			{
			case LitShaderMode.Forward:
				passData.stencilMask = 16;
				passData.stencilRef = 16;
				break;
			case LitShaderMode.Deferred:
				passData.stencilMask = 18;
				passData.stencilRef = 16;
				break;
			default:
				throw new ArgumentOutOfRangeException("Unknown ShaderLitMode");
			}
			passData.dBuffer = ReadDBuffer(output.dbuffer, builder);
			passData.normalBuffer = builder.WriteTexture(in output.resolvedNormalBuffer);
			passData.depthStencilBuffer = builder.ReadTexture(in output.resolvedDepthBuffer);
			builder.SetRenderFunc(delegate(DBufferNormalPatchData data, RenderGraphContext ctx)
			{
				data.decalNormalBufferMaterial.SetInt(HDShaderIDs._DecalNormalBufferStencilReadMask, data.stencilMask);
				data.decalNormalBufferMaterial.SetInt(HDShaderIDs._DecalNormalBufferStencilRef, data.stencilRef);
				for (int i = 0; i < data.dBufferCount; i++)
				{
					data.decalNormalBufferMaterial.SetTexture(HDShaderIDs._DBufferTexture[i], data.dBuffer.mrt[i]);
				}
				CoreUtils.SetRenderTarget(ctx.cmd, data.depthStencilBuffer);
				ctx.cmd.SetRandomWriteTarget(1, data.normalBuffer);
				ctx.cmd.DrawProcedural(Matrix4x4.identity, data.decalNormalBufferMaterial, 0, MeshTopology.Triangles, 3, 1);
				ctx.cmd.ClearRandomWriteTargets();
			});
		}

		private void DownsampleDepthForLowResTransparency(RenderGraph renderGraph, HDCamera hdCamera, bool computeMip1OfPyramid, ref PrepassOutput output)
		{
			CopyDepthBufferIfNeeded(renderGraph, hdCamera, ref output);
			DownsampleDepthForLowResPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DownsampleDepthForLowResPassData>("Downsample Depth Buffer for Low Res Transparency", out passData, ProfilingSampler.Get(HDProfileId.DownsampleDepth));
			try
			{
				passData.useGatherDownsample = false;
				if (hdCamera.isLowResScaleHalf)
				{
					if (m_Asset.currentPlatformRenderPipelineSettings.lowresTransparentSettings.checkerboardDepthBuffer)
					{
						m_DownsampleDepthMaterialHalfresCheckerboard.EnableKeyword("CHECKERBOARD_DOWNSAMPLE");
					}
					else
					{
						m_DownsampleDepthMaterialHalfresCheckerboard.DisableKeyword("CHECKERBOARD_DOWNSAMPLE");
					}
					if (computeMip1OfPyramid)
					{
						passData.mip0Offset = hdCamera.depthBufferMipChainInfo.mipLevelOffsets[1];
						m_DownsampleDepthMaterialHalfresCheckerboard.EnableKeyword("OUTPUT_FIRST_MIP_OF_MIPCHAIN");
					}
					passData.downsampleDepthMaterial = m_DownsampleDepthMaterialHalfresCheckerboard;
				}
				else
				{
					m_DownsampleDepthMaterialGather.EnableKeyword("GATHER_DOWNSAMPLE");
					passData.downsampleDepthMaterial = m_DownsampleDepthMaterialGather;
					passData.useGatherDownsample = true;
				}
				passData.computesMip1OfAtlas = computeMip1OfPyramid;
				passData.downsampleScale = hdCamera.lowResScale;
				passData.sourceWidth = hdCamera.actualWidth;
				passData.sourceHeight = hdCamera.actualHeight;
				passData.depthTexture = renderGraphBuilder.ReadTexture(in output.depthPyramidTexture);
				if (computeMip1OfPyramid)
				{
					passData.depthTexture = renderGraphBuilder.WriteTexture(in passData.depthTexture);
				}
				DownsampleDepthForLowResPassData downsampleDepthForLowResPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one * hdCamera.lowResScale, dynamicResolution: true, xrReady: true)
				{
					depthBufferBits = DepthBits.Depth32,
					name = "LowResDepthBuffer"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				downsampleDepthForLowResPassData.downsampledDepthBuffer = renderGraphBuilder.UseDepthBuffer(in input, DepthAccess.Write);
				renderGraphBuilder.SetRenderFunc(delegate(DownsampleDepthForLowResPassData data, RenderGraphContext context)
				{
					if (data.computesMip1OfAtlas)
					{
						data.downsampleDepthMaterial.SetVector(HDShaderIDs._DstOffset, new Vector4(data.mip0Offset.x, data.mip0Offset.y, 0f, 0f));
						context.cmd.SetRandomWriteTarget(1, data.depthTexture);
					}
					if (data.useGatherDownsample)
					{
						float num = 1f / data.downsampleScale;
						RenderTexture renderTexture = data.depthTexture;
						RenderTexture renderTexture2 = data.downsampledDepthBuffer;
						float x = (float)renderTexture2.width / (float)renderTexture.width * num;
						float y = (float)renderTexture2.height / (float)renderTexture.height * num;
						data.downsampleDepthMaterial.SetVector(HDShaderIDs._ScaleBias, new Vector4(x, y, 0f, 0f));
					}
					float width = data.sourceWidth * data.downsampleScale;
					float height = data.sourceHeight * data.downsampleScale;
					Rect viewport = new Rect(0f, 0f, width, height);
					context.cmd.SetViewport(viewport);
					context.cmd.DrawProcedural(Matrix4x4.identity, data.downsampleDepthMaterial, 0, MeshTopology.Triangles, 3, 1, null);
					if (data.computesMip1OfAtlas)
					{
						context.cmd.ClearRandomWriteTargets();
					}
				});
				output.downsampledDepthBuffer = passData.downsampledDepthBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void GenerateDepthPyramid(RenderGraph renderGraph, HDCamera hdCamera, bool mip0AlreadyComputed, ref PrepassOutput output)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				output.depthPyramidTexture = renderGraph.defaultResources.blackTextureXR;
				return;
			}
			CopyDepthBufferIfNeeded(renderGraph, hdCamera, ref output);
			GenerateDepthPyramidPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GenerateDepthPyramidPassData>("Generate Depth Buffer MIP Chain", out passData, ProfilingSampler.Get(HDProfileId.DepthPyramid));
			passData.depthTexture = renderGraphBuilder.WriteTexture(in output.depthPyramidTexture);
			passData.mipInfo = hdCamera.depthBufferMipChainInfo;
			passData.mipGenerator = m_MipGenerator;
			passData.mip0AlreadyComputed = mip0AlreadyComputed;
			renderGraphBuilder.SetRenderFunc(delegate(GenerateDepthPyramidPassData data, RenderGraphContext context)
			{
				data.mipGenerator.RenderMinDepthPyramid(context.cmd, data.depthTexture, data.mipInfo, data.mip0AlreadyComputed);
			});
			output.depthPyramidTexture = passData.depthTexture;
		}

		private void RenderCameraMotionVectors(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle motionVectorsBuffer)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.MotionVectors))
			{
				return;
			}
			CameraMotionVectorsPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CameraMotionVectorsPassData>("Camera Motion Vectors Rendering", out passData, ProfilingSampler.Get(HDProfileId.CameraMotionVectors));
			hdCamera.camera.depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			passData.cameraMotionVectorsMaterial = m_CameraMotionVectorsMaterial;
			passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
			passData.motionVectorsBuffer = renderGraphBuilder.WriteTexture(in motionVectorsBuffer);
			renderGraphBuilder.SetRenderFunc(delegate(CameraMotionVectorsPassData data, RenderGraphContext context)
			{
				data.cameraMotionVectorsMaterial.SetInt(HDShaderIDs._StencilMask, 32);
				data.cameraMotionVectorsMaterial.SetInt(HDShaderIDs._StencilRef, 32);
				HDUtils.DrawFullScreen(context.cmd, data.cameraMotionVectorsMaterial, data.motionVectorsBuffer, data.depthBuffer);
			});
		}

		private void RecordRenderGraph(RenderRequest renderRequest, AOVRequestData aovRequest, List<RTHandle> aovBuffers, List<RTHandle> aovCustomPassBuffers, ScriptableRenderContext renderContext, CommandBuffer commandBuffer)
		{
			using (new ProfilingScope(commandBuffer, ProfilingSampler.Get(HDProfileId.RecordRenderGraph)))
			{
				HDCamera hdCamera = renderRequest.hdCamera;
				_ = hdCamera.camera;
				CullingResults cullingResults = renderRequest.cullingResults.cullingResults;
				CullingResults cullingResults2 = renderRequest.cullingResults.customPassCullingResults ?? cullingResults;
				bool msaaEnabled = hdCamera.msaaEnabled;
				RenderRequest.Target target = renderRequest.target;
				SetCurrentResolutionGroup(m_RenderGraph, hdCamera, ResolutionGroup.BeforeDynamicResUpscale);
				if (!m_CurrentDebugDisplaySettings.IsMatcapViewEnabled(hdCamera))
				{
					m_SkyManager.UpdateEnvironment(m_RenderGraph, hdCamera, GetMainLight(), m_CurrentDebugDisplaySettings);
				}
				hdCamera.depthBufferMipChainInfo.ComputePackedMipChainInfo(RTHandles.rtHandleProperties.currentRenderTargetSize);
				commandBuffer.SetGlobalBuffer(HDShaderIDs._DepthPyramidMipLevelOffsets, hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer));
				GraphicsFormat format = GraphicsFormat.R16G16B16A16_SFloat;
				if (aovRequest.isValid && aovRequest.overrideRenderFormat)
				{
					aovRequest.OverrideBufferFormatForAOVs(ref format, aovBuffers);
					m_ShouldOverrideColorBufferFormat = true;
					m_AOVGraphicsFormat = (GraphicsFormat)m_Asset.currentPlatformRenderPipelineSettings.colorBufferFormat;
					aovRequest.OverrideBufferFormatForAOVs(ref m_AOVGraphicsFormat, aovBuffers);
				}
				else
				{
					m_ShouldOverrideColorBufferFormat = false;
				}
				UpdateParentExposure(m_RenderGraph, hdCamera);
				TextureHandle textureHandle = m_RenderGraph.ImportBackbuffer(target.id);
				TextureHandle textureHandle2 = CreateColorBuffer(m_RenderGraph, hdCamera, msaaEnabled, fallbackToBlack: true);
				m_NonMSAAColorBuffer = CreateColorBuffer(m_RenderGraph, hdCamera, msaa: false);
				TextureHandle textureHandle3 = m_RenderGraph.ImportTexture(hdCamera.GetCurrentFrameRT(0));
				TextureHandle rayCountTexture = RayCountManager.CreateRayCountTexture(m_RenderGraph);
				TextureHandle nullHandle = TextureHandle.nullHandle;
				EvaluateRTASDebugView(m_RenderGraph, hdCamera);
				LightingBuffers lightingBuffers = default(LightingBuffers);
				lightingBuffers.diffuseLightingBuffer = CreateDiffuseLightingBuffer(m_RenderGraph, hdCamera.msaaSamples);
				lightingBuffers.sssBuffer = CreateSSSBuffer(m_RenderGraph, hdCamera, hdCamera.msaaSamples);
				PrepassOutput prepassOutput = RenderPrepass(m_RenderGraph, textureHandle2, lightingBuffers.sssBuffer, nullHandle, cullingResults, cullingResults2, hdCamera, aovRequest, aovBuffers);
				ShadowResult result = default(ShadowResult);
				BuildGPULightListOutput lightLists = default(BuildGPULightListOutput);
				TextureHandle textureHandle4 = m_RenderGraph.defaultResources.blackTextureXR;
				TextureHandle sunOcclusionTexture = m_RenderGraph.defaultResources.whiteTexture;
				PathTracing component = hdCamera.volumeStack.GetComponent<PathTracing>();
				if (m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled() && m_CurrentDebugDisplaySettings.IsFullScreenDebugPassEnabled())
				{
					StartXRSinglePass(m_RenderGraph, hdCamera);
					RenderFullScreenDebug(m_RenderGraph, textureHandle2, prepassOutput.depthBuffer, cullingResults, hdCamera);
				}
				else if (m_CurrentDebugDisplaySettings.IsDebugMaterialDisplayEnabled() || m_CurrentDebugDisplaySettings.IsMaterialValidationEnabled() || CoreUtils.IsSceneLightingDisabled(hdCamera.camera))
				{
					lightLists = BuildGPULightList(m_RenderGraph, hdCamera, m_TileAndClusterData, m_TotalLightCount, ref m_ShaderVariablesLightListCB, prepassOutput.depthBuffer, prepassOutput.stencilBuffer, prepassOutput.gbuffer);
					if (m_CurrentDebugDisplaySettings.data.materialDebugSettings.debugViewMaterialCommonValue == MaterialSharedProperty.Alpha)
					{
						RenderShadows(m_RenderGraph, hdCamera, cullingResults, ref result);
					}
					else
					{
						HDShadowManager.BindDefaultShadowGlobalResources(m_RenderGraph);
					}
					StartXRSinglePass(m_RenderGraph, hdCamera);
					textureHandle2 = RenderDebugViewMaterial(m_RenderGraph, cullingResults, hdCamera, lightLists, prepassOutput.dbuffer, prepassOutput.gbuffer, prepassOutput.depthBuffer, nullHandle);
					textureHandle2 = ResolveMSAAColor(m_RenderGraph, hdCamera, textureHandle2);
				}
				else if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && component.enable.value && hdCamera.camera.cameraType != CameraType.Preview && GetRayTracingState() && GetRayTracingClusterState())
				{
					if (hdCamera.viewCount == 1)
					{
						textureHandle2 = RenderPathTracing(m_RenderGraph, hdCamera, textureHandle2);
					}
					else
					{
						Debug.LogWarning("Path Tracing is not supported with XR single-pass rendering.");
					}
				}
				else
				{
					lightLists = BuildGPULightList(m_RenderGraph, hdCamera, m_TileAndClusterData, m_TotalLightCount, ref m_ShaderVariablesLightListCB, prepassOutput.depthBuffer, prepassOutput.stencilBuffer, prepassOutput.gbuffer);
					TextureHandle textureHandle5 = EvaluateHistoryValidationBuffer(m_RenderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.resolvedNormalBuffer, prepassOutput.resolvedMotionVectorsBuffer);
					lightingBuffers.ambientOcclusionBuffer = RenderAmbientOcclusion(m_RenderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.depthPyramidTexture, prepassOutput.resolvedNormalBuffer, prepassOutput.resolvedMotionVectorsBuffer, textureHandle5, in hdCamera.depthBufferMipChainInfo, m_ShaderVariablesRayTracingCB, rayCountTexture);
					lightingBuffers.contactShadowsBuffer = RenderContactShadows(m_RenderGraph, hdCamera, msaaEnabled ? prepassOutput.depthValuesMSAA : prepassOutput.depthPyramidTexture, in lightLists, hdCamera.depthBufferMipChainInfo.mipLevelOffsets[1].y);
					TextureHandle densityBuffer = ClearAndHeightFogVoxelizationPass(m_RenderGraph, hdCamera);
					RenderShadows(m_RenderGraph, hdCamera, cullingResults, ref result);
					StartXRSinglePass(m_RenderGraph, hdCamera);
					TextureHandle clearCoatMask = ((hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred) ? prepassOutput.gbuffer.mrt[2] : m_RenderGraph.defaultResources.blackTextureXR);
					lightingBuffers.ssrLightingBuffer = RenderSSR(m_RenderGraph, hdCamera, ref prepassOutput, clearCoatMask, rayCountTexture, m_SkyManager.GetSkyReflection(hdCamera), transparent: false);
					lightingBuffers.ssgiLightingBuffer = RenderScreenSpaceIndirectDiffuse(hdCamera, in prepassOutput, rayCountTexture, textureHandle5, lightLists.lightList);
					if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && GetRayTracingClusterState())
					{
						RequestLightCluster().EvaluateClusterDebugView(m_RenderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.depthPyramidTexture);
					}
					lightingBuffers.screenspaceShadowBuffer = RenderScreenSpaceShadows(m_RenderGraph, hdCamera, prepassOutput, prepassOutput.depthBuffer, prepassOutput.normalBuffer, prepassOutput.motionVectorsBuffer, textureHandle5, rayCountTexture);
					TextureHandle textureHandle6 = GenerateMaxZPass(m_RenderGraph, hdCamera, prepassOutput.depthPyramidTexture, hdCamera.depthBufferMipChainInfo);
					densityBuffer = FogVolumeVoxelizationPass(m_RenderGraph, hdCamera, densityBuffer, m_VisibleVolumeBoundsBuffer);
					TextureHandle volumetricLighting = VolumetricLightingPass(m_RenderGraph, hdCamera, prepassOutput.depthPyramidTexture, densityBuffer, textureHandle6, lightLists.bigTileLightList, result);
					RenderDeferredLighting(m_RenderGraph, hdCamera, textureHandle2, prepassOutput.depthBuffer, prepassOutput.depthPyramidTexture, in lightingBuffers, in prepassOutput.gbuffer, in result, in lightLists);
					ApplyCameraMipBias(hdCamera);
					RenderForwardOpaque(m_RenderGraph, hdCamera, textureHandle2, in lightingBuffers, in lightLists, in prepassOutput, nullHandle, result, cullingResults);
					ResetCameraMipBias(hdCamera);
					if (aovRequest.isValid)
					{
						aovRequest.PushCameraTexture(m_RenderGraph, AOVBuffers.Normals, hdCamera, prepassOutput.resolvedNormalBuffer, aovBuffers);
					}
					RenderSubsurfaceScattering(m_RenderGraph, hdCamera, textureHandle2, textureHandle5, ref lightingBuffers, ref prepassOutput);
					RenderSky(m_RenderGraph, hdCamera, textureHandle2, volumetricLighting, prepassOutput.depthBuffer, msaaEnabled ? prepassOutput.depthAsColor : prepassOutput.depthPyramidTexture);
					RenderCustomPass(m_RenderGraph, hdCamera, textureHandle2, in prepassOutput, cullingResults2, cullingResults, CustomPassInjectionPoint.AfterOpaqueAndSky, aovRequest, aovCustomPassBuffers);
					DoUserAfterOpaqueAndSky(m_RenderGraph, hdCamera, textureHandle2, prepassOutput.resolvedDepthBuffer, prepassOutput.resolvedNormalBuffer, prepassOutput.resolvedMotionVectorsBuffer);
					sunOcclusionTexture = RenderVolumetricClouds(m_RenderGraph, hdCamera, textureHandle2, prepassOutput.depthPyramidTexture, prepassOutput.motionVectorsBuffer, volumetricLighting, textureHandle6);
					SendGeometryGraphicsBuffers(m_RenderGraph, prepassOutput.normalBuffer, prepassOutput.depthPyramidTexture, hdCamera);
					ClearStencilBuffer(m_RenderGraph, hdCamera, prepassOutput.depthBuffer);
					textureHandle2 = RenderTransparency(m_RenderGraph, hdCamera, textureHandle2, prepassOutput.resolvedNormalBuffer, nullHandle, textureHandle3, volumetricLighting, rayCountTexture, m_SkyManager.GetSkyReflection(hdCamera), in lightLists, ref prepassOutput, result, cullingResults, cullingResults2, aovRequest, aovCustomPassBuffers);
					textureHandle4 = RenderTransparentUI(m_RenderGraph, hdCamera, prepassOutput.depthBuffer);
					if (NeedMotionVectorForTransparent(hdCamera.frameSettings))
					{
						prepassOutput.resolvedMotionVectorsBuffer = ResolveMotionVector(m_RenderGraph, hdCamera, prepassOutput.motionVectorsBuffer);
					}
					if (m_Asset.currentPlatformRenderPipelineSettings.supportMotionVectors)
					{
						PushFullScreenDebugTexture(m_RenderGraph, prepassOutput.resolvedMotionVectorsBuffer, FullScreenDebugMode.MotionVectors, format);
					}
					if (aovRequest.isValid)
					{
						aovRequest.PushCameraTexture(m_RenderGraph, AOVBuffers.DepthStencil, hdCamera, prepassOutput.resolvedDepthBuffer, aovBuffers);
						if (m_Asset.currentPlatformRenderPipelineSettings.supportMotionVectors)
						{
							aovRequest.PushCameraTexture(m_RenderGraph, AOVBuffers.MotionVectors, hdCamera, prepassOutput.resolvedMotionVectorsBuffer, aovBuffers);
						}
					}
					RenderGraph renderGraph = m_RenderGraph;
					RendererListDesc desc = CreateTransparentRendererListDesc(cullingResults, hdCamera.camera, HDShaderPassNames.s_DistortionVectorsName);
					RendererListHandle rendererListHandle = renderGraph.CreateRendererList(in desc);
					if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Distortion) && hdCamera.frameSettings.IsEnabled(FrameSettingsField.RoughDistortion))
					{
						RenderGraph renderGraph2 = m_RenderGraph;
						TextureDesc desc2 = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
						{
							colorFormat = GetColorBufferFormat(),
							enableRandomWrite = true,
							useMipMap = true,
							autoGenerateMips = false,
							name = "DistortionColorBufferMipChain"
						};
						TextureHandle textureHandle7 = renderGraph2.CreateTexture(in desc2);
						GenerateColorPyramid(m_RenderGraph, hdCamera, textureHandle2, textureHandle7, FullScreenDebugMode.PreRefractionColorPyramid, rendererListHandle);
						textureHandle3 = textureHandle7;
					}
					using (new RenderGraphProfilingScope(m_RenderGraph, ProfilingSampler.Get(HDProfileId.Distortion)))
					{
						TextureHandle distortionBuffer = AccumulateDistortion(m_RenderGraph, hdCamera, prepassOutput.resolvedDepthBuffer, rendererListHandle);
						RenderDistortion(m_RenderGraph, hdCamera, textureHandle2, prepassOutput.resolvedDepthBuffer, textureHandle3, distortionBuffer, rendererListHandle);
					}
					PushFullScreenDebugTexture(m_RenderGraph, textureHandle2, FullScreenDebugMode.NanTracker, format);
					PushFullScreenDebugTexture(m_RenderGraph, textureHandle2, FullScreenDebugMode.WorldSpacePosition, format);
					PushFullScreenLightingDebugTexture(m_RenderGraph, textureHandle2, format);
					if ((!m_PostProcessEnabled || !m_DepthOfField.IsActive()) && m_SubFrameManager.isRecording && m_SubFrameManager.subFrameCount > 1)
					{
						RenderAccumulation(m_RenderGraph, hdCamera, textureHandle2, textureHandle2, null, needExposure: false);
					}
					RenderGizmos(m_RenderGraph, hdCamera, GizmoSubset.PreImageEffects);
				}
				TextureHandle colorPickerDebugTexture = PushColorPickerDebugTexture(m_RenderGraph, textureHandle2);
				RenderCustomPass(m_RenderGraph, hdCamera, textureHandle2, in prepassOutput, cullingResults2, cullingResults, CustomPassInjectionPoint.BeforePostProcess, aovRequest, aovCustomPassBuffers);
				if (aovRequest.isValid)
				{
					aovRequest.PushCameraTexture(m_RenderGraph, AOVBuffers.Color, hdCamera, textureHandle2, aovBuffers);
				}
				bool flag = HDUtils.PostProcessIsFinalPass(hdCamera, aovRequest);
				TextureHandle textureHandle8 = RenderAfterPostProcessObjects(m_RenderGraph, hdCamera, component, cullingResults, in prepassOutput);
				CubemapFace cubemapFace = (flag ? target.face : CubemapFace.Unknown);
				TextureHandle textureHandle9 = RenderPostProcess(m_RenderGraph, in prepassOutput, textureHandle2, textureHandle, textureHandle4, textureHandle8, sunOcclusionTexture, cullingResults, hdCamera, cubemapFace, flag);
				TextureHandle xyBufferMapping = GenerateDebugHDRxyMapping(m_RenderGraph, hdCamera, textureHandle9);
				GenerateDebugImageHistogram(m_RenderGraph, hdCamera, textureHandle9);
				PushFullScreenExposureDebugTexture(m_RenderGraph, textureHandle9, format);
				PushFullScreenHDRDebugTexture(m_RenderGraph, textureHandle9, format);
				ResetCameraSizeForAfterPostProcess(m_RenderGraph, hdCamera, commandBuffer);
				RenderCustomPass(m_RenderGraph, hdCamera, textureHandle9, in prepassOutput, cullingResults2, cullingResults, CustomPassInjectionPoint.AfterPostProcess, aovRequest, aovCustomPassBuffers);
				CopyXRDepth(m_RenderGraph, hdCamera, prepassOutput.resolvedDepthBuffer, textureHandle);
				if (!flag)
				{
					hdCamera.ExecuteCaptureActions(m_RenderGraph, textureHandle9);
					textureHandle9 = RenderDebug(m_RenderGraph, hdCamera, textureHandle9, prepassOutput.resolvedDepthBuffer, prepassOutput.depthPyramidTexture, colorPickerDebugTexture, rayCountTexture, xyBufferMapping, in lightLists, in result, cullingResults, format);
					StopXRSinglePass(m_RenderGraph, hdCamera);
					for (int i = 0; i < hdCamera.viewCount; i++)
					{
						BlitFinalCameraTexture(m_RenderGraph, hdCamera, textureHandle9, textureHandle, textureHandle4, textureHandle8, i, HDROutputActiveForCameraType(hdCamera.camera.cameraType), target.face);
					}
					if (aovRequest.isValid)
					{
						aovRequest.PushCameraTexture(m_RenderGraph, AOVBuffers.Output, hdCamera, textureHandle9, aovBuffers);
					}
				}
				for (int j = 0; j < hdCamera.viewCount; j++)
				{
					if (target.targetDepth != null)
					{
						BlitFinalCameraTexture(m_RenderGraph, hdCamera, prepassOutput.resolvedDepthBuffer, m_RenderGraph.ImportTexture(target.targetDepth), textureHandle4, textureHandle8, j, outputsToHDR: false, target.face);
					}
				}
				SendColorGraphicsBuffer(m_RenderGraph, hdCamera);
				SetFinalTarget(m_RenderGraph, hdCamera, prepassOutput.resolvedDepthBuffer, textureHandle, target.face);
				RenderWireOverlay(m_RenderGraph, hdCamera, textureHandle);
				RenderGizmos(m_RenderGraph, hdCamera, GizmoSubset.PostImageEffects);
				RenderScreenSpaceOverlayUI(m_RenderGraph, hdCamera, textureHandle);
			}
		}

		private void ExecuteWithRenderGraph(RenderRequest renderRequest, AOVRequestData aovRequest, List<RTHandle> aovBuffers, List<RTHandle> aovCustomPassBuffers, ScriptableRenderContext renderContext, CommandBuffer commandBuffer)
		{
			RenderGraph renderGraph = m_RenderGraph;
			RenderGraphParameters parameters = new RenderGraphParameters
			{
				executionName = renderRequest.hdCamera.name,
				currentFrameIndex = m_FrameCount,
				rendererListCulling = m_GlobalSettings.rendererListCulling,
				scriptableRenderContext = renderContext,
				commandBuffer = commandBuffer
			};
			using (renderGraph.RecordAndExecute(in parameters))
			{
				RecordRenderGraph(renderRequest, aovRequest, aovBuffers, aovCustomPassBuffers, renderContext, commandBuffer);
			}
			if (aovRequest.isValid)
			{
				using (new ProfilingScope(commandBuffer, ProfilingSampler.Get(HDProfileId.AOVExecute)))
				{
					aovRequest.Execute(commandBuffer, aovBuffers, aovCustomPassBuffers, RenderOutputProperties.From(renderRequest.hdCamera));
				}
			}
		}

		private void BlitFinalCameraTexture(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle source, TextureHandle destination, TextureHandle uiTexture, TextureHandle afterPostProcessTexture, int viewIndex, bool outputsToHDR, CubemapFace cubemapFace)
		{
			FinalBlitPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<FinalBlitPassData>("Final Blit (Dev Build Only)", out passData);
			if (hdCamera.xr.enabled)
			{
				passData.viewport = hdCamera.xr.GetViewport(viewIndex);
				passData.srcTexArraySlice = viewIndex;
				passData.dstTexArraySlice = hdCamera.xr.GetTextureArraySlice(viewIndex);
			}
			else
			{
				passData.viewport = hdCamera.finalViewport;
				passData.srcTexArraySlice = -1;
				passData.dstTexArraySlice = -1;
			}
			passData.flip = hdCamera.flipYMode == HDAdditionalCameraData.FlipYMode.ForceFlipY || hdCamera.isMainGameView;
			passData.blitMaterial = HDUtils.GetBlitMaterial(TextureXR.useTexArray ? TextureDimension.Tex2DArray : TextureDimension.Tex2D, passData.srcTexArraySlice >= 0);
			passData.source = renderGraphBuilder.ReadTexture(in source);
			passData.afterPostProcessTexture = renderGraphBuilder.ReadTexture(in afterPostProcessTexture);
			passData.destination = renderGraphBuilder.WriteTexture(in destination);
			passData.applyAfterPP = false;
			passData.cubemapFace = cubemapFace;
			if (outputsToHDR)
			{
				passData.blitMaterial = m_FinalBlitWithOETF;
				GetHDROutputParameters(m_Tonemapping, out passData.hdrOutputParmeters, out var _);
				passData.uiTexture = renderGraphBuilder.ReadTexture(in uiTexture);
				passData.applyAfterPP = hdCamera.frameSettings.IsEnabled(FrameSettingsField.AfterPostprocess) && !NeedHDRDebugMode(m_CurrentDebugDisplaySettings);
			}
			else
			{
				passData.hdrOutputParmeters = new Vector4(-1f, -1f, -1f, -1f);
			}
			renderGraphBuilder.SetRenderFunc(delegate(FinalBlitPassData data, RenderGraphContext context)
			{
				MaterialPropertyBlock tempMaterialPropertyBlock = context.renderGraphPool.GetTempMaterialPropertyBlock();
				RTHandle rTHandle = data.source;
				if (data.hdrOutputParmeters.x >= 0f)
				{
					data.blitMaterial.SetInt(HDShaderIDs._NeedsFlip, data.flip ? 1 : 0);
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._UITexture, data.uiTexture);
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputTexture, rTHandle);
					tempMaterialPropertyBlock.SetVector(HDShaderIDs._HDROutputParams, data.hdrOutputParmeters);
					data.blitMaterial.shaderKeywords = null;
					HDROutputUtils.ConfigureHDROutput(data.blitMaterial, HDROutputSettings.main.displayColorGamut, HDROutputUtils.Operation.ColorEncoding);
					if (data.applyAfterPP)
					{
						data.blitMaterial.EnableKeyword("APPLY_AFTER_POST");
						data.blitMaterial.SetTexture(HDShaderIDs._AfterPostProcessTexture, data.afterPostProcessTexture);
					}
					else
					{
						data.blitMaterial.SetTexture(HDShaderIDs._AfterPostProcessTexture, TextureXR.GetBlackTexture());
					}
				}
				else
				{
					Vector4 value = new Vector4(data.viewport.width / (float)rTHandle.rt.width, data.viewport.height / (float)rTHandle.rt.height, 0f, 0f);
					if (data.flip)
					{
						value.w = value.y;
						value.y *= -1f;
					}
					tempMaterialPropertyBlock.SetTexture(HDShaderIDs._BlitTexture, rTHandle);
					tempMaterialPropertyBlock.SetVector(HDShaderIDs._BlitScaleBias, value);
					tempMaterialPropertyBlock.SetFloat(HDShaderIDs._BlitMipLevel, 0f);
					tempMaterialPropertyBlock.SetInt(HDShaderIDs._BlitTexArraySlice, data.srcTexArraySlice);
				}
				HDUtils.DrawFullScreen(context.cmd, data.viewport, data.blitMaterial, data.destination, data.cubemapFace, tempMaterialPropertyBlock, 0, data.dstTexArraySlice);
			});
		}

		private void UpdateParentExposure(RenderGraph renderGraph, HDCamera hdCamera)
		{
			HDCamera.ExposureTextures currentExposureTextures = hdCamera.currentExposureTextures;
			if (currentExposureTextures.useCurrentCamera)
			{
				return;
			}
			UpdateParentExposureData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpdateParentExposureData>("UpdateParentExposures", out passData);
			passData.textures = currentExposureTextures;
			renderGraphBuilder.SetRenderFunc(delegate(UpdateParentExposureData data, RenderGraphContext context)
			{
				if (data.textures.useFetchedExposure)
				{
					Color backgroundColor = new Color(data.textures.fetchedGpuExposure, ColorUtils.ConvertExposureToEV100(data.textures.fetchedGpuExposure), 0f, 0f);
					context.cmd.SetRenderTarget(data.textures.current);
					context.cmd.ClearRenderTarget(clearDepth: false, clearColor: true, backgroundColor);
				}
				else
				{
					context.cmd.CopyTexture(data.textures.parent, data.textures.current);
				}
			});
		}

		private void ApplyCameraMipBias(HDCamera hdCamera)
		{
			float num = 0f;
			PushCameraGlobalMipBiasPass(mipBias: (m_CurrentDebugDisplaySettings == null || !m_CurrentDebugDisplaySettings.data.UseDebugGlobalMipBiasOverride()) ? hdCamera.globalMipBias : m_CurrentDebugDisplaySettings.data.GetDebugGlobalMipBiasOverride(), renderGraph: m_RenderGraph, hdCamera: hdCamera);
		}

		private void ResetCameraMipBias(HDCamera hdCamera)
		{
			PushCameraGlobalMipBiasPass(m_RenderGraph, hdCamera, 0f);
		}

		private void PushCameraGlobalMipBiasPass(RenderGraph renderGraph, HDCamera hdCamera, float mipBias)
		{
			if (!ShaderConfig.s_GlobalMipBias)
			{
				return;
			}
			PushCameraGlobalMipBiasData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PushCameraGlobalMipBiasData>("Push Global Camera Mip Bias", out passData);
			passData.hdCamera = hdCamera;
			passData.mipBias = mipBias;
			passData.globalCB = m_ShaderVariablesGlobalCB;
			passData.xrCB = m_ShaderVariablesXRCB;
			renderGraphBuilder.SetRenderFunc(delegate(PushCameraGlobalMipBiasData data, RenderGraphContext context)
			{
				data.hdCamera.globalMipBias = data.mipBias;
				data.hdCamera.UpdateShaderVariablesGlobalCB(ref data.globalCB);
				ConstantBuffer.PushGlobal(context.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
				data.hdCamera.UpdateShaderVariablesXRCB(ref data.xrCB);
				ConstantBuffer.PushGlobal(context.cmd, in data.xrCB, HDShaderIDs._ShaderVariablesXR);
			});
		}

		private void SetFinalTarget(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle finalTarget, CubemapFace finalTargetFace)
		{
			SetFinalTargetPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SetFinalTargetPassData>("Set Final Target", out passData);
			passData.copyDepth = hdCamera.camera.targetTexture != null && hdCamera.camera.targetTexture.depth != 0;
			passData.copyDepth = passData.copyDepth && !hdCamera.xr.enabled;
			passData.finalTarget = renderGraphBuilder.WriteTexture(in finalTarget);
			passData.finalTargetFace = finalTargetFace;
			passData.finalViewport = hdCamera.finalViewport;
			if (passData.copyDepth)
			{
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				passData.flipY = hdCamera.isMainGameView || hdCamera.flipYMode == HDAdditionalCameraData.FlipYMode.ForceFlipY;
				passData.copyDepthMaterial = m_CopyDepth;
			}
			renderGraphBuilder.SetRenderFunc(delegate(SetFinalTargetPassData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetRenderTarget(data.finalTarget, 0, data.finalTargetFace);
				ctx.cmd.SetViewport(data.finalViewport);
				if (data.copyDepth)
				{
					using (new ProfilingScope(ctx.cmd, ProfilingSampler.Get(HDProfileId.CopyDepthInTargetTexture)))
					{
						MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
						RTHandle rTHandle = data.depthBuffer;
						if (rTHandle != null)
						{
							tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputDepth, rTHandle);
							tempMaterialPropertyBlock.SetInt("_FlipY", data.flipY ? 1 : 0);
							tempMaterialPropertyBlock.SetVector(HDShaderIDs._BlitScaleBias, new Vector4(1f, 1f, 0f, 0f));
							CoreUtils.DrawFullScreen(ctx.cmd, data.copyDepthMaterial, tempMaterialPropertyBlock);
						}
					}
				}
			});
		}

		private void CopyXRDepth(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle output)
		{
			if (!hdCamera.xr.enabled || !hdCamera.xr.copyDepth)
			{
				return;
			}
			CopyXRDepthPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CopyXRDepthPassData>("Copy XR Depth", out passData, ProfilingSampler.Get(HDProfileId.XRDepthCopy));
			passData.copyDepth = m_CopyDepth;
			passData.viewport = hdCamera.finalViewport;
			passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
			passData.output = renderGraphBuilder.WriteTexture(in output);
			passData.dynamicResolutionScale = DynamicResolutionHandler.instance.GetCurrentScale();
			renderGraphBuilder.SetRenderFunc(delegate(CopyXRDepthPassData data, RenderGraphContext ctx)
			{
				MaterialPropertyBlock tempMaterialPropertyBlock = ctx.renderGraphPool.GetTempMaterialPropertyBlock();
				tempMaterialPropertyBlock.SetTexture(HDShaderIDs._InputDepth, data.depthBuffer);
				tempMaterialPropertyBlock.SetVector(HDShaderIDs._BlitScaleBias, new Vector4(data.dynamicResolutionScale, data.dynamicResolutionScale, 0f, 0f));
				tempMaterialPropertyBlock.SetInt("_FlipY", 1);
				ctx.cmd.SetRenderTarget(data.output, 0, CubemapFace.Unknown, -1);
				ctx.cmd.SetViewport(data.viewport);
				CoreUtils.DrawFullScreen(ctx.cmd, data.copyDepth, tempMaterialPropertyBlock);
			});
		}

		private void PrepareCommonForwardPassData(RenderGraph renderGraph, RenderGraphBuilder builder, ForwardPassData data, bool opaque, FrameSettings frameSettings, RendererListDesc rendererListDesc, in BuildGPULightListOutput lightLists, ShadowResult shadowResult)
		{
			bool num = frameSettings.IsEnabled(FrameSettingsField.FPTLForForwardOpaque) && opaque;
			data.frameSettings = frameSettings;
			data.lightListTile = builder.ReadComputeBuffer(in lightLists.lightList);
			data.lightListCluster = builder.ReadComputeBuffer(in lightLists.perVoxelLightLists);
			if (!num)
			{
				data.perVoxelOffset = builder.ReadComputeBuffer(in lightLists.perVoxelOffset);
				if (lightLists.perTileLogBaseTweak.IsValid())
				{
					data.perTileLogBaseTweak = builder.ReadComputeBuffer(in lightLists.perTileLogBaseTweak);
				}
			}
			RendererListHandle input = renderGraph.CreateRendererList(in rendererListDesc);
			data.rendererList = builder.UseRendererList(in input);
			HDShadowManager.ReadShadowResult(in shadowResult, builder);
		}

		private static void BindGlobalLightListBuffers(ForwardPassData data, RenderGraphContext ctx)
		{
			ctx.cmd.SetGlobalBuffer(HDShaderIDs.g_vLightListTile, data.lightListTile);
			ctx.cmd.SetGlobalBuffer(HDShaderIDs.g_vLightListCluster, data.lightListCluster);
			if (data.perVoxelOffset.IsValid())
			{
				ctx.cmd.SetGlobalBuffer(HDShaderIDs.g_vLayeredOffsetsBuffer, data.perVoxelOffset);
			}
			if (data.perTileLogBaseTweak.IsValid())
			{
				ctx.cmd.SetGlobalBuffer(HDShaderIDs.g_logBaseBuffer, data.perTileLogBaseTweak);
			}
		}

		private RendererListDesc PrepareForwardOpaqueRendererList(CullingResults cullResults, HDCamera hdCamera)
		{
			ShaderTagId[] passNames = ((hdCamera.frameSettings.litShaderMode == LitShaderMode.Forward) ? m_ForwardAndForwardOnlyPassNames : m_ForwardOnlyPassNames);
			return CreateOpaqueRendererListDesc(cullResults, hdCamera.camera, passNames, m_CurrentRendererConfigurationBakedLighting);
		}

		private RendererListDesc PrepareForwardTransparentRendererList(CullingResults cullResults, HDCamera hdCamera, bool preRefraction)
		{
			RenderQueueRange value = (preRefraction ? HDRenderQueue.k_RenderQueue_PreRefraction : ((!hdCamera.frameSettings.IsEnabled(FrameSettingsField.LowResTransparent)) ? HDRenderQueue.k_RenderQueue_TransparentWithLowRes : HDRenderQueue.k_RenderQueue_Transparent));
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.Refraction))
			{
				value = ((!hdCamera.frameSettings.IsEnabled(FrameSettingsField.LowResTransparent)) ? HDRenderQueue.k_RenderQueue_AllTransparentWithLowRes : HDRenderQueue.k_RenderQueue_AllTransparent);
			}
			if (NeedMotionVectorForTransparent(hdCamera.frameSettings))
			{
				m_CurrentRendererConfigurationBakedLighting |= PerObjectData.MotionVectors;
			}
			ShaderTagId[] passNames = (m_Asset.currentPlatformRenderPipelineSettings.supportTransparentBackface ? m_AllTransparentPassNames : m_TransparentNoBackfaceNames);
			return CreateTransparentRendererListDesc(cullResults, hdCamera.camera, passNames, m_CurrentRendererConfigurationBakedLighting, value);
		}

		internal static void RenderForwardRendererList(FrameSettings frameSettings, RendererList rendererList, bool opaque, ScriptableRenderContext renderContext, CommandBuffer cmd)
		{
			bool flag = opaque && frameSettings.IsEnabled(FrameSettingsField.FPTLForForwardOpaque);
			CoreUtils.SetKeyword(cmd, "USE_FPTL_LIGHTLIST", flag);
			CoreUtils.SetKeyword(cmd, "USE_CLUSTERED_LIGHTLIST", !flag);
			if (opaque)
			{
				DrawOpaqueRendererList(in renderContext, cmd, in frameSettings, rendererList);
			}
			else
			{
				DrawTransparentRendererList(in renderContext, cmd, in frameSettings, rendererList);
			}
		}

		private void RenderForwardOpaque(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, in LightingBuffers lightingBuffers, in BuildGPULightListOutput lightLists, in PrepassOutput prepassOutput, TextureHandle vtFeedbackBuffer, ShadowResult shadowResult, CullingResults cullResults)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return;
			}
			bool flag = m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled();
			ForwardOpaquePassData passData;
			using RenderGraphBuilder builder = renderGraph.AddRenderPass<ForwardOpaquePassData>(flag ? "Forward (+ Emissive) Opaque  Debug" : "Forward (+ Emissive) Opaque", out passData, flag ? ProfilingSampler.Get(HDProfileId.ForwardOpaqueDebug) : ProfilingSampler.Get(HDProfileId.ForwardOpaque));
			PrepareCommonForwardPassData(renderGraph, builder, passData, opaque: true, hdCamera.frameSettings, PrepareForwardOpaqueRendererList(cullResults, hdCamera), in lightLists, shadowResult);
			int num = 0;
			builder.UseColorBuffer(in colorBuffer, num++);
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SubsurfaceScattering))
			{
				builder.UseColorBuffer(in lightingBuffers.diffuseLightingBuffer, num++);
				builder.UseColorBuffer(in lightingBuffers.sssBuffer, num++);
			}
			builder.UseDepthBuffer(in prepassOutput.depthBuffer, DepthAccess.ReadWrite);
			builder.AllowRendererListCulling(value: false);
			passData.enableDecals = hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) && DecalSystem.instance.HasAnyForwardEmissive();
			passData.dbuffer = ReadDBuffer(prepassOutput.dbuffer, builder);
			passData.lightingBuffers = ReadLightingBuffers(in lightingBuffers, builder);
			if (passData.enableDecals && hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers))
			{
				builder.ReadTexture(in prepassOutput.renderingLayersBuffer);
			}
			builder.SetRenderFunc(delegate(ForwardOpaquePassData data, RenderGraphContext context)
			{
				BindGlobalLightListBuffers(data, context);
				BindDBufferGlobalData(in data.dbuffer, in context);
				BindGlobalLightingBuffers(in data.lightingBuffers, context.cmd);
				RenderForwardRendererList(data.frameSettings, data.rendererList, opaque: true, context.renderContext, context.cmd);
				if (data.enableDecals)
				{
					DecalSystem.instance.RenderForwardEmissive(context.cmd);
				}
			});
		}

		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("UNITY_EDITOR")]
		private void RenderForwardError(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthStencilBuffer, CullingResults cullResults)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentObjects) && !hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return;
			}
			ForwardPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ForwardPassData>("Forward Error", out passData, ProfilingSampler.Get(HDProfileId.RenderForwardError));
			try
			{
				renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
				renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.ReadWrite);
				ForwardPassData forwardPassData = passData;
				Camera camera = hdCamera.camera;
				ShaderTagId[] forwardErrorPassNames = m_ForwardErrorPassNames;
				RenderQueueRange? renderQueueRange = RenderQueueRange.all;
				Material errorMaterial = m_ErrorMaterial;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cullResults, camera, forwardErrorPassNames, PerObjectData.None, renderQueueRange, null, errorMaterial);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				forwardPassData.rendererList = renderGraphBuilder.UseRendererList(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ForwardPassData data, RenderGraphContext context)
				{
					CoreUtils.DrawRendererList(context.renderContext, context.cmd, data.rendererList);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle CreateOffscreenUIBuffer(RenderGraph renderGraph, MSAASamples msaaSamples)
		{
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_SRGB,
				clearBuffer = true,
				clearColor = Color.clear,
				msaaSamples = msaaSamples,
				name = "UI Buffer"
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle RenderTransparentUI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer)
		{
			TextureHandle result = renderGraph.defaultResources.blackTextureXR;
			if (HDROutputActiveForCameraType(hdCamera.camera.cameraType) && SupportedRenderingFeatures.active.rendersUIOverlay && !NeedHDRDebugMode(m_CurrentDebugDisplaySettings))
			{
				RenderOffscreenUIData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderOffscreenUIData>("UI Rendering", out passData, ProfilingSampler.Get(HDProfileId.OffscreenUIRendering));
				try
				{
					TextureHandle input = CreateOffscreenUIBuffer(renderGraph, hdCamera.msaaSamples);
					result = renderGraphBuilder.UseColorBuffer(in input, 0);
					renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
					passData.camera = hdCamera.camera;
					passData.frameSettings = hdCamera.frameSettings;
					renderGraphBuilder.SetRenderFunc(delegate(RenderOffscreenUIData data, RenderGraphContext context)
					{
						context.renderContext.ExecuteCommandBuffer(context.cmd);
						context.cmd.Clear();
						context.renderContext.DrawUIOverlay(data.camera);
					});
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return result;
		}

		private TextureHandle RenderAfterPostProcessObjects(RenderGraph renderGraph, HDCamera hdCamera, PathTracing pathTracing, CullingResults cullResults, in PrepassOutput prepassOutput)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.AfterPostprocess))
			{
				return renderGraph.defaultResources.blackTextureXR;
			}
			AfterPostProcessPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<AfterPostProcessPassData>("After Post-Process Objects", out passData, ProfilingSampler.Get(HDProfileId.AfterPostProcessingObjects));
			try
			{
				bool flag = !hdCamera.RequiresCameraJitter() && hdCamera.frameSettings.IsEnabled(FrameSettingsField.ZTestAfterPostProcessTAA);
				passData.globalCB = m_ShaderVariablesGlobalCB;
				passData.hdCamera = hdCamera;
				AfterPostProcessPassData afterPostProcessPassData = passData;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cullResults, hdCamera.camera, HDShaderPassNames.s_ForwardOnlyName, PerObjectData.None, HDRenderQueue.k_RenderQueue_AfterPostProcessOpaque);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				afterPostProcessPassData.opaqueAfterPostprocessRL = renderGraphBuilder.UseRendererList(in input);
				AfterPostProcessPassData afterPostProcessPassData2 = passData;
				desc = CreateTransparentRendererListDesc(cullResults, hdCamera.camera, HDShaderPassNames.s_ForwardOnlyName, PerObjectData.None, HDRenderQueue.k_RenderQueue_AfterPostProcessTransparent);
				input = renderGraph.CreateRendererList(in desc);
				afterPostProcessPassData2.transparentAfterPostprocessRL = renderGraphBuilder.UseRendererList(in input);
				TextureDesc desc2 = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_SRGB,
					clearBuffer = true,
					clearColor = Color.black,
					name = "OffScreen AfterPostProcess"
				};
				TextureHandle input2 = renderGraph.CreateTexture(in desc2);
				TextureHandle result = renderGraphBuilder.UseColorBuffer(in input2, 0);
				if (flag)
				{
					renderGraphBuilder.UseDepthBuffer(in prepassOutput.resolvedDepthBuffer, DepthAccess.ReadWrite);
				}
				renderGraphBuilder.SetRenderFunc(delegate(AfterPostProcessPassData data, RenderGraphContext ctx)
				{
					if (data.hdCamera.RequiresCameraJitter())
					{
						data.hdCamera.UpdateAllViewConstants(jitterProjectionMatrix: false);
						data.hdCamera.UpdateShaderVariablesGlobalCB(ref data.globalCB);
					}
					UpdateOffscreenRenderingConstants(ref data.globalCB, enabled: true, 1f);
					ConstantBuffer.PushGlobal(ctx.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
					ref ScriptableRenderContext renderContext = ref ctx.renderContext;
					CommandBuffer cmd = ctx.cmd;
					FrameSettings frameSettings = data.hdCamera.frameSettings;
					DrawOpaqueRendererList(in renderContext, cmd, in frameSettings, data.opaqueAfterPostprocessRL);
					ref ScriptableRenderContext renderContext2 = ref ctx.renderContext;
					CommandBuffer cmd2 = ctx.cmd;
					frameSettings = data.hdCamera.frameSettings;
					DrawTransparentRendererList(in renderContext2, cmd2, in frameSettings, data.transparentAfterPostprocessRL);
					if (data.hdCamera.RequiresCameraJitter())
					{
						data.hdCamera.UpdateAllViewConstants(jitterProjectionMatrix: true);
						data.hdCamera.UpdateShaderVariablesGlobalCB(ref data.globalCB);
					}
					UpdateOffscreenRenderingConstants(ref data.globalCB, enabled: false, 1f);
					ConstantBuffer.PushGlobal(ctx.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
				});
				return result;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderForwardTransparent(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle normalBuffer, in PrepassOutput prepassOutput, TextureHandle vtFeedbackBuffer, TextureHandle volumetricLighting, TextureHandle ssrLighting, TextureHandle? colorPyramid, in BuildGPULightListOutput lightLists, in ShadowResult shadowResult, CullingResults cullResults, bool preRefractionPass)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentObjects) || (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.Refraction) && preRefractionPass))
			{
				return;
			}
			string passName;
			HDProfileId marker;
			if (m_CurrentDebugDisplaySettings.IsDebugDisplayEnabled())
			{
				passName = (preRefractionPass ? "Forward PreRefraction Debug" : "Forward Transparent Debug");
				marker = (preRefractionPass ? HDProfileId.ForwardPreRefractionDebug : HDProfileId.ForwardTransparentDebug);
			}
			else
			{
				passName = (preRefractionPass ? "Forward PreRefraction" : "Forward Transparent");
				marker = (preRefractionPass ? HDProfileId.ForwardPreRefraction : HDProfileId.ForwardTransparent);
			}
			ForwardTransparentPassData passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<ForwardTransparentPassData>(passName, out passData, ProfilingSampler.Get(marker));
			try
			{
				PrepareCommonForwardPassData(renderGraph, builder, passData, opaque: false, hdCamera.frameSettings, PrepareForwardTransparentRendererList(cullResults, hdCamera, preRefractionPass), in lightLists, shadowResult);
				passData.decalsEnabled = hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) && DecalSystem.m_DecalDatasCount > 0;
				passData.renderMotionVecForTransparent = NeedMotionVectorForTransparent(hdCamera.frameSettings);
				passData.colorMaskTransparentVel = colorMaskTransparentVel;
				passData.volumetricLighting = builder.ReadTexture(in volumetricLighting);
				passData.transparentSSRLighting = builder.ReadTexture(in ssrLighting);
				passData.depthPyramidTexture = builder.ReadTexture(in prepassOutput.depthPyramidTexture);
				int num = 0;
				builder.UseColorBuffer(in colorBuffer, num++);
				if (passData.renderMotionVecForTransparent)
				{
					builder.UseColorBuffer(in prepassOutput.motionVectorsBuffer, num++);
				}
				else
				{
					bool msaaEnabled = hdCamera.msaaEnabled;
					TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.R8G8B8A8_SRGB,
						bindTextureMS = msaaEnabled,
						msaaSamples = hdCamera.msaaSamples,
						name = "Transparency Velocity Dummy"
					};
					TextureHandle input = builder.CreateTransientTexture(in desc);
					builder.UseColorBuffer(in input, num++);
				}
				builder.UseDepthBuffer(in prepassOutput.depthBuffer, DepthAccess.ReadWrite);
				if (colorPyramid.HasValue && hdCamera.frameSettings.IsEnabled(FrameSettingsField.Refraction) && !preRefractionPass)
				{
					TextureHandle input = colorPyramid.Value;
					builder.ReadTexture(in input);
				}
				passData.normalBuffer = builder.ReadTexture(in normalBuffer);
				builder.SetRenderFunc(delegate(ForwardTransparentPassData data, RenderGraphContext context)
				{
					context.cmd.SetGlobalInt(data.colorMaskTransparentVel, data.renderMotionVecForTransparent ? 15 : 0);
					if (data.decalsEnabled)
					{
						DecalSystem.instance.SetAtlas(context.cmd);
					}
					BindGlobalLightListBuffers(data, context);
					context.cmd.SetGlobalTexture(HDShaderIDs._SsrLightingTexture, data.transparentSSRLighting);
					context.cmd.SetGlobalTexture(HDShaderIDs._VBufferLighting, data.volumetricLighting);
					context.cmd.SetGlobalTexture(HDShaderIDs._CameraDepthTexture, data.depthPyramidTexture);
					context.cmd.SetGlobalTexture(HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					RenderForwardRendererList(data.frameSettings, data.rendererList, opaque: false, context.renderContext, context.cmd);
				});
			}
			finally
			{
				((IDisposable)builder).Dispose();
			}
		}

		private void RenderTransparentDepthPrepass(RenderGraph renderGraph, HDCamera hdCamera, in PrepassOutput prepassOutput, CullingResults cull)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentPrepass))
			{
				return;
			}
			ForwardPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ForwardPassData>("Transparent Depth Prepass", out passData, ProfilingSampler.Get(HDProfileId.TransparentDepthPrepass));
			try
			{
				passData.frameSettings = hdCamera.frameSettings;
				if (hdCamera.IsSSREnabled(transparent: true))
				{
					int num = 0;
					if (hdCamera.msaaEnabled)
					{
						renderGraphBuilder.UseColorBuffer(in prepassOutput.depthAsColor, num++);
					}
					renderGraphBuilder.UseColorBuffer(in prepassOutput.normalBuffer, num++);
				}
				renderGraphBuilder.UseDepthBuffer(in prepassOutput.depthBuffer, DepthAccess.ReadWrite);
				ForwardPassData forwardPassData = passData;
				RendererListDesc desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, m_TransparentDepthPrepassNames);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				forwardPassData.rendererList = renderGraphBuilder.UseRendererList(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ForwardPassData data, RenderGraphContext context)
				{
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.rendererList);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderTransparentDepthPostpass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, CullingResults cull)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentPostpass))
			{
				return;
			}
			ForwardPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ForwardPassData>("Transparent Depth Postpass", out passData, ProfilingSampler.Get(HDProfileId.TransparentDepthPostpass));
			try
			{
				passData.frameSettings = hdCamera.frameSettings;
				renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.ReadWrite);
				ForwardPassData forwardPassData = passData;
				RendererListDesc desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, m_TransparentDepthPostpassNames);
				RendererListHandle input = renderGraph.CreateRendererList(in desc);
				forwardPassData.rendererList = renderGraphBuilder.UseRendererList(in input);
				renderGraphBuilder.SetRenderFunc(delegate(ForwardPassData data, RenderGraphContext context)
				{
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.rendererList);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderLowResTransparent(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle downsampledDepth, CullingResults cullingResults, RendererListHandle rendererList)
		{
			RenderLowResTransparentPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderLowResTransparentPassData>("Low Res Transparent", out passData, ProfilingSampler.Get(HDProfileId.LowResTransparent));
			try
			{
				passData.globalCB = m_ShaderVariablesGlobalCB;
				passData.lowResScale = hdCamera.lowResScale;
				passData.frameSettings = hdCamera.frameSettings;
				passData.rendererList = renderGraphBuilder.UseRendererList(in rendererList);
				renderGraphBuilder.UseDepthBuffer(in downsampledDepth, DepthAccess.ReadWrite);
				TextureDesc desc = new TextureDesc(Vector2.one * hdCamera.lowResScale, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					clearBuffer = true,
					clearColor = Color.black,
					name = "Low res transparent"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				TextureHandle result = renderGraphBuilder.UseColorBuffer(in input, 0);
				renderGraphBuilder.SetRenderFunc(delegate(RenderLowResTransparentPassData data, RenderGraphContext context)
				{
					UpdateOffscreenRenderingConstants(ref data.globalCB, enabled: true, 1f / data.lowResScale);
					ConstantBuffer.PushGlobal(context.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.rendererList);
					UpdateOffscreenRenderingConstants(ref data.globalCB, enabled: false, 1f);
					ConstantBuffer.PushGlobal(context.cmd, in data.globalCB, HDShaderIDs._ShaderVariablesGlobal);
				});
				return result;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void UpsampleTransparent(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle lowResTransparentBuffer, TextureHandle downsampledDepthBuffer, RendererListHandle rendererList)
		{
			UpsampleTransparentPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpsampleTransparentPassData>("Upsample Low Res Transparency", out passData, ProfilingSampler.Get(HDProfileId.UpsampleLowResTransparent));
			renderGraphBuilder.DependsOn(in rendererList);
			GlobalLowResolutionTransparencySettings lowresTransparentSettings = m_Asset.currentPlatformRenderPipelineSettings.lowresTransparentSettings;
			if (lowresTransparentSettings.upsampleType == LowResTransparentUpsample.Bilinear)
			{
				m_UpsampleTransparency.EnableKeyword("BILINEAR");
			}
			else if (lowresTransparentSettings.upsampleType == LowResTransparentUpsample.NearestDepth)
			{
				m_UpsampleTransparency.EnableKeyword("NEAREST_DEPTH");
			}
			passData.shaderParams = new Vector4(hdCamera.lowResScale, 1f / hdCamera.lowResScale, 0f, 0f);
			passData.upsampleMaterial = m_UpsampleTransparency;
			passData.lowResTransparentBuffer = renderGraphBuilder.ReadTexture(in lowResTransparentBuffer);
			passData.downsampledDepthBuffer = renderGraphBuilder.ReadTexture(in downsampledDepthBuffer);
			renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
			renderGraphBuilder.SetRenderFunc(delegate(UpsampleTransparentPassData data, RenderGraphContext context)
			{
				data.upsampleMaterial.SetVector(HDShaderIDs._Params, data.shaderParams);
				data.upsampleMaterial.SetTexture(HDShaderIDs._LowResTransparent, data.lowResTransparentBuffer);
				data.upsampleMaterial.SetTexture(HDShaderIDs._LowResDepthTexture, data.downsampledDepthBuffer);
				context.cmd.DrawProcedural(Matrix4x4.identity, data.upsampleMaterial, 0, MeshTopology.Triangles, 3, 1, null);
			});
		}

		private void SetGlobalColorForCustomPass(RenderGraph renderGraph, TextureHandle colorBuffer)
		{
			SetGlobalColorPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SetGlobalColorPassData>("SetGlobalColorForCustomPass", out passData);
			passData.colorBuffer = renderGraphBuilder.ReadTexture(in colorBuffer);
			renderGraphBuilder.SetRenderFunc(delegate(SetGlobalColorPassData data, RenderGraphContext context)
			{
				if ((RTHandle)data.colorBuffer != null)
				{
					context.cmd.SetGlobalTexture(HDShaderIDs._ColorPyramidTexture, data.colorBuffer);
				}
			});
		}

		private TextureHandle RenderRayTracingFlagMask(RenderGraph renderGraph, CullingResults cull, HDCamera hdCamera, TextureHandle depthBuffer)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
			{
				return renderGraph.defaultResources.blackTextureXR;
			}
			if (!hdCamera.volumeStack.GetComponent<RecursiveRendering>().enable.value || !GetRayTracingState() || !GetRayTracingClusterState())
			{
				return renderGraph.defaultResources.blackTextureXR;
			}
			RayTracingFlagMaskPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RayTracingFlagMaskPassData>("RayTracing Flag Mask", out passData, ProfilingSampler.Get(HDProfileId.RayTracingFlagMask));
			try
			{
				passData.frameSettings = hdCamera.frameSettings;
				passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				RayTracingFlagMaskPassData rayTracingFlagMaskPassData = passData;
				TextureHandle input = CreateFlagMaskTexture(renderGraph);
				rayTracingFlagMaskPassData.flagMask = renderGraphBuilder.UseColorBuffer(in input, 0);
				RayTracingFlagMaskPassData rayTracingFlagMaskPassData2 = passData;
				Camera camera = hdCamera.camera;
				ShaderTagId[] rayTracingPrepassNames = m_RayTracingPrepassNames;
				RenderStateBlock? stateBlock = m_DepthStateNoWrite;
				RendererListDesc desc = CreateOpaqueRendererListDesc(cull, camera, rayTracingPrepassNames, PerObjectData.None, null, stateBlock);
				RendererListHandle input2 = renderGraph.CreateRendererList(in desc);
				rayTracingFlagMaskPassData2.opaqueRenderList = renderGraphBuilder.UseRendererList(in input2);
				RayTracingFlagMaskPassData rayTracingFlagMaskPassData3 = passData;
				desc = CreateTransparentRendererListDesc(cull, hdCamera.camera, m_RayTracingPrepassNames, PerObjectData.None, HDRenderQueue.k_RenderQueue_AllTransparentWithLowRes, m_DepthStateNoWrite);
				input2 = renderGraph.CreateRendererList(in desc);
				rayTracingFlagMaskPassData3.transparentRenderList = renderGraphBuilder.UseRendererList(in input2);
				renderGraphBuilder.SetRenderFunc(delegate(RayTracingFlagMaskPassData data, RenderGraphContext context)
				{
					DrawOpaqueRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.opaqueRenderList);
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.transparentRenderList);
				});
				return passData.flagMask;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderTransparency(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle normalBuffer, TextureHandle vtFeedbackBuffer, TextureHandle currentColorPyramid, TextureHandle volumetricLighting, TextureHandle rayCountTexture, Texture skyTexture, in BuildGPULightListOutput lightLists, ref PrepassOutput prepassOutput, ShadowResult shadowResult, CullingResults cullingResults, CullingResults customPassCullingResults, AOVRequestData aovRequest, List<RTHandle> aovCustomPassBuffers)
		{
			TextureHandle flagMask = RenderRayTracingFlagMask(renderGraph, cullingResults, hdCamera, prepassOutput.depthBuffer);
			RenderTransparentDepthPrepass(renderGraph, hdCamera, in prepassOutput, cullingResults);
			WaterGBuffer waterGBuffer = RenderWaterGBuffer(m_RenderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.normalBuffer, currentColorPyramid, prepassOutput.depthPyramidTexture, in lightLists);
			TextureHandle ssrLighting = RenderSSR(renderGraph, hdCamera, ref prepassOutput, renderGraph.defaultResources.blackTextureXR, rayCountTexture, skyTexture, transparent: true);
			colorBuffer = RaytracingRecursiveRender(renderGraph, hdCamera, colorBuffer, prepassOutput.depthBuffer, flagMask, rayCountTexture);
			SetGlobalColorForCustomPass(renderGraph, colorBuffer);
			RenderCustomPass(m_RenderGraph, hdCamera, colorBuffer, in prepassOutput, customPassCullingResults, cullingResults, CustomPassInjectionPoint.BeforePreRefraction, aovRequest, aovCustomPassBuffers);
			SetGlobalColorForCustomPass(renderGraph, currentColorPyramid);
			ApplyCameraMipBias(hdCamera);
			RenderForwardTransparent(renderGraph, hdCamera, colorBuffer, normalBuffer, in prepassOutput, vtFeedbackBuffer, volumetricLighting, ssrLighting, null, in lightLists, in shadowResult, cullingResults, preRefractionPass: true);
			ResetCameraMipBias(hdCamera);
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Refraction) || hdCamera.IsSSREnabled() || hdCamera.IsSSREnabled(transparent: true) || hdCamera.IsSSGIEnabled() || hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water))
			{
				TextureHandle inputColor = ResolveMSAAColor(renderGraph, hdCamera, colorBuffer, m_NonMSAAColorBuffer);
				GenerateColorPyramid(renderGraph, hdCamera, inputColor, currentColorPyramid, FullScreenDebugMode.FinalColorPyramid);
			}
			RenderWaterLighting(m_RenderGraph, hdCamera, colorBuffer, prepassOutput.depthBuffer, prepassOutput.depthPyramidTexture, volumetricLighting, ssrLighting, in waterGBuffer, in lightLists);
			RenderCustomPass(m_RenderGraph, hdCamera, colorBuffer, in prepassOutput, customPassCullingResults, cullingResults, CustomPassInjectionPoint.BeforeTransparent, aovRequest, aovCustomPassBuffers);
			ApplyCameraMipBias(hdCamera);
			RenderForwardTransparent(renderGraph, hdCamera, colorBuffer, normalBuffer, in prepassOutput, vtFeedbackBuffer, volumetricLighting, ssrLighting, currentColorPyramid, in lightLists, in shadowResult, cullingResults, preRefractionPass: false);
			ResetCameraMipBias(hdCamera);
			colorBuffer = ResolveMSAAColor(renderGraph, hdCamera, colorBuffer, m_NonMSAAColorBuffer);
			colorBuffer = RenderUnderWaterVolume(renderGraph, hdCamera, colorBuffer, normalBuffer, prepassOutput.depthBuffer);
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.LowResTransparent))
			{
				ShaderTagId[] passNames = (m_Asset.currentPlatformRenderPipelineSettings.supportTransparentBackface ? m_AllTransparentPassNames : m_TransparentNoBackfaceNames);
				RendererListDesc desc = CreateTransparentRendererListDesc(cullingResults, hdCamera.camera, passNames, m_CurrentRendererConfigurationBakedLighting, HDRenderQueue.k_RenderQueue_LowTransparent);
				RendererListHandle rendererList = renderGraph.CreateRendererList(in desc);
				ApplyCameraMipBias(hdCamera);
				TextureHandle lowResTransparentBuffer = RenderLowResTransparent(renderGraph, hdCamera, prepassOutput.downsampledDepthBuffer, cullingResults, rendererList);
				ResetCameraMipBias(hdCamera);
				UpsampleTransparent(renderGraph, hdCamera, colorBuffer, lowResTransparentBuffer, prepassOutput.downsampledDepthBuffer, rendererList);
			}
			RenderTransparentDepthPostpass(renderGraph, hdCamera, prepassOutput.resolvedDepthBuffer, cullingResults);
			return colorBuffer;
		}

		private SendGeometryGraphcisBuffersParameters PrepareSendGeometryBuffersParameters(HDCamera hdCamera)
		{
			SendGeometryGraphcisBuffersParameters result = default(SendGeometryGraphcisBuffersParameters);
			result.hdCamera = hdCamera;
			result.needNormalBuffer = false;
			result.needDepthBuffer = false;
			result.packedMipChainInfo = hdCamera.depthBufferMipChainInfo;
			HDAdditionalCameraData component = null;
			hdCamera.camera.TryGetComponent<HDAdditionalCameraData>(out component);
			HDAdditionalCameraData.BufferAccessType bufferAccessType = (HDAdditionalCameraData.BufferAccessType)0;
			if (component != null)
			{
				bufferAccessType = component.GetBufferAccess();
			}
			result.neededVFXBuffers = VFXManager.IsCameraBufferNeeded(hdCamera.camera);
			result.needNormalBuffer |= (result.neededVFXBuffers & VFXCameraBufferTypes.Normal) != 0 || (bufferAccessType & HDAdditionalCameraData.BufferAccessType.Normal) != 0 || GetIndirectDiffuseMode(hdCamera) == IndirectDiffuseMode.ScreenSpace;
			result.needDepthBuffer |= (result.neededVFXBuffers & VFXCameraBufferTypes.Depth) != 0 || (bufferAccessType & HDAdditionalCameraData.BufferAccessType.Depth) != 0 || GetIndirectDiffuseMode(hdCamera) == IndirectDiffuseMode.ScreenSpace;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && GetRayTracingState())
			{
				result.needNormalBuffer = true;
				result.needDepthBuffer = true;
			}
			return result;
		}

		private void SendGeometryGraphicsBuffers(RenderGraph renderGraph, TextureHandle inputNormalBuffer, TextureHandle inputDepthBuffer, HDCamera camera)
		{
			SendGeometryGraphcisBuffersParameters parameters = PrepareSendGeometryBuffersParameters(camera);
			if (!parameters.NeedSendBuffers())
			{
				return;
			}
			SendGeometryBuffersPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SendGeometryBuffersPassData>("Send Geometry Buffers", out passData);
			renderGraphBuilder.AllowPassCulling(value: false);
			passData.parameters = parameters;
			if (!camera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				passData.normalBuffer = renderGraph.defaultResources.blackTextureXR;
				passData.depthBuffer = renderGraph.defaultResources.blackTextureXR;
			}
			else
			{
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in inputNormalBuffer);
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in inputDepthBuffer);
			}
			renderGraphBuilder.SetRenderFunc(delegate(SendGeometryBuffersPassData data, RenderGraphContext ctx)
			{
				HDCamera hdCamera = data.parameters.hdCamera;
				RTHandle rTHandle = data.normalBuffer;
				RTHandle rTHandle2 = data.depthBuffer;
				Texture texture = null;
				Texture texture2 = null;
				Texture texture3 = null;
				RTHandle localNormalBuffer;
				if (data.parameters.needNormalBuffer && rTHandle.rt != null)
				{
					localNormalBuffer = rTHandle;
					texture = hdCamera.GetCurrentFrameRT(5) ?? hdCamera.AllocHistoryFrameRT(5, Allocator, 1);
					for (int i = 0; i < hdCamera.viewCount; i++)
					{
						ctx.cmd.CopyTexture(localNormalBuffer, i, 0, 0, 0, hdCamera.actualWidth, hdCamera.actualHeight, texture, i, 0, 0, 0);
					}
				}
				RTHandle localDepthBuffer;
				if (data.parameters.needDepthBuffer && rTHandle2.rt != null)
				{
					localDepthBuffer = rTHandle2;
					texture2 = hdCamera.GetCurrentFrameRT(6) ?? hdCamera.AllocHistoryFrameRT(6, Allocator, 1);
					for (int j = 0; j < hdCamera.viewCount; j++)
					{
						ctx.cmd.CopyTexture(localDepthBuffer, j, 0, 0, 0, hdCamera.actualWidth, hdCamera.actualHeight, texture2, j, 0, 0, 0);
					}
					texture3 = hdCamera.GetCurrentFrameRT(7) ?? hdCamera.AllocHistoryFrameRT(7, Allocator1, 1);
					for (int k = 0; k < hdCamera.viewCount; k++)
					{
						ctx.cmd.CopyTexture(localDepthBuffer, k, 0, data.parameters.packedMipChainInfo.mipLevelOffsets[1].x, data.parameters.packedMipChainInfo.mipLevelOffsets[1].y, hdCamera.actualWidth / 2, hdCamera.actualHeight / 2, texture3, k, 0, 0, 0);
					}
				}
				if ((data.parameters.neededVFXBuffers & VFXCameraBufferTypes.Depth) != 0)
				{
					VFXManager.SetCameraBuffer(hdCamera.camera, VFXCameraBufferTypes.Depth, texture2, 0, 0, hdCamera.actualWidth, hdCamera.actualHeight);
				}
				if ((data.parameters.neededVFXBuffers & VFXCameraBufferTypes.Normal) != 0)
				{
					VFXManager.SetCameraBuffer(hdCamera.camera, VFXCameraBufferTypes.Normal, texture, 0, 0, hdCamera.actualWidth, hdCamera.actualHeight);
				}
				RTHandle Allocator(string id, int frameIndex, RTHandleSystem rtHandleSystem)
				{
					return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, localNormalBuffer.rt.graphicsFormat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, localNormalBuffer.rt.enableRandomWrite, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, id + "_Normal History Buffer");
				}
				RTHandle Allocator(string id, int frameIndex, RTHandleSystem rtHandleSystem)
				{
					return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, localDepthBuffer.rt.graphicsFormat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, localDepthBuffer.rt.enableRandomWrite, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, id + "_Depth History Buffer");
				}
				RTHandle Allocator1(string id, int frameIndex, RTHandleSystem rtHandleSystem)
				{
					return rtHandleSystem.Alloc(Vector2.one * 0.5f, TextureXR.slices, DepthBits.None, localDepthBuffer.rt.graphicsFormat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, localDepthBuffer.rt.enableRandomWrite, useMipMap: false, autoGenerateMips: true, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, "Depth History Buffer Mip 1");
				}
			});
		}

		private void SendColorGraphicsBuffer(RenderGraph renderGraph, HDCamera hdCamera)
		{
			SendColorGraphicsBufferPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SendColorGraphicsBufferPassData>("Send Color Buffers", out passData);
			renderGraphBuilder.AllowPassCulling(value: false);
			passData.hdCamera = hdCamera;
			renderGraphBuilder.SetRenderFunc(delegate(SendColorGraphicsBufferPassData data, RenderGraphContext ctx)
			{
				if ((VFXManager.IsCameraBufferNeeded(data.hdCamera.camera) & VFXCameraBufferTypes.Color) != 0)
				{
					RTHandle currentFrameRT = data.hdCamera.GetCurrentFrameRT(0);
					VFXManager.SetCameraBuffer(data.hdCamera.camera, VFXCameraBufferTypes.Color, currentFrameRT, 0, 0, data.hdCamera.actualWidth, data.hdCamera.actualHeight);
				}
			});
		}

		private void ClearStencilBuffer(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.OpaqueObjects))
			{
				return;
			}
			ClearStencilPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ClearStencilPassData>("Clear Stencil Buffer", out passData, ProfilingSampler.Get(HDProfileId.ClearStencil));
			passData.clearStencilMaterial = m_ClearStencilBufferMaterial;
			passData.depthBuffer = renderGraphBuilder.WriteTexture(in depthBuffer);
			renderGraphBuilder.SetRenderFunc(delegate(ClearStencilPassData data, RenderGraphContext ctx)
			{
				data.clearStencilMaterial.SetInt(HDShaderIDs._StencilMask, 63);
				HDUtils.DrawFullScreen(ctx.cmd, data.clearStencilMaterial, data.depthBuffer);
			});
		}

		private void PreRenderSky(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, TextureHandle normalbuffer)
		{
			if (!m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera))
			{
				m_SkyManager.PreRenderSky(renderGraph, hdCamera, normalbuffer, depthStencilBuffer);
			}
		}

		private void RenderSky(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle volumetricLighting, TextureHandle depthStencilBuffer, TextureHandle depthTexture)
		{
			if (!m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera))
			{
				m_SkyManager.RenderSky(renderGraph, hdCamera, colorBuffer, depthStencilBuffer, "Render Sky", ProfilingSampler.Get(HDProfileId.RenderSky));
				m_SkyManager.RenderOpaqueAtmosphericScattering(renderGraph, hdCamera, colorBuffer, depthTexture, volumetricLighting, depthStencilBuffer);
			}
		}

		private void GenerateColorPyramid(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle inputColor, TextureHandle output, FullScreenDebugMode fsDebugMode, RendererListHandle? depedency = null)
		{
			GenerateColorPyramidData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GenerateColorPyramidData>("Color Gaussian MIP Chain", out passData, ProfilingSampler.Get(HDProfileId.ColorPyramid));
			try
			{
				if (depedency.HasValue)
				{
					RendererListHandle input = depedency.Value;
					renderGraphBuilder.DependsOn(in input);
				}
				if (!hdCamera.colorPyramidHistoryIsValid)
				{
					hdCamera.colorPyramidHistoryIsValid = true;
					hdCamera.colorPyramidHistoryValidFrames = 0;
				}
				else
				{
					hdCamera.colorPyramidHistoryValidFrames++;
				}
				passData.colorPyramid = renderGraphBuilder.WriteTexture(in output);
				passData.inputColor = renderGraphBuilder.ReadTexture(in inputColor);
				passData.hdCamera = hdCamera;
				passData.mipGenerator = m_MipGenerator;
				renderGraphBuilder.SetRenderFunc(delegate(GenerateColorPyramidData data, RenderGraphContext context)
				{
					Vector2Int size = new Vector2Int(data.hdCamera.actualWidth, data.hdCamera.actualHeight);
					data.hdCamera.colorPyramidHistoryMipCount = data.mipGenerator.RenderColorGaussianPyramid(context.cmd, size, data.inputColor, data.colorPyramid);
					context.cmd.SetGlobalTexture(HDShaderIDs._ColorPyramidTexture, data.colorPyramid);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
			PushFullScreenDebugTextureMip(scaleBias: new Vector4(RTHandles.rtHandleProperties.rtHandleScale.x, RTHandles.rtHandleProperties.rtHandleScale.y, 0f, 0f), renderGraph: renderGraph, input: output, lodCount: hdCamera.colorPyramidHistoryMipCount, debugMode: fsDebugMode);
		}

		private TextureHandle AccumulateDistortion(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, RendererListHandle distortionRendererList)
		{
			AccumulateDistortionPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<AccumulateDistortionPassData>("Accumulate Distortion", out passData, ProfilingSampler.Get(HDProfileId.AccumulateDistortion));
			try
			{
				passData.frameSettings = hdCamera.frameSettings;
				AccumulateDistortionPassData accumulateDistortionPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = Builtin.GetDistortionBufferFormat(),
					clearBuffer = true,
					clearColor = Color.clear,
					name = "Distortion"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				accumulateDistortionPassData.distortionBuffer = renderGraphBuilder.UseColorBuffer(in input, 0);
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.Read);
				passData.distortionRendererList = renderGraphBuilder.UseRendererList(in distortionRendererList);
				renderGraphBuilder.SetRenderFunc(delegate(AccumulateDistortionPassData data, RenderGraphContext context)
				{
					DrawTransparentRendererList(in context.renderContext, context.cmd, in data.frameSettings, data.distortionRendererList);
				});
				return passData.distortionBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderDistortion(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthStencilBuffer, TextureHandle colorPyramidBuffer, TextureHandle distortionBuffer, RendererListHandle distortionRendererList)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.Distortion))
			{
				return;
			}
			RenderDistortionPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderDistortionPassData>("Apply Distortion", out passData, ProfilingSampler.Get(HDProfileId.ApplyDistortion));
			try
			{
				renderGraphBuilder.DependsOn(in distortionRendererList);
				passData.applyDistortionMaterial = m_ApplyDistortionMaterial;
				passData.roughDistortion = hdCamera.frameSettings.IsEnabled(FrameSettingsField.RoughDistortion);
				RenderDistortionPassData renderDistortionPassData = passData;
				TextureHandle sourceColorBuffer;
				if (!passData.roughDistortion)
				{
					TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GetColorBufferFormat(),
						name = "DistortionIntermediateBuffer"
					};
					sourceColorBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					sourceColorBuffer = renderGraphBuilder.ReadTexture(in colorPyramidBuffer);
				}
				renderDistortionPassData.sourceColorBuffer = sourceColorBuffer;
				passData.distortionBuffer = renderGraphBuilder.ReadTexture(in distortionBuffer);
				passData.colorBuffer = renderGraphBuilder.UseColorBuffer(in colorBuffer, 0);
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.Read);
				passData.size = new Vector4(hdCamera.actualWidth, hdCamera.actualHeight, 1f / (float)hdCamera.actualWidth, 1f / (float)hdCamera.actualHeight);
				renderGraphBuilder.SetRenderFunc(delegate(RenderDistortionPassData data, RenderGraphContext context)
				{
					if (!data.roughDistortion)
					{
						HDUtils.BlitCameraTexture(context.cmd, data.colorBuffer, data.sourceColorBuffer);
					}
					data.applyDistortionMaterial.SetTexture(HDShaderIDs._DistortionTexture, data.distortionBuffer);
					data.applyDistortionMaterial.SetTexture(HDShaderIDs._ColorPyramidTexture, data.sourceColorBuffer);
					data.applyDistortionMaterial.SetVector(HDShaderIDs._Size, data.size);
					data.applyDistortionMaterial.SetInt(HDShaderIDs._StencilMask, 4);
					data.applyDistortionMaterial.SetInt(HDShaderIDs._StencilRef, 4);
					data.applyDistortionMaterial.SetInt(HDShaderIDs._RoughDistortion, data.roughDistortion ? 1 : 0);
					HDUtils.DrawFullScreen(context.cmd, data.applyDistortionMaterial, data.colorBuffer, data.depthStencilBuffer);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle CreateColorBuffer(RenderGraph renderGraph, HDCamera hdCamera, bool msaa, bool fallbackToBlack = false)
		{
			FastMemoryDesc fastMemoryDesc = default(FastMemoryDesc);
			fastMemoryDesc.inFastMemory = true;
			fastMemoryDesc.residencyFraction = 1f;
			fastMemoryDesc.flags = FastMemoryFlags.SpillTop;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GetColorBufferFormat(),
				enableRandomWrite = !msaa,
				bindTextureMS = msaa,
				msaaSamples = ((!msaa) ? MSAASamples.None : hdCamera.msaaSamples),
				clearBuffer = NeedClearColorBuffer(hdCamera),
				clearColor = GetColorBufferClearColor(hdCamera),
				name = (msaa ? "CameraColorMSAA" : "CameraColor"),
				fallBackToBlackTexture = fallbackToBlack,
				fastMemoryDesc = fastMemoryDesc
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle ResolveMSAAColor(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle input)
		{
			TextureDesc desc = renderGraph.GetTextureDesc(input);
			desc.msaaSamples = MSAASamples.None;
			desc.enableRandomWrite = true;
			desc.bindTextureMS = false;
			TextureHandle output = renderGraph.CreateTexture(in desc);
			return ResolveMSAAColor(renderGraph, hdCamera, input, output);
		}

		private TextureHandle ResolveMSAAColor(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle input, TextureHandle output)
		{
			ResolveColorData passData;
			if (hdCamera.msaaEnabled)
			{
				using (RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolveColorData>("ResolveColor", out passData))
				{
					passData.input = renderGraphBuilder.ReadTexture(in input);
					passData.output = renderGraphBuilder.UseColorBuffer(in output, 0);
					passData.resolveMaterial = m_ColorResolveMaterial;
					passData.passIndex = SampleCountToPassIndex(hdCamera.msaaSamples);
					renderGraphBuilder.SetRenderFunc(delegate(ResolveColorData data, RenderGraphContext context)
					{
						MaterialPropertyBlock tempMaterialPropertyBlock = context.renderGraphPool.GetTempMaterialPropertyBlock();
						tempMaterialPropertyBlock.SetTexture(HDShaderIDs._ColorTextureMS, data.input);
						context.cmd.DrawProcedural(Matrix4x4.identity, data.resolveMaterial, data.passIndex, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock);
					});
					return passData.output;
				}
			}
			return input;
		}

		private TextureHandle ResolveMotionVector(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle input)
		{
			if (hdCamera.msaaEnabled)
			{
				ResolveMotionVectorData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResolveMotionVectorData>("ResolveMotionVector", out passData);
				try
				{
					passData.input = renderGraphBuilder.ReadTexture(in input);
					ResolveMotionVectorData resolveMotionVectorData = passData;
					TextureHandle input2 = CreateMotionVectorBuffer(renderGraph, clear: false, MSAASamples.None);
					resolveMotionVectorData.output = renderGraphBuilder.UseColorBuffer(in input2, 0);
					passData.resolveMaterial = m_MotionVectorResolve;
					passData.passIndex = SampleCountToPassIndex(hdCamera.msaaSamples);
					renderGraphBuilder.SetRenderFunc(delegate(ResolveMotionVectorData data, RenderGraphContext context)
					{
						MaterialPropertyBlock tempMaterialPropertyBlock = context.renderGraphPool.GetTempMaterialPropertyBlock();
						tempMaterialPropertyBlock.SetTexture(HDShaderIDs._MotionVectorTextureMS, data.input);
						context.cmd.DrawProcedural(Matrix4x4.identity, data.resolveMaterial, data.passIndex, MeshTopology.Triangles, 3, 1, tempMaterialPropertyBlock);
					});
					return passData.output;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return input;
		}

		private void RenderGizmos(RenderGraph renderGraph, HDCamera hdCamera, GizmoSubset gizmoSubset)
		{
		}

		private bool RenderCustomPass(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, in PrepassOutput prepassOutput, CullingResults cullingResults, CullingResults cameraCullingResults, CustomPassInjectionPoint injectionPoint, AOVRequestData aovRequest, List<RTHandle> aovCustomPassBuffers)
		{
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.CustomPass))
			{
				return false;
			}
			bool flag = false;
			CustomPassVolume.GetActivePassVolumes(injectionPoint, m_ActivePassVolumes);
			foreach (CustomPassVolume activePassVolume in m_ActivePassVolumes)
			{
				if (activePassVolume == null)
				{
					return false;
				}
				CustomPass.RenderTargets renderTargets = default(CustomPass.RenderTargets);
				renderTargets.customColorBuffer = m_CustomPassColorBuffer;
				renderTargets.customDepthBuffer = m_CustomPassDepthBuffer;
				renderTargets.colorBufferRG = colorBuffer;
				renderTargets.nonMSAAColorBufferRG = m_NonMSAAColorBuffer;
				renderTargets.depthBufferRG = prepassOutput.depthBuffer;
				renderTargets.normalBufferRG = prepassOutput.resolvedNormalBuffer;
				renderTargets.motionVectorBufferRG = prepassOutput.resolvedMotionVectorsBuffer;
				CustomPass.RenderTargets targets = renderTargets;
				flag |= activePassVolume.Execute(renderGraph, hdCamera, cullingResults, cameraCullingResults, in targets);
			}
			aovRequest.PushCustomPassTexture(renderGraph, injectionPoint, colorBuffer, m_CustomPassColorBuffer, aovCustomPassBuffers);
			return flag;
		}

		internal void UpdatePostProcessScreenSize(RenderGraph renderGraph, HDCamera hdCamera, int postProcessWidth, int postProcessHeight)
		{
			UpdatePostProcessScreenSizePassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpdatePostProcessScreenSizePassData>("Update RT Handle Scales CB", out passData);
			passData.hdCamera = hdCamera;
			passData.shaderVariablesGlobal = m_ShaderVariablesGlobalCB;
			passData.postProcessWidth = postProcessWidth;
			passData.postProcessHeight = postProcessHeight;
			renderGraphBuilder.SetRenderFunc(delegate(UpdatePostProcessScreenSizePassData data, RenderGraphContext ctx)
			{
				data.hdCamera.SetPostProcessScreenSize(data.postProcessWidth, data.postProcessHeight);
				data.hdCamera.UpdateScalesAndScreenSizesCB(ref data.shaderVariablesGlobal);
				ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesGlobal, HDShaderIDs._ShaderVariablesGlobal);
			});
		}

		private void ResetCameraSizeForAfterPostProcess(RenderGraph renderGraph, HDCamera hdCamera, CommandBuffer commandBuffer)
		{
			if (!DynamicResolutionHandler.instance.DynamicResolutionEnabled())
			{
				return;
			}
			ResetCameraSizeForAfterPostProcessPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ResetCameraSizeForAfterPostProcessPassData>("Reset Camera Size After Post Process", out passData);
			passData.hdCamera = hdCamera;
			passData.shaderVariablesGlobal = m_ShaderVariablesGlobalCB;
			renderGraphBuilder.AllowPassCulling(value: false);
			renderGraphBuilder.SetRenderFunc(delegate(ResetCameraSizeForAfterPostProcessPassData data, RenderGraphContext ctx)
			{
				data.shaderVariablesGlobal._ScreenSize = new Vector4(data.hdCamera.finalViewport.width, data.hdCamera.finalViewport.height, 1f / data.hdCamera.finalViewport.width, 1f / data.hdCamera.finalViewport.height);
				data.shaderVariablesGlobal._RTHandleScale = RTHandles.rtHandleProperties.rtHandleScale;
				ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesGlobal, HDShaderIDs._ShaderVariablesGlobal);
				RTHandles.SetReferenceSize((int)data.hdCamera.finalViewport.width, (int)data.hdCamera.finalViewport.height);
			});
		}

		private void RenderWireOverlay(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer)
		{
		}

		private void RenderScreenSpaceOverlayUI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer)
		{
			if (HDROutputActiveForCameraType(hdCamera.camera.cameraType) || !SupportedRenderingFeatures.active.rendersUIOverlay || hdCamera.camera.cameraType == CameraType.SceneView)
			{
				return;
			}
			RenderScreenSpaceOverlayData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderScreenSpaceOverlayData>("Screen Space Overlay UI", out passData);
			renderGraphBuilder.WriteTexture(in colorBuffer);
			passData.camera = hdCamera.camera;
			renderGraphBuilder.SetRenderFunc(delegate(RenderScreenSpaceOverlayData data, RenderGraphContext ctx)
			{
				ctx.renderContext.ExecuteCommandBuffer(ctx.cmd);
				ctx.cmd.Clear();
				ctx.renderContext.DrawUIOverlay(data.camera);
			});
		}

		private static void UpdateOffscreenRenderingConstants(ref ShaderVariablesGlobal cb, bool enabled, float factor)
		{
			cb._OffScreenRendering = (enabled ? 1u : 0u);
			cb._OffScreenDownsampleFactor = factor;
		}

		internal static void GenerateMipmaps(RenderGraph renderGraph, TextureHandle texture)
		{
			GenerateMipmapsPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GenerateMipmapsPassData>("Generate Mipmaps", out passData);
			passData.texture = renderGraphBuilder.ReadWriteTexture(in texture);
			renderGraphBuilder.SetRenderFunc(delegate(GenerateMipmapsPassData data, RenderGraphContext context)
			{
				RTHandle rTHandle = data.texture;
				context.cmd.GenerateMips(rTHandle);
			});
		}

		internal static void SetGlobalTexture(RenderGraph renderGraph, int shaderID, Texture texture)
		{
			SetGlobalTexturePassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SetGlobalTexturePassData>("SetGlobalTexture", out passData);
			renderGraphBuilder.AllowPassCulling(value: false);
			passData.shaderID = shaderID;
			passData.texture = texture;
			renderGraphBuilder.SetRenderFunc(delegate(SetGlobalTexturePassData data, RenderGraphContext context)
			{
				context.cmd.SetGlobalTexture(data.shaderID, data.texture);
			});
		}

		internal static void SetGlobalBuffer(RenderGraph renderGraph, int shaderID, ComputeBuffer buffer)
		{
			SetGlobalBufferPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SetGlobalBufferPassData>("SetGlobalBuffer", out passData);
			renderGraphBuilder.AllowPassCulling(value: false);
			passData.shaderID = shaderID;
			passData.buffer = buffer;
			renderGraphBuilder.SetRenderFunc(delegate(SetGlobalBufferPassData data, RenderGraphContext context)
			{
				context.cmd.SetGlobalBuffer(data.shaderID, data.buffer);
			});
		}

		private static void DrawOpaqueRendererList(in RenderGraphContext context, in FrameSettings frameSettings, in RendererList rendererList)
		{
			DrawOpaqueRendererList(in context.renderContext, context.cmd, in frameSettings, rendererList);
		}

		private static void DrawTransparentRendererList(in RenderGraphContext context, in FrameSettings frameSettings, RendererList rendererList)
		{
			DrawTransparentRendererList(in context.renderContext, context.cmd, in frameSettings, rendererList);
		}

		internal static int SampleCountToPassIndex(MSAASamples samples)
		{
			return samples switch
			{
				MSAASamples.None => 0, 
				MSAASamples.MSAA2x => 1, 
				MSAASamples.MSAA4x => 2, 
				MSAASamples.MSAA8x => 3, 
				_ => 0, 
			};
		}

		private bool NeedClearColorBuffer(HDCamera hdCamera)
		{
			if (hdCamera.clearColorMode == HDAdditionalCameraData.ClearColorMode.Color || m_CurrentDebugDisplaySettings.data.lightingDebugSettings.debugLightingMode == DebugLightingMode.LuxMeter || m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera) || (hdCamera.clearColorMode == HDAdditionalCameraData.ClearColorMode.Sky && !m_SkyManager.IsVisualSkyValid(hdCamera)) || HDUtils.IsRegularPreviewCamera(hdCamera.camera))
			{
				return true;
			}
			return false;
		}

		private Color GetColorBufferClearColor(HDCamera hdCamera)
		{
			Color result = hdCamera.backgroundColorHDR;
			if (m_CurrentDebugDisplaySettings.data.lightingDebugSettings.debugLightingMode == DebugLightingMode.LuxMeter || m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera))
			{
				result = Color.black;
			}
			if (hdCamera.CameraIsSceneFiltering())
			{
				result.a = 0f;
			}
			return result;
		}

		internal static void StartXRSinglePass(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (!hdCamera.xr.enabled)
			{
				return;
			}
			XRRenderingPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<XRRenderingPassData>("Start XR single-pass", out passData);
			passData.xr = hdCamera.xr;
			renderGraphBuilder.SetRenderFunc(delegate(XRRenderingPassData data, RenderGraphContext context)
			{
				data.xr.StartSinglePass(context.cmd);
			});
		}

		internal static void StopXRSinglePass(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (!hdCamera.xr.enabled)
			{
				return;
			}
			XRRenderingPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<XRRenderingPassData>("Stop XR single-pass", out passData);
			passData.xr = hdCamera.xr;
			renderGraphBuilder.SetRenderFunc(delegate(XRRenderingPassData data, RenderGraphContext context)
			{
				data.xr.StopSinglePass(context.cmd);
			});
		}

		private void RenderXROcclusionMeshes(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthBuffer)
		{
			if (!hdCamera.xr.hasValidOcclusionMesh || !m_Asset.currentPlatformRenderPipelineSettings.xrSettings.occlusionMesh)
			{
				return;
			}
			RenderOcclusionMeshesPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderOcclusionMeshesPassData>("XR Occlusion Meshes", out passData);
			passData.hdCamera = hdCamera;
			passData.colorBuffer = renderGraphBuilder.WriteTexture(in colorBuffer);
			passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Write);
			passData.clearColor = GetColorBufferClearColor(hdCamera);
			renderGraphBuilder.SetRenderFunc(delegate(RenderOcclusionMeshesPassData data, RenderGraphContext ctx)
			{
				CoreUtils.SetRenderTarget(ctx.cmd, data.colorBuffer, data.depthBuffer, ClearFlag.None, data.clearColor);
				ctx.cmd.SetGlobalVector(HDShaderIDs._ClearColor, data.clearColor);
				data.hdCamera.xr.RenderOcclusionMesh(ctx.cmd);
			});
		}

		internal static void BlitCameraTexture(RenderGraph renderGraph, TextureHandle source, TextureHandle destination, float mipLevel = 0f, bool bilinear = false)
		{
			BlitCameraTextureData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<BlitCameraTextureData>("Blit Camera Texture", out passData);
			passData.source = renderGraphBuilder.ReadTexture(in source);
			passData.destination = renderGraphBuilder.WriteTexture(in destination);
			passData.mipLevel = mipLevel;
			passData.bilinear = bilinear;
			renderGraphBuilder.SetRenderFunc(delegate(BlitCameraTextureData data, RenderGraphContext ctx)
			{
				HDUtils.BlitCameraTexture(ctx.cmd, data.source, data.destination, data.mipLevel, data.bilinear);
			});
		}

		private void InitializeSubsurfaceScattering()
		{
			string name = "SubsurfaceScattering";
			m_SubsurfaceScatteringCS = defaultResources.shaders.subsurfaceScatteringCS;
			m_SubsurfaceScatteringKernel = m_SubsurfaceScatteringCS.FindKernel(name);
			m_CombineLightingPass = CoreUtils.CreateEngineMaterial(defaultResources.shaders.combineLightingPS);
			m_CombineLightingPass.SetInt(HDShaderIDs._StencilRef, 4);
			m_CombineLightingPass.SetInt(HDShaderIDs._StencilMask, 4);
			m_SSSCopyStencilForSplitLighting = CoreUtils.CreateEngineMaterial(defaultResources.shaders.copyStencilBufferPS);
			m_SSSCopyStencilForSplitLighting.SetInt(HDShaderIDs._StencilRef, 4);
			m_SSSCopyStencilForSplitLighting.SetInt(HDShaderIDs._StencilMask, 4);
			m_SSSDefaultDiffusionProfile = defaultResources.assets.defaultDiffusionProfile;
			m_SSSShapeParamsAndMaxScatterDists = new Vector4[16];
			m_SSSTransmissionTintsAndFresnel0 = new Vector4[16];
			m_SSSDisabledTransmissionTintsAndFresnel0 = new Vector4[16];
			m_SSSWorldScalesAndFilterRadiiAndThicknessRemaps = new Vector4[16];
			m_SSSDiffusionProfileHashes = new uint[16];
			m_SSSDiffusionProfileUpdate = new int[16];
			m_SSSSetDiffusionProfiles = new DiffusionProfileSettings[16];
			if (rayTracingSupported)
			{
				InitializeSubsurfaceScatteringRT();
			}
		}

		private void CleanupSubsurfaceScattering()
		{
			if (rayTracingSupported)
			{
				CleanupSubsurfaceScatteringRT();
			}
			CoreUtils.Destroy(m_CombineLightingPass);
			CoreUtils.Destroy(m_SSSCopyStencilForSplitLighting);
		}

		private void UpdateCurrentDiffusionProfileSettings(HDCamera hdCamera)
		{
			SetDiffusionProfileAtIndex(m_SSSDefaultDiffusionProfile, 0);
			m_SSSDiffusionProfileHashes[0] = 0u;
			int sSSActiveDiffusionProfileCount = 1;
			DiffusionProfileSettingsParameter diffusionProfiles = hdCamera.volumeStack.GetComponent<DiffusionProfileList>().diffusionProfiles;
			if (diffusionProfiles.value != null)
			{
				sSSActiveDiffusionProfileCount = diffusionProfiles.accumulatedCount;
				for (int i = 1; i < diffusionProfiles.accumulatedCount; i++)
				{
					SetDiffusionProfileAtIndex(diffusionProfiles.value[i], i);
				}
			}
			m_SSSActiveDiffusionProfileCount = sSSActiveDiffusionProfileCount;
		}

		private void SetDiffusionProfileAtIndex(DiffusionProfileSettings settings, int index)
		{
			if ((!(m_SSSSetDiffusionProfiles[index] == settings) || m_SSSDiffusionProfileUpdate[index] != settings.updateCount) && settings.profile.hash != 0)
			{
				m_SSSShapeParamsAndMaxScatterDists[index] = settings.shapeParamAndMaxScatterDist;
				m_SSSTransmissionTintsAndFresnel0[index] = settings.transmissionTintAndFresnel0;
				m_SSSDisabledTransmissionTintsAndFresnel0[index] = settings.disabledTransmissionTintAndFresnel0;
				m_SSSWorldScalesAndFilterRadiiAndThicknessRemaps[index] = settings.worldScaleAndFilterRadiusAndThicknessRemap;
				m_SSSDiffusionProfileHashes[index] = settings.profile.hash;
				uint num = (uint)(1 << index);
				m_SSSTexturingModeFlags &= ~num;
				m_SSSTransmissionFlags &= ~num;
				m_SSSTexturingModeFlags |= (uint)settings.profile.texturingMode << index;
				m_SSSTransmissionFlags |= (uint)settings.profile.transmissionMode << index;
				m_SSSSetDiffusionProfiles[index] = settings;
				m_SSSDiffusionProfileUpdate[index] = settings.updateCount;
			}
		}

		private unsafe void UpdateShaderVariablesGlobalSubsurface(ref ShaderVariablesGlobal cb, HDCamera hdCamera)
		{
			UpdateCurrentDiffusionProfileSettings(hdCamera);
			cb._DiffusionProfileCount = (uint)m_SSSActiveDiffusionProfileCount;
			cb._EnableSubsurfaceScattering = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SubsurfaceScattering) ? 1u : 0u);
			cb._TexturingModeFlags = m_SSSTexturingModeFlags;
			cb._TransmissionFlags = m_SSSTransmissionFlags;
			for (int i = 0; i < m_SSSActiveDiffusionProfileCount; i++)
			{
				for (int j = 0; j < 4; j++)
				{
					cb._ShapeParamsAndMaxScatterDists[i * 4 + j] = m_SSSShapeParamsAndMaxScatterDists[i][j];
					cb._TransmissionTintsAndFresnel0[i * 4 + j] = (hdCamera.frameSettings.IsEnabled(FrameSettingsField.Transmission) ? m_SSSTransmissionTintsAndFresnel0[i][j] : m_SSSDisabledTransmissionTintsAndFresnel0[i][j]);
					cb._WorldScalesAndFilterRadiiAndThicknessRemaps[i * 4 + j] = m_SSSWorldScalesAndFilterRadiiAndThicknessRemaps[i][j];
				}
				cb._DiffusionProfileHashTable[i * 4] = m_SSSDiffusionProfileHashes[i];
			}
		}

		private static bool NeedTemporarySubsurfaceBuffer()
		{
			if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStation4 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStation5 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.PlayStation5NGGC && SystemInfo.graphicsDeviceType != GraphicsDeviceType.XboxOne && SystemInfo.graphicsDeviceType != GraphicsDeviceType.XboxOneD3D12 && SystemInfo.graphicsDeviceType != GraphicsDeviceType.GameCoreXboxOne)
			{
				return SystemInfo.graphicsDeviceType != GraphicsDeviceType.GameCoreXboxSeries;
			}
			return false;
		}

		private TextureHandle CreateSSSBuffer(RenderGraph renderGraph, HDCamera hdCamera, MSAASamples msaaSamples)
		{
			bool flag = msaaSamples != MSAASamples.None;
			FastMemoryDesc fastMemoryDesc = default(FastMemoryDesc);
			fastMemoryDesc.inFastMemory = true;
			fastMemoryDesc.residencyFraction = 1f;
			fastMemoryDesc.flags = FastMemoryFlags.SpillTop;
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_SRGB,
				enableRandomWrite = !flag,
				bindTextureMS = flag,
				msaaSamples = msaaSamples,
				clearBuffer = NeedClearGBuffer(hdCamera),
				clearColor = Color.clear,
				name = (flag ? "SSSBufferMSAA" : "SSSBuffer"),
				fastMemoryDesc = fastMemoryDesc
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle RenderSubsurfaceScatteringScreenSpace(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, in LightingBuffers lightingBuffers, ref PrepassOutput prepassOutput)
		{
			BuildCoarseStencilAndResolveIfNeeded(renderGraph, hdCamera, resolveOnly: false, ref prepassOutput);
			TextureHandle input = prepassOutput.depthBuffer;
			TextureHandle input2 = prepassOutput.depthPyramidTexture;
			SubsurfaceScaterringPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SubsurfaceScaterringPassData>("Subsurface Scattering", out passData, ProfilingSampler.Get(HDProfileId.SubsurfaceScattering));
			try
			{
				CoreUtils.SetKeyword(m_SubsurfaceScatteringCS, "ENABLE_MSAA", hdCamera.msaaEnabled);
				passData.subsurfaceScatteringCS = m_SubsurfaceScatteringCS;
				passData.subsurfaceScatteringCSKernel = m_SubsurfaceScatteringKernel;
				passData.needTemporaryBuffer = NeedTemporarySubsurfaceBuffer() || hdCamera.msaaEnabled;
				passData.copyStencilForSplitLighting = m_SSSCopyStencilForSplitLighting;
				passData.combineLighting = m_CombineLightingPass;
				passData.numTilesX = ((int)hdCamera.screenSize.x + 15) / 16;
				passData.numTilesY = ((int)hdCamera.screenSize.y + 15) / 16;
				passData.numTilesZ = hdCamera.viewCount;
				passData.sampleBudget = hdCamera.frameSettings.sssResolvedSampleBudget;
				passData.colorBuffer = renderGraphBuilder.WriteTexture(in colorBuffer);
				passData.diffuseBuffer = renderGraphBuilder.ReadTexture(in lightingBuffers.diffuseLightingBuffer);
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in input);
				passData.depthTexture = renderGraphBuilder.ReadTexture(in input2);
				passData.sssBuffer = renderGraphBuilder.ReadTexture(in lightingBuffers.sssBuffer);
				passData.coarseStencilBuffer = renderGraphBuilder.ReadComputeBuffer(in prepassOutput.coarseStencilBuffer);
				if (passData.needTemporaryBuffer)
				{
					SubsurfaceScaterringPassData subsurfaceScaterringPassData = passData;
					TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
					{
						colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
						enableRandomWrite = true,
						clearBuffer = true,
						clearColor = Color.clear,
						name = "SSSCameraFiltering"
					};
					subsurfaceScaterringPassData.cameraFilteringBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				}
				else
				{
					passData.cameraFilteringBuffer = TextureHandle.nullHandle;
				}
				renderGraphBuilder.SetRenderFunc(delegate(SubsurfaceScaterringPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeIntParam(data.subsurfaceScatteringCS, HDShaderIDs._SssSampleBudget, data.sampleBudget);
					ctx.cmd.SetComputeTextureParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._DepthTexture, data.depthTexture);
					ctx.cmd.SetComputeTextureParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._IrradianceSource, data.diffuseBuffer);
					ctx.cmd.SetComputeTextureParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._SSSBufferTexture, data.sssBuffer);
					ctx.cmd.SetComputeBufferParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._CoarseStencilBuffer, data.coarseStencilBuffer);
					if (data.needTemporaryBuffer)
					{
						ctx.cmd.SetComputeTextureParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._CameraFilteringBuffer, data.cameraFilteringBuffer);
						ctx.cmd.DispatchCompute(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, data.numTilesX, data.numTilesY, data.numTilesZ);
						data.combineLighting.SetTexture(HDShaderIDs._IrradianceSource, data.cameraFilteringBuffer);
						HDUtils.DrawFullScreen(ctx.cmd, data.combineLighting, data.colorBuffer, data.depthStencilBuffer);
					}
					else
					{
						ctx.cmd.SetComputeTextureParam(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, HDShaderIDs._CameraColorTexture, data.colorBuffer);
						ctx.cmd.DispatchCompute(data.subsurfaceScatteringCS, data.subsurfaceScatteringCSKernel, data.numTilesX, data.numTilesY, data.numTilesZ);
					}
				});
				return passData.colorBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderSubsurfaceScattering(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle historyValidationTexture, ref LightingBuffers lightingBuffers, ref PrepassOutput prepassOutput)
		{
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SubsurfaceScattering))
			{
				lightingBuffers.diffuseLightingBuffer = ResolveMSAAColor(m_RenderGraph, hdCamera, lightingBuffers.diffuseLightingBuffer);
				lightingBuffers.sssBuffer = ResolveMSAAColor(m_RenderGraph, hdCamera, lightingBuffers.sssBuffer);
				SubSurfaceScattering component = hdCamera.volumeStack.GetComponent<SubSurfaceScattering>();
				if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && component.rayTracing.value && GetRayTracingState() && GetRayTracingClusterState())
				{
					RenderSubsurfaceScatteringRT(m_RenderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.normalBuffer, colorBuffer, lightingBuffers.sssBuffer, lightingBuffers.diffuseLightingBuffer, prepassOutput.motionVectorsBuffer, historyValidationTexture, lightingBuffers.ssgiLightingBuffer);
				}
				else
				{
					RenderSubsurfaceScatteringScreenSpace(m_RenderGraph, hdCamera, colorBuffer, in lightingBuffers, ref prepassOutput);
				}
			}
		}

		public bool IsVolumetricCloudUsable()
		{
			if (currentAsset != null)
			{
				return currentAsset.currentPlatformRenderPipelineSettings.supportVolumetricClouds;
			}
			return false;
		}

		private void InitPathTracing()
		{
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true);
			desc.colorFormat = GraphicsFormat.R32G32B32A32_SFloat;
			desc.useMipMap = false;
			desc.autoGenerateMips = false;
			desc.name = "PathTracingFrameBuffer";
			desc.enableRandomWrite = true;
			m_FrameTexture = m_RenderGraph.CreateSharedTexture(in desc);
			desc.name = "PathTracingSkyBackgroundBuffer";
			desc.enableRandomWrite = false;
			m_SkyBGTexture = m_RenderGraph.CreateSharedTexture(in desc);
			desc.name = "PathTracingSkySamplingBuffer";
			desc.colorFormat = GraphicsFormat.R32_SFloat;
			desc.dimension = TextureDimension.Tex2D;
			desc.enableRandomWrite = true;
			desc.useDynamicScale = false;
			desc.slices = 1;
			desc.sizeMode = TextureSizeMode.Explicit;
			m_skySamplingSize = (int)m_Asset.currentPlatformRenderPipelineSettings.lightLoopSettings.skyReflectionSize * 2;
			desc.width = m_skySamplingSize * 2;
			desc.height = m_skySamplingSize;
			m_SkyCDFTexture = m_RenderGraph.CreateSharedTexture(in desc, explicitRelease: true);
			desc.width = m_skySamplingSize;
			desc.height = 1;
			m_SkyMarginalTexture = m_RenderGraph.CreateSharedTexture(in desc, explicitRelease: true);
			pathTracedAOVs = new List<Tuple<TextureHandle, HDCameraFrameHistoryType>>(3);
		}

		private void ReleasePathTracing()
		{
			m_RenderGraph.ReleaseSharedTexture(m_SkyCDFTexture);
			m_RenderGraph.ReleaseSharedTexture(m_SkyMarginalTexture);
		}

		public void ResetPathTracing()
		{
			m_RenderSky = true;
			m_SubFrameManager.Reset();
		}

		public void ResetPathTracing(HDCamera hdCamera)
		{
			int instanceID = hdCamera.camera.GetInstanceID();
			CameraData cameraData = m_SubFrameManager.GetCameraData(instanceID);
			ResetPathTracing(instanceID, cameraData);
		}

		internal CameraData ResetPathTracing(int camID, CameraData camData)
		{
			m_RenderSky = true;
			camData.ResetIteration();
			m_SubFrameManager.SetCameraData(camID, camData);
			return camData;
		}

		private Vector4 ComputeDoFConstants(HDCamera hdCamera, PathTracing settings)
		{
			DepthOfField component = hdCamera.volumeStack.GetComponent<DepthOfField>();
			float x = ((component.focusMode.value == DepthOfFieldMode.UsePhysicalCamera && hdCamera.camera.cameraType != CameraType.SceneView && hdCamera.camera.aperture > 0f) ? (0.0005f * hdCamera.camera.focalLength / hdCamera.camera.aperture) : 0f);
			float y = ((component.focusDistanceMode.value == FocusDistanceMode.Volume) ? component.focusDistance.value : hdCamera.camera.focusDistance);
			return new Vector4(x, y, 0f, 0f);
		}

		private bool IsSkySamplingEnabled(HDCamera hdCamera)
		{
			return m_PathTracingSettings.skyImportanceSampling.value switch
			{
				SkyImportanceSamplingMode.On => true, 
				SkyImportanceSamplingMode.Off => false, 
				_ => hdCamera.volumeStack.GetComponent<VisualEnvironment>().skyType.value == 1, 
			};
		}

		private AccelerationStructureSize GetAccelerationStructureSize(HDCamera hdCamera)
		{
			RayTracingAccelerationStructure rayTracingAccelerationStructure = RequestAccelerationStructure(hdCamera);
			AccelerationStructureSize result = default(AccelerationStructureSize);
			result.memUsage = rayTracingAccelerationStructure?.GetSize() ?? 0;
			result.instCount = rayTracingAccelerationStructure?.GetInstanceCount() ?? 0;
			return result;
		}

		private CameraData CheckDirtiness(HDCamera hdCamera, int camID, CameraData camData)
		{
			bool flag = false;
			if (hdCamera.actualWidth != camData.width || hdCamera.actualHeight != camData.height)
			{
				camData.width = (uint)hdCamera.actualWidth;
				camData.height = (uint)hdCamera.actualHeight;
				flag = true;
			}
			bool flag2 = hdCamera.clearColorMode == HDAdditionalCameraData.ClearColorMode.Sky;
			if (flag2 != camData.skyEnabled)
			{
				camData.skyEnabled = flag2;
				flag = true;
			}
			flag2 = Fog.IsFogEnabled(hdCamera);
			if (flag2 != camData.fogEnabled)
			{
				camData.fogEnabled = flag2;
				flag = true;
			}
			AccelerationStructureSize accelerationStructureSize = GetAccelerationStructureSize(hdCamera);
			if (accelerationStructureSize != camData.accelSize)
			{
				camData.accelSize = accelerationStructureSize;
				flag = true;
			}
			bool flag3 = false;
			if (GetMaterialDirtiness(hdCamera))
			{
				ResetMaterialDirtiness(hdCamera);
				flag3 = true;
			}
			if (GetTransformDirtiness(hdCamera))
			{
				ResetTransformDirtiness(hdCamera);
				flag3 = true;
			}
			if (m_CacheLightCount != m_RayTracingLights.lightCount)
			{
				m_CacheLightCount = (uint)m_RayTracingLights.lightCount;
				flag3 = true;
			}
			if (hdCamera.mainViewConstants.nonJitteredViewProjMatrix != hdCamera.mainViewConstants.prevViewProjMatrix)
			{
				flag = true;
			}
			if (camID != m_CameraID)
			{
				m_RenderSky = true;
				m_CameraID = camID;
			}
			if (flag3)
			{
				ResetPathTracing();
				return m_SubFrameManager.GetCameraData(camID);
			}
			if (flag)
			{
				return ResetPathTracing(camID, camData);
			}
			return camData;
		}

		private static RTHandle PathTracingHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R32G32B32A32_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_PathTracingHistoryBuffer{frameIndex}");
		}

		private void RenderPathTracingFrame(RenderGraph renderGraph, HDCamera hdCamera, in CameraData cameraData, TextureHandle pathTracingBuffer, TextureHandle albedo, TextureHandle normal, TextureHandle motionVector)
		{
			RenderPathTracingData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderPathTracingData>("Render Path Tracing Frame", out passData);
			passData.shader = m_GlobalSettings.renderPipelineRayTracingResources.pathTracingRT;
			passData.cameraData = cameraData;
			passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet256SPP();
			passData.backgroundColor = hdCamera.backgroundColorHDR;
			passData.pixelCoordToViewDirWS = hdCamera.mainViewConstants.pixelCoordToViewDirWS;
			passData.dofParameters = ComputeDoFConstants(hdCamera, m_PathTracingSettings);
			passData.tilingParameters = m_PathTracingSettings.tilingParameters.value;
			passData.width = hdCamera.actualWidth;
			passData.height = hdCamera.actualHeight;
			passData.skySize = (IsSkySamplingEnabled(hdCamera) ? m_skySamplingSize : 0);
			passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
			passData.lightCluster = RequestLightCluster();
			passData.shaderVariablesRaytracingCB = m_ShaderVariablesRayTracingCB;
			passData.shaderVariablesRaytracingCB._RaytracingNumSamples = (int)m_SubFrameManager.subFrameCount;
			passData.shaderVariablesRaytracingCB._RaytracingMinRecursion = m_PathTracingSettings.minimumDepth.value;
			passData.shaderVariablesRaytracingCB._RaytracingMaxRecursion = m_PathTracingSettings.maximumDepth.value;
			passData.shaderVariablesRaytracingCB._RaytracingIntensityClamp = m_PathTracingSettings.maximumIntensity.value;
			passData.shaderVariablesRaytracingCB._RaytracingSampleIndex = (int)cameraData.currentIteration;
			passData.skyReflection = m_SkyManager.GetSkyReflection(hdCamera);
			passData.skyBG = renderGraphBuilder.ReadTexture(in m_SkyBGTexture);
			passData.skyCDF = renderGraphBuilder.ReadTexture(in m_SkyCDFTexture);
			passData.skyMarginal = renderGraphBuilder.ReadTexture(in m_SkyMarginalTexture);
			passData.output = renderGraphBuilder.WriteTexture(in pathTracingBuffer);
			passData.enableAOVs = albedo.IsValid() && normal.IsValid() && motionVector.IsValid();
			if (passData.enableAOVs)
			{
				passData.albedoAOV = renderGraphBuilder.WriteTexture(in albedo);
				passData.normalAOV = renderGraphBuilder.WriteTexture(in normal);
				passData.motionVectorAOV = renderGraphBuilder.WriteTexture(in motionVector);
			}
			renderGraphBuilder.SetRenderFunc(delegate(RenderPathTracingData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetRayTracingShaderPass(data.shader, "PathTracingDXR");
				ctx.cmd.SetRayTracingAccelerationStructure(data.shader, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
				BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
				ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRaytracingCB, HDShaderIDs._ShaderVariablesRaytracing);
				ctx.cmd.SetGlobalBuffer(HDShaderIDs._RaytracingLightCluster, data.lightCluster.GetCluster());
				ctx.cmd.SetGlobalBuffer(HDShaderIDs._LightDatasRT, data.lightCluster.GetLightDatas());
				ctx.cmd.SetGlobalInt(HDShaderIDs._PathTracingCameraSkyEnabled, data.cameraData.skyEnabled ? 1 : 0);
				ctx.cmd.SetGlobalInt(HDShaderIDs._PathTracingSkyTextureWidth, 2 * data.skySize);
				ctx.cmd.SetGlobalInt(HDShaderIDs._PathTracingSkyTextureHeight, data.skySize);
				ctx.cmd.SetGlobalTexture(HDShaderIDs._SkyTexture, data.skyReflection);
				ctx.cmd.SetGlobalTexture(HDShaderIDs._SkyCameraTexture, data.skyBG);
				ctx.cmd.SetGlobalTexture(HDShaderIDs._PathTracingSkyCDFTexture, data.skyCDF);
				ctx.cmd.SetGlobalTexture(HDShaderIDs._PathTracingSkyMarginalTexture, data.skyMarginal);
				ctx.cmd.SetRayTracingVectorParam(data.shader, HDShaderIDs._PathTracingCameraClearColor, data.backgroundColor);
				ctx.cmd.SetRayTracingTextureParam(data.shader, HDShaderIDs._FrameTexture, data.output);
				ctx.cmd.SetRayTracingMatrixParam(data.shader, HDShaderIDs._PixelCoordToViewDirWS, data.pixelCoordToViewDirWS);
				ctx.cmd.SetRayTracingVectorParam(data.shader, HDShaderIDs._PathTracingDoFParameters, data.dofParameters);
				ctx.cmd.SetRayTracingVectorParam(data.shader, HDShaderIDs._PathTracingTilingParameters, data.tilingParameters);
				if (data.enableAOVs)
				{
					ctx.cmd.SetRayTracingTextureParam(data.shader, HDShaderIDs._AlbedoAOV, data.albedoAOV);
					ctx.cmd.SetRayTracingTextureParam(data.shader, HDShaderIDs._NormalAOV, data.normalAOV);
					ctx.cmd.SetRayTracingTextureParam(data.shader, HDShaderIDs._MotionVectorAOV, data.motionVectorAOV);
				}
				ctx.cmd.DispatchRays(data.shader, data.enableAOVs ? "RayGenAOV" : "RayGen", (uint)data.width, (uint)data.height, 1u);
			});
		}

		private void RenderSkyBackground(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle skyBuffer)
		{
			if (!m_CurrentDebugDisplaySettings.DebugHideSky(hdCamera))
			{
				SetGlobalTexture(renderGraph, HDShaderIDs._ExposureTexture, m_EmptyExposureTexture);
				m_SkyManager.RenderSky(renderGraph, hdCamera, skyBuffer, CreateDepthBuffer(renderGraph, clear: true, MSAASamples.None), "Render Sky Background for Path Tracing");
				SetGlobalTexture(renderGraph, HDShaderIDs._ExposureTexture, GetExposureTexture(hdCamera));
			}
		}

		private void RenderSkySamplingData(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (!m_GlobalSettings.renderPipelineRayTracingResources.pathTracingSkySamplingDataCS)
			{
				return;
			}
			RenderSkySamplingPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RenderSkySamplingPassData>("Render Sky Sampling Data for Path Tracing", out passData);
			passData.shader = m_GlobalSettings.renderPipelineRayTracingResources.pathTracingSkySamplingDataCS;
			passData.k0 = passData.shader.FindKernel("ComputeCDF");
			passData.k1 = passData.shader.FindKernel("ComputeMarginal");
			passData.size = m_skySamplingSize;
			passData.outputCDF = renderGraphBuilder.WriteTexture(in m_SkyCDFTexture);
			passData.outputMarginal = renderGraphBuilder.WriteTexture(in m_SkyMarginalTexture);
			renderGraphBuilder.SetRenderFunc(delegate(RenderSkySamplingPassData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetComputeIntParam(data.shader, HDShaderIDs._PathTracingSkyTextureWidth, data.size * 2);
				ctx.cmd.SetComputeIntParam(data.shader, HDShaderIDs._PathTracingSkyTextureHeight, data.size);
				ctx.cmd.SetComputeTextureParam(data.shader, data.k0, HDShaderIDs._PathTracingSkyCDFTexture, data.outputCDF);
				ctx.cmd.SetComputeTextureParam(data.shader, data.k0, HDShaderIDs._PathTracingSkyMarginalTexture, data.outputMarginal);
				ctx.cmd.DispatchCompute(data.shader, data.k0, 1, data.size, 1);
				ctx.cmd.SetComputeTextureParam(data.shader, data.k1, HDShaderIDs._PathTracingSkyMarginalTexture, data.outputMarginal);
				ctx.cmd.DispatchCompute(data.shader, data.k1, 1, 1, 1);
			});
		}

		private TextureHandle RenderPathTracing(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer)
		{
			m_PathTracingSettings = hdCamera.volumeStack.GetComponent<PathTracing>();
			if (!m_GlobalSettings.renderPipelineRayTracingResources.pathTracingRT || !m_PathTracingSettings.enable.value)
			{
				return TextureHandle.nullHandle;
			}
			TextureHandle nullHandle = TextureHandle.nullHandle;
			TextureHandle nullHandle2 = TextureHandle.nullHandle;
			TextureHandle nullHandle3 = TextureHandle.nullHandle;
			int instanceID = hdCamera.camera.GetInstanceID();
			CameraData cameraData = m_SubFrameManager.GetCameraData(instanceID);
			if (!hdCamera.isPersistent && hdCamera.GetCurrentFrameRT(17) == null)
			{
				m_SubFrameManager.Reset(instanceID);
			}
			if (!m_SubFrameManager.isRecording)
			{
				cameraData = CheckDirtiness(hdCamera, instanceID, cameraData);
				m_SubFrameManager.subFrameCount = (uint)m_PathTracingSettings.maximumSamples.value;
			}
			else
			{
				cameraData.skyEnabled = hdCamera.clearColorMode == HDAdditionalCameraData.ClearColorMode.Sky;
				m_SubFrameManager.SetCameraData(instanceID, cameraData);
			}
			if (cameraData.currentIteration < m_SubFrameManager.subFrameCount)
			{
				if (m_RenderSky || m_SubFrameManager.isRecording)
				{
					RenderSkyBackground(m_RenderGraph, hdCamera, m_SkyBGTexture);
					m_RenderSky = false;
					if (IsSkySamplingEnabled(hdCamera) && m_SkyHash != hdCamera.lightingSky.skyParametersHash)
					{
						RenderSkySamplingData(m_RenderGraph, hdCamera);
						m_SkyHash = hdCamera.lightingSky.skyParametersHash;
					}
				}
				RenderPathTracingFrame(m_RenderGraph, hdCamera, in cameraData, m_FrameTexture, nullHandle2, nullHandle3, nullHandle);
			}
			RenderAccumulation(m_RenderGraph, hdCamera, m_FrameTexture, colorBuffer, pathTracedAOVs, needExposure: true);
			RenderDenoisePass(m_RenderGraph, hdCamera, colorBuffer);
			return colorBuffer;
		}

		internal bool GetMaterialDirtiness(HDCamera hdCamera)
		{
			if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
			{
				return m_RTASManager.materialsDirty;
			}
			return hdCamera.materialsDirty;
		}

		internal void ResetMaterialDirtiness(HDCamera hdCamera)
		{
			if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
			{
				m_RTASManager.materialsDirty = false;
			}
			else
			{
				hdCamera.materialsDirty = false;
			}
		}

		internal bool GetTransformDirtiness(HDCamera hdCamera)
		{
			if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
			{
				return m_RTASManager.transformsDirty;
			}
			return hdCamera.transformsDirty;
		}

		internal void ResetTransformDirtiness(HDCamera hdCamera)
		{
			if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
			{
				m_RTASManager.transformsDirty = false;
			}
			else
			{
				hdCamera.transformsDirty = false;
			}
		}

		internal void InitRayTracingManager()
		{
			m_RayCountManager = new RayCountManager();
			m_RayCountManager.Init(m_GlobalSettings.renderPipelineRayTracingResources);
			m_RayTracingLightCluster = new HDRaytracingLightCluster();
			m_RayTracingLightCluster.Initialize(this);
			m_RTASManager = new HDRTASManager();
			m_RTASManager.Initialize();
		}

		internal void ReleaseRayTracingManager()
		{
			if (m_RTASManager != null)
			{
				m_RTASManager.ReleaseResources();
			}
			if (m_RayTracingLightCluster != null)
			{
				m_RayTracingLightCluster.ReleaseResources();
			}
			if (m_RayCountManager != null)
			{
				m_RayCountManager.Release();
			}
			if (m_ReflectionDenoiser != null)
			{
				m_ReflectionDenoiser.Release();
			}
			if (m_TemporalFilter != null)
			{
				m_TemporalFilter.Release();
			}
			if (m_DiffuseShadowDenoiser != null)
			{
				m_DiffuseShadowDenoiser.Release();
			}
			if (m_DiffuseDenoiser != null)
			{
				m_DiffuseDenoiser.Release();
			}
		}

		private static bool IsValidRayTracedMaterial(Material currentMaterial)
		{
			if (currentMaterial == null || currentMaterial.shader == null)
			{
				return false;
			}
			if (currentMaterial.GetTag("RenderPipeline", searchFallbacks: false) == "HDRenderPipeline")
			{
				return !DecalSystem.IsDecalMaterial(currentMaterial);
			}
			return false;
		}

		private static bool IsTransparentMaterial(Material currentMaterial)
		{
			if (!currentMaterial.IsKeywordEnabled("_SURFACE_TYPE_TRANSPARENT"))
			{
				if (HDRenderQueue.k_RenderQueue_Transparent.lowerBound <= currentMaterial.renderQueue)
				{
					return HDRenderQueue.k_RenderQueue_Transparent.upperBound >= currentMaterial.renderQueue;
				}
				return false;
			}
			return true;
		}

		private static bool IsAlphaTestedMaterial(Material currentMaterial)
		{
			if (!currentMaterial.IsKeywordEnabled("_ALPHATEST_ON"))
			{
				if (HDRenderQueue.k_RenderQueue_OpaqueAlphaTest.lowerBound <= currentMaterial.renderQueue)
				{
					return HDRenderQueue.k_RenderQueue_OpaqueAlphaTest.upperBound >= currentMaterial.renderQueue;
				}
				return false;
			}
			return true;
		}

		private static bool UpdateMaterialCRC(int matInstanceId, int matCRC)
		{
			if (m_MaterialCRCs.TryGetValue(matInstanceId, out var value))
			{
				m_MaterialCRCs[matInstanceId] = matCRC;
				return matCRC != value;
			}
			m_MaterialCRCs.Add(matInstanceId, matCRC);
			return true;
		}

		public static AccelerationStructureStatus AddInstanceToRAS(RayTracingAccelerationStructure targetRTAS, Renderer currentRenderer, HDEffectsParameters effectsParameters, ref bool transformDirty, ref bool materialsDirty)
		{
			currentRenderer.GetSharedMaterials(materialArray);
			if (materialArray == null)
			{
				return AccelerationStructureStatus.NullMaterial;
			}
			int num = 1;
			if (!(currentRenderer.GetType() == typeof(SkinnedMeshRenderer)))
			{
				currentRenderer.TryGetComponent<MeshFilter>(out var component);
				if (component == null || component.sharedMesh == null)
				{
					return AccelerationStructureStatus.MissingMesh;
				}
				num = component.sharedMesh.subMeshCount;
			}
			else
			{
				SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)currentRenderer;
				if (skinnedMeshRenderer.sharedMesh == null)
				{
					return AccelerationStructureStatus.MissingMesh;
				}
				num = skinnedMeshRenderer.sharedMesh.subMeshCount;
			}
			num = Mathf.Min(num, 32);
			int num2 = 1 << currentRenderer.gameObject.layer;
			uint num3 = 0u;
			bool flag = false;
			bool flag2 = true;
			bool flag3 = false;
			bool flag4 = effectsParameters.shadows && !effectsParameters.pathTracing;
			bool flag5 = effectsParameters.pathTracing && (effectsParameters.ptLayerMask & num2) != 0;
			for (int i = 0; i < num; i++)
			{
				bool flag6 = false;
				if (materialArray.Count > i)
				{
					Material material = materialArray[i];
					if (IsValidRayTracedMaterial(material))
					{
						flag6 = true;
						subMeshFlagArray[i] = RayTracingSubMeshFlags.Enabled;
						bool flag7 = IsAlphaTestedMaterial(material);
						bool flag8 = IsTransparentMaterial(material);
						flag2 = flag2 && flag8;
						flag3 = flag3 || flag8;
						if (!flag8 && !flag7)
						{
							subMeshFlagArray[i] |= RayTracingSubMeshFlags.ClosestHitOnly;
						}
						else if (flag8)
						{
							subMeshFlagArray[i] |= RayTracingSubMeshFlags.UniqueAnyHitCalls;
						}
						flag |= material.doubleSidedGI || material.IsKeywordEnabled("_DOUBLESIDED_ON");
						if (!materialsDirty)
						{
							materialsDirty |= UpdateMaterialCRC(material.GetInstanceID(), material.ComputeCRC());
						}
					}
				}
				if (!flag6)
				{
					subMeshFlagArray[i] = RayTracingSubMeshFlags.Disabled;
				}
			}
			if (!flag2 && flag3)
			{
				for (int j = 0; j < num; j++)
				{
					subMeshFlagArray[j] = RayTracingSubMeshFlags.Enabled | RayTracingSubMeshFlags.UniqueAnyHitCalls;
				}
			}
			if (!flag3)
			{
				num3 |= 1u;
			}
			if (flag4 || flag5)
			{
				num3 = ((!flag3) ? (num3 | ((currentRenderer.shadowCastingMode != 0) ? 4u : 0u)) : (num3 | ((currentRenderer.shadowCastingMode != 0) ? 2u : 0u)));
			}
			bool flag9 = currentRenderer.shadowCastingMode != ShadowCastingMode.ShadowsOnly;
			if (effectsParameters.ambientOcclusion && !flag2 && flag9)
			{
				num3 |= (((effectsParameters.aoLayerMask & num2) != 0) ? 8u : 0u);
			}
			if (effectsParameters.reflections && !flag2 && flag9)
			{
				num3 |= (((effectsParameters.reflLayerMask & num2) != 0) ? 16u : 0u);
			}
			if (effectsParameters.globalIllumination && !flag2 && flag9)
			{
				num3 |= (((effectsParameters.giLayerMask & num2) != 0) ? 32u : 0u);
			}
			if (effectsParameters.recursiveRendering && flag9)
			{
				num3 |= (((effectsParameters.recursiveLayerMask & num2) != 0) ? 64u : 0u);
			}
			if (effectsParameters.pathTracing && flag9)
			{
				num3 |= 0x80u;
			}
			if (num3 == 0)
			{
				return AccelerationStructureStatus.Added;
			}
			targetRTAS.AddInstance(currentRenderer, subMeshFlagArray, !flag, frontTriangleCounterClockwise: false, num3);
			transformDirty |= currentRenderer.transform.hasChanged;
			currentRenderer.transform.hasChanged = false;
			if (!(!flag2 && flag3))
			{
				return AccelerationStructureStatus.Added;
			}
			return AccelerationStructureStatus.TransparencyIssue;
		}

		private void CollectLightsForRayTracing(HDCamera hdCamera, ref bool transformDirty)
		{
			HDLightRenderDatabase instance = HDLightRenderDatabase.instance;
			for (int i = 0; i < instance.lightCount; i++)
			{
				HDLightRenderEntity item = instance.lightEntities[i];
				HDAdditionalLightData hDAdditionalLightData = instance.hdAdditionalLightData[i];
				if (!(hDAdditionalLightData != null) || !hDAdditionalLightData.enabled || !(hDAdditionalLightData != HDUtils.s_DefaultHDAdditionalLightData))
				{
					continue;
				}
				Light component = hDAdditionalLightData.gameObject.GetComponent<Light>();
				if (component == null || !component.enabled || (!hdCamera.volumeStack.GetComponent<PathTracing>().enable.value && component.bakingOutput.lightmapBakeType == LightmapBakeType.Baked && component.bakingOutput.isBaked) || (hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) && !hDAdditionalLightData.includeForRayTracing))
				{
					continue;
				}
				bool flag = false;
				transformDirty |= hDAdditionalLightData.transform.hasChanged;
				hDAdditionalLightData.transform.hasChanged = false;
				switch (hDAdditionalLightData.type)
				{
				case HDLightType.Directional:
					flag = hDAdditionalLightData.ShadowsEnabled() && hDAdditionalLightData.useScreenSpaceShadows && hDAdditionalLightData.useRayTracedShadows;
					m_RayTracingLights.hdDirectionalLightArray.Add(hDAdditionalLightData);
					break;
				case HDLightType.Spot:
				case HDLightType.Point:
					flag = hDAdditionalLightData.ShadowsEnabled() && hDAdditionalLightData.useRayTracedShadows;
					m_RayTracingLights.hdPointLightArray.Add(item);
					break;
				case HDLightType.Area:
					flag = hDAdditionalLightData.ShadowsEnabled() && hDAdditionalLightData.useRayTracedShadows;
					switch (hDAdditionalLightData.areaLightShape)
					{
					case AreaLightShape.Rectangle:
						m_RayTracingLights.hdRectLightArray.Add(item);
						break;
					case AreaLightShape.Tube:
						m_RayTracingLights.hdLineLightArray.Add(item);
						break;
					}
					break;
				}
				m_RayTracedShadowsRequired |= flag;
				m_RayTracedContactShadowsRequired |= hDAdditionalLightData.useContactShadow.@override && hDAdditionalLightData.rayTraceContactShadow;
			}
			m_RayTracingLights.hdLightEntityArray.AddRange(m_RayTracingLights.hdPointLightArray);
			m_RayTracingLights.hdLightEntityArray.AddRange(m_RayTracingLights.hdLineLightArray);
			m_RayTracingLights.hdLightEntityArray.AddRange(m_RayTracingLights.hdRectLightArray);
			HDAdditionalReflectionData[] array = Object.FindObjectsByType<HDAdditionalReflectionData>(FindObjectsSortMode.None);
			foreach (HDAdditionalReflectionData hDAdditionalReflectionData in array)
			{
				if (hDAdditionalReflectionData != null && hDAdditionalReflectionData.enabled && hDAdditionalReflectionData.ReflectionProbeIsEnabled() && hDAdditionalReflectionData.gameObject.activeSelf && hDAdditionalReflectionData.HasValidRenderedData())
				{
					m_RayTracingLights.reflectionProbeArray.Add(hDAdditionalReflectionData);
				}
			}
			m_RayTracingLights.lightCount = m_RayTracingLights.hdPointLightArray.Count + m_RayTracingLights.hdLineLightArray.Count + m_RayTracingLights.hdRectLightArray.Count + m_RayTracingLights.reflectionProbeArray.Count;
		}

		public static HDEffectsParameters EvaluateEffectsParameters(HDCamera hdCamera, bool rayTracedShadows, bool rayTracedContactShadows)
		{
			HDEffectsParameters result = default(HDEffectsParameters);
			result.shadows = hdCamera.frameSettings.IsEnabled(FrameSettingsField.ScreenSpaceShadows) && (rayTracedShadows || rayTracedContactShadows);
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			result.ambientOcclusion = component.rayTracing.value && hdCamera.frameSettings.IsEnabled(FrameSettingsField.SSAO);
			result.aoLayerMask = component.layerMask.value;
			ScreenSpaceReflection component2 = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			bool flag = hdCamera.frameSettings.IsEnabled(FrameSettingsField.SSR) && component2.enabled.value;
			bool flag2 = hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentSSR) && component2.enabledTransparent.value;
			result.reflections = ScreenSpaceReflection.RayTracingActive(component2) && (flag || flag2);
			result.reflLayerMask = component2.layerMask.value;
			GlobalIllumination component3 = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			result.globalIllumination = component3.enable.value && GlobalIllumination.RayTracingActive(component3) && hdCamera.frameSettings.IsEnabled(FrameSettingsField.SSGI);
			result.giLayerMask = component3.layerMask.value;
			RecursiveRendering component4 = hdCamera.volumeStack.GetComponent<RecursiveRendering>();
			result.recursiveRendering = component4.enable.value;
			result.recursiveLayerMask = component4.layerMask.value;
			SubSurfaceScattering component5 = hdCamera.volumeStack.GetComponent<SubSurfaceScattering>();
			result.subSurface = component5.rayTracing.value && hdCamera.frameSettings.IsEnabled(FrameSettingsField.SubsurfaceScattering);
			PathTracing component6 = hdCamera.volumeStack.GetComponent<PathTracing>();
			result.pathTracing = component6.enable.value;
			result.ptLayerMask = component6.layerMask.value;
			result.rayTracingRequired = result.ambientOcclusion || result.reflections || result.globalIllumination || result.recursiveRendering || result.subSurface || result.pathTracing || result.shadows;
			return result;
		}

		internal void BuildRayTracingAccelerationStructure(HDCamera hdCamera)
		{
			m_RTASManager.Reset();
			m_RayTracingLights.Reset();
			m_ValidRayTracingState = false;
			m_ValidRayTracingCluster = false;
			m_ValidRayTracingClusterCulling = false;
			m_RayTracedShadowsRequired = false;
			m_RayTracedContactShadowsRequired = false;
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing))
			{
				return;
			}
			CollectLightsForRayTracing(hdCamera, ref m_RTASManager.transformsDirty);
			HDEffectsParameters parameters = EvaluateEffectsParameters(hdCamera, m_RayTracedShadowsRequired, m_RayTracedContactShadowsRequired);
			if (!parameters.rayTracingRequired)
			{
				return;
			}
			if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
			{
				RayTracingInstanceCullingResults rayTracingInstanceCullingResults = m_RTASManager.Cull(hdCamera, in parameters);
				if (parameters.pathTracing)
				{
					m_RTASManager.transformsDirty |= rayTracingInstanceCullingResults.transformsChanged;
					for (int i = 0; i < rayTracingInstanceCullingResults.materialsCRC.Length; i++)
					{
						RayTracingInstanceMaterialCRC rayTracingInstanceMaterialCRC = rayTracingInstanceCullingResults.materialsCRC[i];
						m_RTASManager.materialsDirty |= UpdateMaterialCRC(rayTracingInstanceMaterialCRC.instanceID, rayTracingInstanceMaterialCRC.crc);
					}
				}
				m_RTASManager.Build(hdCamera);
				m_ValidRayTracingState = true;
			}
			else if (hdCamera.rayTracingAccelerationStructure != null)
			{
				m_ValidRayTracingState = true;
			}
		}

		private static uint LayerFromRTASDebugView(RTASDebugView debugView, HDCamera hdCamera)
		{
			return debugView switch
			{
				RTASDebugView.Shadows => 6u, 
				RTASDebugView.AmbientOcclusion => 8u, 
				RTASDebugView.GlobalIllumination => 32u, 
				RTASDebugView.Reflections => 16u, 
				RTASDebugView.RecursiveRayTracing => 64u, 
				RTASDebugView.PathTracing => 128u, 
				_ => 255u, 
			};
		}

		internal void EvaluateRTASDebugView(RenderGraph renderGraph, HDCamera hdCamera)
		{
			if (!m_ValidRayTracingState)
			{
				return;
			}
			RTASDebugPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RTASDebugPassData>("Debug view of the RTAS", out passData, ProfilingSampler.Get(HDProfileId.RaytracingBuildAccelerationStructureDebug));
			try
			{
				new RTASDebugPassData();
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.actualWidth = hdCamera.actualWidth;
				passData.actualHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.debugMode = (int)m_CurrentDebugDisplaySettings.data.rtasDebugMode;
				passData.layerMask = LayerFromRTASDebugView(m_CurrentDebugDisplaySettings.data.rtasDebugView, hdCamera);
				passData.pixelCoordToViewDirWS = hdCamera.mainViewConstants.pixelCoordToViewDirWS;
				passData.debugRTASRT = m_GlobalSettings.renderPipelineRayTracingResources.rtasDebug;
				passData.rayTracingAccelerationStructure = RequestAccelerationStructure(hdCamera);
				RTASDebugPassData rTASDebugPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "RTAS Debug"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				rTASDebugPassData.outputTexture = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RTASDebugPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetRayTracingShaderPass(data.debugRTASRT, "DebugDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.debugRTASRT, HDShaderIDs._RaytracingAccelerationStructureName, data.rayTracingAccelerationStructure);
					ctx.cmd.SetRayTracingIntParam(data.debugRTASRT, "_DebugMode", data.debugMode);
					ctx.cmd.SetRayTracingIntParam(data.debugRTASRT, "_LayerMask", (int)data.layerMask);
					ctx.cmd.SetRayTracingMatrixParam(data.debugRTASRT, HDShaderIDs._PixelCoordToViewDirWS, data.pixelCoordToViewDirWS);
					ctx.cmd.SetRayTracingTextureParam(data.debugRTASRT, "_OutputDebugBuffer", data.outputTexture);
					ctx.cmd.DispatchRays(data.debugRTASRT, m_RTASDebugRTKernel, (uint)data.actualWidth, (uint)data.actualHeight, (uint)data.viewCount);
				});
				PushFullScreenDebugTexture(renderGraph, passData.outputTexture, FullScreenDebugMode.RayTracingAccelerationStructure);
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		internal static int RayTracingFrameIndex(HDCamera hdCamera)
		{
			return (int)hdCamera.GetCameraFrameCount() % 8;
		}

		internal int RayTracingFrameIndex(HDCamera hdCamera, int targetFrameCount = 8)
		{
			return (int)hdCamera.GetCameraFrameCount() % targetFrameCount;
		}

		internal bool RayTracingLightClusterRequired(HDCamera hdCamera)
		{
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			GlobalIllumination component2 = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			RecursiveRendering component3 = hdCamera.volumeStack.GetComponent<RecursiveRendering>();
			PathTracing component4 = hdCamera.volumeStack.GetComponent<PathTracing>();
			SubSurfaceScattering component5 = hdCamera.volumeStack.GetComponent<SubSurfaceScattering>();
			if (m_ValidRayTracingState)
			{
				if (!ScreenSpaceReflection.RayTracingActive(component) && !GlobalIllumination.RayTracingActive(component2) && !component3.enable.value && !component4.enable.value)
				{
					return component5.rayTracing.value;
				}
				return true;
			}
			return false;
		}

		internal void CullForRayTracing(CommandBuffer cmd, HDCamera hdCamera)
		{
			if (m_ValidRayTracingState && RayTracingLightClusterRequired(hdCamera))
			{
				m_RayTracingLightCluster.CullForRayTracing(hdCamera, m_RayTracingLights);
				m_ValidRayTracingClusterCulling = true;
			}
		}

		internal void ReserveRayTracingCookieAtlasSlots()
		{
			if (m_ValidRayTracingState && m_ValidRayTracingClusterCulling)
			{
				m_RayTracingLightCluster.ReserveCookieAtlasSlots(m_RayTracingLights);
			}
		}

		internal void BuildRayTracingLightData(CommandBuffer cmd, HDCamera hdCamera, DebugDisplaySettings debugDisplaySettings)
		{
			if (m_ValidRayTracingState && m_ValidRayTracingClusterCulling)
			{
				m_RayTracingLightCluster.BuildRayTracingLightData(cmd, hdCamera, m_RayTracingLights, debugDisplaySettings);
				m_ValidRayTracingCluster = true;
				UpdateShaderVariablesRaytracingLightLoopCB(hdCamera, cmd);
				m_RayTracingLightCluster.BuildLightClusterBuffer(cmd, hdCamera, m_RayTracingLights);
			}
		}

		internal static float EvaluateHistoryValidity(HDCamera hdCamera)
		{
			return 1f;
		}

		internal bool RayTracingHalfResAllowed()
		{
			return DynamicResolutionHandler.instance.GetCurrentScale() >= currentPlatformRenderPipelineSettings.dynamicResolutionSettings.rayTracingHalfResThreshold / 100f;
		}

		internal static Vector4 EvaluateRayTracingHistorySizeAndScale(HDCamera hdCamera, RTHandle buffer)
		{
			return new Vector4(hdCamera.historyRTHandleProperties.previousViewportSize.x, hdCamera.historyRTHandleProperties.previousViewportSize.y, (float)hdCamera.historyRTHandleProperties.previousViewportSize.x / (float)buffer.rt.width, (float)hdCamera.historyRTHandleProperties.previousViewportSize.y / (float)buffer.rt.height);
		}

		private void UpdateShaderVariablesRaytracingLightLoopCB(HDCamera hdCamera, CommandBuffer cmd)
		{
			m_ShaderVariablesRaytracingLightLoopCB._MinClusterPos = m_RayTracingLightCluster.GetMinClusterPos();
			m_ShaderVariablesRaytracingLightLoopCB._LightPerCellCount = (uint)m_RayTracingLightCluster.GetLightPerCellCount();
			m_ShaderVariablesRaytracingLightLoopCB._MaxClusterPos = m_RayTracingLightCluster.GetMaxClusterPos();
			m_ShaderVariablesRaytracingLightLoopCB._PunctualLightCountRT = (uint)m_RayTracingLightCluster.GetPunctualLightCount();
			m_ShaderVariablesRaytracingLightLoopCB._AreaLightCountRT = (uint)m_RayTracingLightCluster.GetAreaLightCount();
			m_ShaderVariablesRaytracingLightLoopCB._EnvLightCountRT = (uint)m_RayTracingLightCluster.GetEnvLightCount();
			ConstantBuffer.PushGlobal(cmd, in m_ShaderVariablesRaytracingLightLoopCB, HDShaderIDs._ShaderVariablesRaytracingLightLoop);
		}

		internal bool RayTracedContactShadowsRequired()
		{
			return m_RayTracedContactShadowsRequired;
		}

		internal RayTracingAccelerationStructure RequestAccelerationStructure(HDCamera hdCamera)
		{
			if (m_ValidRayTracingState)
			{
				if (hdCamera.volumeStack.GetComponent<RayTracingSettings>().buildMode.value == RTASBuildMode.Automatic)
				{
					return m_RTASManager.rtas;
				}
				return hdCamera.rayTracingAccelerationStructure;
			}
			return null;
		}

		internal HDRaytracingLightCluster RequestLightCluster()
		{
			if (m_ValidRayTracingCluster)
			{
				return m_RayTracingLightCluster;
			}
			return null;
		}

		internal static bool PipelineSupportsRayTracing(RenderPipelineSettings rpSetting)
		{
			if (rpSetting.supportRayTracing)
			{
				return currentSystemSupportsRayTracing;
			}
			return false;
		}

		internal BlueNoise GetBlueNoiseManager()
		{
			return m_BlueNoise;
		}

		internal HDTemporalFilter GetTemporalFilter()
		{
			if (m_TemporalFilter == null)
			{
				m_TemporalFilter = new HDTemporalFilter();
				m_TemporalFilter.Init(m_GlobalSettings.renderPipelineResources);
			}
			return m_TemporalFilter;
		}

		internal HDDiffuseDenoiser GetDiffuseDenoiser()
		{
			if (m_DiffuseDenoiser == null)
			{
				m_DiffuseDenoiser = new HDDiffuseDenoiser();
				m_DiffuseDenoiser.Init(m_GlobalSettings.renderPipelineResources, this);
			}
			return m_DiffuseDenoiser;
		}

		internal HDReflectionDenoiser GetReflectionDenoiser()
		{
			if (m_ReflectionDenoiser == null)
			{
				m_ReflectionDenoiser = new HDReflectionDenoiser();
				m_ReflectionDenoiser.Init(m_GlobalSettings.renderPipelineRayTracingResources);
			}
			return m_ReflectionDenoiser;
		}

		internal HDDiffuseShadowDenoiser GetDiffuseShadowDenoiser()
		{
			if (m_DiffuseShadowDenoiser == null)
			{
				m_DiffuseShadowDenoiser = new HDDiffuseShadowDenoiser();
				m_DiffuseShadowDenoiser.Init(m_GlobalSettings.renderPipelineRayTracingResources);
			}
			return m_DiffuseShadowDenoiser;
		}

		internal bool GetRayTracingState()
		{
			return m_ValidRayTracingState;
		}

		internal bool GetRayTracingClusterState()
		{
			return m_ValidRayTracingCluster;
		}

		internal static float GetPixelSpreadTangent(float fov, int width, int height)
		{
			return Mathf.Tan(fov * (MathF.PI / 180f) * 0.5f) * 2f / (float)Mathf.Min(width, height);
		}

		internal static float GetPixelSpreadAngle(float fov, int width, int height)
		{
			return Mathf.Atan(GetPixelSpreadTangent(fov, width, height));
		}

		internal TextureHandle EvaluateHistoryValidationBuffer(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorsBuffer)
		{
			HDTemporalFilter temporalFilter = GetTemporalFilter();
			if (temporalFilter != null)
			{
				float historyValidity = EvaluateHistoryValidity(hdCamera);
				return temporalFilter.HistoryValidity(renderGraph, hdCamera, historyValidity, depthBuffer, normalBuffer, motionVectorsBuffer);
			}
			return renderGraph.defaultResources.whiteTexture;
		}

		private void InitRayTracingAmbientOcclusion()
		{
			m_RTAOApplyIntensityKernel = m_GlobalSettings.renderPipelineRayTracingResources.aoRaytracingCS.FindKernel("RTAOApplyIntensity");
		}

		private float EvaluateRayTracedAmbientOcclusionHistoryValidity(HDCamera hdCamera)
		{
			float num = (hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.RayTracedAmbientOcclusion, 2) ? 1f : 0f);
			return EvaluateHistoryValidity(hdCamera) * num;
		}

		private void PropagateRayTracedAmbientOcclusionHistoryValidity(HDCamera hdCamera)
		{
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.RayTracedAmbientOcclusion, 2);
		}

		private float EvaluateRTSpecularOcclusionFlag(HDCamera hdCamera, ScreenSpaceAmbientOcclusion ssoSettings)
		{
			return ssoSettings.specularOcclusion.value;
		}

		private static RTHandle AmbientOcclusionHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_AmbientOcclusionHistoryBuffer{frameIndex}");
		}

		private TextureHandle RenderRTAO(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectors, TextureHandle historyValidationBuffer, TextureHandle rayCountTexture, in ShaderVariablesRaytracing shaderVariablesRaytracing)
		{
			TraceAmbientOcclusionResult traceAOResult = TraceAO(renderGraph, hdCamera, depthBuffer, normalBuffer, rayCountTexture, in shaderVariablesRaytracing);
			TextureHandle aoTexture = DenoiseAO(renderGraph, hdCamera, traceAOResult, depthBuffer, normalBuffer, motionVectors, historyValidationBuffer);
			return ComposeAO(renderGraph, hdCamera, aoTexture);
		}

		private TraceAmbientOcclusionResult TraceAO(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle rayCountTexture, in ShaderVariablesRaytracing shaderVariablesRaytracing)
		{
			TraceRTAOPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TraceRTAOPassData>("Tracing the rays for RTAO", out passData, ProfilingSampler.Get(HDProfileId.RaytracingAmbientOcclusion));
			try
			{
				TraceAmbientOcclusionResult result = default(TraceAmbientOcclusionResult);
				renderGraphBuilder.EnableAsyncCompute(value: false);
				ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
				passData.actualWidth = hdCamera.actualWidth;
				passData.actualHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.rayLength = component.rayLength;
				passData.sampleCount = component.sampleCount;
				passData.denoise = component.denoise;
				passData.occluderMotionRejection = component.occluderMotionRejection.value;
				passData.receiverMotionRejection = component.receiverMotionRejection.value;
				passData.raytracingCB = shaderVariablesRaytracing;
				passData.aoShaderRT = m_GlobalSettings.renderPipelineRayTracingResources.aoRaytracingRT;
				passData.rayTracingAccelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				TraceRTAOPassData traceRTAOPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8_UNorm,
					enableRandomWrite = true,
					name = "Ray Traced Ambient Occlusion"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				traceRTAOPassData.outputTexture = renderGraphBuilder.WriteTexture(in input);
				TraceRTAOPassData traceRTAOPassData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8_SNorm,
					enableRandomWrite = true,
					name = "Velocity Buffer"
				};
				input = renderGraph.CreateTexture(in desc);
				traceRTAOPassData2.velocityBuffer = renderGraphBuilder.ReadWriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TraceRTAOPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetRayTracingShaderPass(data.aoShaderRT, "VisibilityDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.aoShaderRT, HDShaderIDs._RaytracingAccelerationStructureName, data.rayTracingAccelerationStructure);
					data.raytracingCB._RaytracingRayMaxLength = data.rayLength;
					data.raytracingCB._RaytracingNumSamples = data.sampleCount;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.raytracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetRayTracingTextureParam(data.aoShaderRT, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._StencilTexture, data.depthBuffer, RenderTextureSubElement.Stencil);
					ctx.cmd.SetRayTracingTextureParam(data.aoShaderRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					ctx.cmd.SetRayTracingTextureParam(data.aoShaderRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
					ctx.cmd.SetRayTracingTextureParam(data.aoShaderRT, HDShaderIDs._AmbientOcclusionTextureRW, data.outputTexture);
					ctx.cmd.SetRayTracingTextureParam(data.aoShaderRT, HDShaderIDs._VelocityBuffer, data.velocityBuffer);
					ctx.cmd.DispatchRays(data.aoShaderRT, "RayGenAmbientOcclusion", (uint)data.actualWidth, (uint)data.actualHeight, (uint)data.viewCount);
				});
				result.signalBuffer = passData.outputTexture;
				result.velocityBuffer = passData.velocityBuffer;
				return result;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle DenoiseAO(RenderGraph renderGraph, HDCamera hdCamera, TraceAmbientOcclusionResult traceAOResult, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle motionVectorBuffer, TextureHandle historyValidationBuffer)
		{
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			if (component.denoise)
			{
				float historyValidity = EvaluateRayTracedAmbientOcclusionHistoryValidity(hdCamera);
				TextureHandle historyBuffer = renderGraph.ImportTexture(RequestAmbientOcclusionHistoryTexture(renderGraph, hdCamera));
				HDTemporalFilter.TemporalFilterParameters filterParams = default(HDTemporalFilter.TemporalFilterParameters);
				filterParams.singleChannel = true;
				filterParams.historyValidity = historyValidity;
				filterParams.occluderMotionRejection = component.occluderMotionRejection.value;
				filterParams.receiverMotionRejection = component.receiverMotionRejection.value;
				filterParams.exposureControl = false;
				filterParams.fullResolution = true;
				TextureHandle noisyBuffer = GetTemporalFilter().Denoise(renderGraph, hdCamera, filterParams, traceAOResult.signalBuffer, traceAOResult.velocityBuffer, historyBuffer, depthBuffer, normalBuffer, motionVectorBuffer, historyValidationBuffer);
				HDDiffuseDenoiser diffuseDenoiser = GetDiffuseDenoiser();
				HDDiffuseDenoiser.DiffuseDenoiserParameters denoiserParams = default(HDDiffuseDenoiser.DiffuseDenoiserParameters);
				denoiserParams.singleChannel = true;
				denoiserParams.kernelSize = component.denoiserRadius;
				denoiserParams.halfResolutionFilter = false;
				denoiserParams.jitterFilter = false;
				denoiserParams.fullResolutionInput = true;
				TextureHandle result = diffuseDenoiser.Denoise(renderGraph, hdCamera, denoiserParams, noisyBuffer, depthBuffer, normalBuffer, traceAOResult.signalBuffer);
				PropagateRayTracedAmbientOcclusionHistoryValidity(hdCamera);
				return result;
			}
			return traceAOResult.signalBuffer;
		}

		private TextureHandle ComposeAO(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle aoTexture)
		{
			ComposeRTAOPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ComposeRTAOPassData>("Composing the result of RTAO", out passData, ProfilingSampler.Get(HDProfileId.RaytracingComposeAmbientOcclusion));
			renderGraphBuilder.EnableAsyncCompute(value: false);
			ScreenSpaceAmbientOcclusion component = hdCamera.volumeStack.GetComponent<ScreenSpaceAmbientOcclusion>();
			passData.intensity = component.intensity.value;
			passData.actualWidth = hdCamera.actualWidth;
			passData.actualHeight = hdCamera.actualHeight;
			passData.viewCount = hdCamera.viewCount;
			passData.aoShaderCS = m_GlobalSettings.renderPipelineRayTracingResources.aoRaytracingCS;
			passData.intensityKernel = m_RTAOApplyIntensityKernel;
			passData.outputTexture = renderGraphBuilder.ReadWriteTexture(in aoTexture);
			renderGraphBuilder.SetRenderFunc(delegate(ComposeRTAOPassData data, RenderGraphContext ctx)
			{
				ctx.cmd.SetComputeFloatParam(data.aoShaderCS, HDShaderIDs._RaytracingAOIntensity, data.intensity);
				ctx.cmd.SetComputeTextureParam(data.aoShaderCS, data.intensityKernel, HDShaderIDs._AmbientOcclusionTextureRW, data.outputTexture);
				int actualWidth = data.actualWidth;
				int actualHeight = data.actualHeight;
				int num = 8;
				int threadGroupsX = (actualWidth + (num - 1)) / num;
				int threadGroupsY = (actualHeight + (num - 1)) / num;
				ctx.cmd.DispatchCompute(data.aoShaderCS, data.intensityKernel, threadGroupsX, threadGroupsY, data.viewCount);
			});
			return passData.outputTexture;
		}

		private static RTHandle RequestAmbientOcclusionHistoryTexture(RenderGraph renderGraph, HDCamera hdCamera)
		{
			RTHandle currentFrameRT = hdCamera.GetCurrentFrameRT(9);
			if (currentFrameRT == null)
			{
				RTHandle rTHandle = hdCamera.AllocHistoryFrameRT(9, AmbientOcclusionHistoryBufferAllocatorFunction, 1);
				ClearRTAOHistoryData passData;
				RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ClearRTAOHistoryData>("Clearing the AO History Texture", out passData, ProfilingSampler.Get(HDProfileId.RaytracingClearHistoryAmbientOcclusion));
				try
				{
					renderGraphBuilder.EnableAsyncCompute(value: false);
					ClearRTAOHistoryData clearRTAOHistoryData = passData;
					TextureHandle input = renderGraph.ImportTexture(rTHandle);
					clearRTAOHistoryData.aoTexture = renderGraphBuilder.ReadWriteTexture(in input);
					renderGraphBuilder.SetRenderFunc(delegate(ClearRTAOHistoryData data, RenderGraphContext ctx)
					{
						CoreUtils.SetRenderTarget(ctx.cmd, data.aoTexture, ClearFlag.Color, Color.black);
					});
					return rTHandle;
				}
				finally
				{
					((IDisposable)renderGraphBuilder).Dispose();
				}
			}
			return currentFrameRT;
		}

		private void InitRaytracingDeferred()
		{
			m_RayBinResult = new ComputeBuffer(1, 4);
			m_RayBinSizeResult = new ComputeBuffer(1, 4);
		}

		private void ReleaseRayTracingDeferred()
		{
			CoreUtils.SafeRelease(m_RayBinResult);
			CoreUtils.SafeRelease(m_RayBinSizeResult);
		}

		private void CheckBinningBuffersSize(HDCamera hdCamera)
		{
			int viewCount = hdCamera.viewCount;
			int num = (hdCamera.actualWidth + 15) / 16;
			int num2 = (hdCamera.actualHeight + 15) / 16;
			int count = viewCount * num * num2;
			int num3 = num * 16;
			int num4 = num2 * 16;
			int num5 = viewCount * num3 * num4;
			if (num5 > m_RayBinResult.count)
			{
				if (m_RayBinResult != null)
				{
					CoreUtils.SafeRelease(m_RayBinResult);
					CoreUtils.SafeRelease(m_RayBinSizeResult);
					m_RayBinResult = null;
					m_RayBinSizeResult = null;
				}
				if (num5 > 0)
				{
					m_RayBinResult = new ComputeBuffer(num5, 4);
					m_RayBinSizeResult = new ComputeBuffer(count, 4);
				}
			}
		}

		private static void BinRays(CommandBuffer cmd, in DeferredLightingRTParameters config, RTHandle directionBuffer, int texWidth, int texHeight)
		{
			int kernelIndex = config.rayBinningCS.FindKernel(config.halfResolution ? "RayBinningHalf" : "RayBinning");
			int num = (texWidth + 15) / 16;
			int num2 = (texHeight + 15) / 16;
			int num3 = num * 16;
			int num4 = num2 * 16;
			cmd.SetComputeTextureParam(config.rayBinningCS, kernelIndex, HDShaderIDs._RaytracingDirectionBuffer, directionBuffer);
			cmd.SetComputeBufferParam(config.rayBinningCS, kernelIndex, HDShaderIDs._RayBinResult, config.rayBinResult);
			cmd.SetComputeBufferParam(config.rayBinningCS, kernelIndex, HDShaderIDs._RayBinSizeResult, config.rayBinSizeResult);
			cmd.SetComputeIntParam(config.rayBinningCS, HDShaderIDs._RayBinTileCountX, num);
			cmd.SetComputeIntParam(config.rayBinningCS, HDShaderIDs._RayBinViewOffset, num3 * num4);
			cmd.SetComputeIntParam(config.rayBinningCS, HDShaderIDs._RayBinTileViewOffset, num * num2);
			cmd.DispatchCompute(config.rayBinningCS, kernelIndex, num, num2, config.viewCount);
		}

		private static void RayMarchGBuffer(CommandBuffer cmd, in DeferredLightingRTRPassData data, int texWidth, int texHeight)
		{
			int kernelIndex = data.parameters.rayMarchingCS.FindKernel(data.parameters.halfResolution ? "RayMarchHalfKernel" : "RayMarchKernel");
			int threadGroupsX = (texWidth + 7) / 8;
			int threadGroupsY = (texHeight + 7) / 8;
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._DepthTexture, data.depthPyramid);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
			cmd.SetComputeIntParam(data.parameters.rayMarchingCS, HDShaderIDs._DeferredStencilBit, 2);
			cmd.SetComputeBufferParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._DepthPyramidMipLevelOffsets, data.parameters.mipChainBuffer);
			float nearClipPlane = data.parameters.nearClipPlane;
			float farClipPlane = data.parameters.farClipPlane;
			float num = 0.990099f;
			float val = (0f - nearClipPlane) / (farClipPlane - nearClipPlane) * (0.01f * num);
			cmd.SetComputeFloatParam(data.parameters.rayMarchingCS, HDShaderIDs._RayMarchingThicknessScale, num);
			cmd.SetComputeFloatParam(data.parameters.rayMarchingCS, HDShaderIDs._RayMarchingThicknessBias, val);
			cmd.SetComputeIntParam(data.parameters.rayMarchingCS, HDShaderIDs._RayMarchingSteps, data.parameters.raySteps);
			cmd.SetComputeIntParam(data.parameters.rayMarchingCS, HDShaderIDs._RayMarchingReflectSky, 0);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTexture[0], data.ssgbuffer0);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTexture[1], data.ssgbuffer1);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTexture[2], data.ssgbuffer2);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTexture[3], data.ssgbuffer3);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTextureRW[0], data.gbuffer0);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTextureRW[1], data.gbuffer1);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTextureRW[2], data.gbuffer2);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._GBufferTextureRW[3], data.gbuffer3);
			cmd.SetComputeTextureParam(data.parameters.rayMarchingCS, kernelIndex, HDShaderIDs._RaytracingDistanceBuffer, data.distanceBuffer);
			cmd.DispatchCompute(data.parameters.rayMarchingCS, kernelIndex, threadGroupsX, threadGroupsY, data.parameters.viewCount);
		}

		private TextureHandle DeferredLightingRT(RenderGraph renderGraph, in DeferredLightingRTParameters parameters, TextureHandle directionBuffer, in PrepassOutput prepassOutput, Texture skyTexture, TextureHandle rayCountTexture)
		{
			DeferredLightingRTRPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DeferredLightingRTRPassData>("Deferred Lighting Ray Tracing", out passData, ProfilingSampler.Get(HDProfileId.RaytracingDeferredLighting));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.parameters = parameters;
				passData.directionBuffer = renderGraphBuilder.ReadTexture(in directionBuffer);
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.depthBuffer);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in prepassOutput.depthPyramidTexture);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in prepassOutput.normalBuffer);
				if (passData.parameters.mixedTracing)
				{
					passData.ssgbuffer0 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[0]);
					passData.ssgbuffer1 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[1]);
					passData.ssgbuffer2 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[2]);
					passData.ssgbuffer3 = renderGraphBuilder.ReadTexture(in prepassOutput.gbuffer.mrt[3]);
				}
				else
				{
					passData.ssgbuffer0 = renderGraph.defaultResources.blackTextureXR;
					passData.ssgbuffer1 = renderGraph.defaultResources.blackTextureXR;
					passData.ssgbuffer2 = renderGraph.defaultResources.blackTextureXR;
					passData.ssgbuffer3 = renderGraph.defaultResources.blackTextureXR;
				}
				passData.skyTexture = skyTexture;
				DeferredLightingRTRPassData deferredLightingRTRPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_SRGB,
					enableRandomWrite = true,
					name = "GBuffer0"
				};
				deferredLightingRTRPassData.gbuffer0 = renderGraphBuilder.CreateTransientTexture(in desc);
				DeferredLightingRTRPassData deferredLightingRTRPassData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
					enableRandomWrite = true,
					name = "GBuffer1"
				};
				deferredLightingRTRPassData2.gbuffer1 = renderGraphBuilder.CreateTransientTexture(in desc);
				DeferredLightingRTRPassData deferredLightingRTRPassData3 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
					enableRandomWrite = true,
					name = "GBuffer2"
				};
				deferredLightingRTRPassData3.gbuffer2 = renderGraphBuilder.CreateTransientTexture(in desc);
				DeferredLightingRTRPassData deferredLightingRTRPassData4 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = Builtin.GetLightingBufferFormat(),
					enableRandomWrite = true,
					name = "GBuffer3"
				};
				deferredLightingRTRPassData4.gbuffer3 = renderGraphBuilder.CreateTransientTexture(in desc);
				DeferredLightingRTRPassData deferredLightingRTRPassData5 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R32_SFloat,
					enableRandomWrite = true,
					name = "Distance Buffer"
				};
				deferredLightingRTRPassData5.distanceBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				DeferredLightingRTRPassData deferredLightingRTRPassData6 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Deferred Lighting Result"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				deferredLightingRTRPassData6.litBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(DeferredLightingRTRPassData data, RenderGraphContext ctx)
				{
					int num = data.parameters.width;
					int num2 = data.parameters.height;
					if (data.parameters.halfResolution)
					{
						num = (num + 1) / 2;
						num2 = (num2 + 1) / 2;
					}
					ConstantBuffer.PushGlobal(ctx.cmd, in data.parameters.raytracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					if (data.parameters.mixedTracing)
					{
						RayMarchGBuffer(ctx.cmd, in data, num, num2);
					}
					if (data.parameters.rayBinning)
					{
						BinRays(ctx.cmd, in data.parameters, data.directionBuffer, num, num2);
					}
					data.parameters.raytracingCB._RayTracingLodBias = data.parameters.lodBias;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.parameters.raytracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetRayTracingShaderPass(data.parameters.gBufferRaytracingRT, "GBufferDXR");
					if (data.parameters.rayBinning)
					{
						int val = (num + 15) / 16;
						ctx.cmd.SetGlobalBuffer(HDShaderIDs._RayBinResult, data.parameters.rayBinResult);
						ctx.cmd.SetGlobalBuffer(HDShaderIDs._RayBinSizeResult, data.parameters.rayBinSizeResult);
						ctx.cmd.SetRayTracingIntParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayBinTileCountX, val);
					}
					ctx.cmd.SetRayTracingAccelerationStructure(data.parameters.gBufferRaytracingRT, HDShaderIDs._RaytracingAccelerationStructureName, data.parameters.accelerationStructure);
					ctx.cmd.SetRayTracingIntParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayCountType, data.parameters.rayCountType);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
					ctx.cmd.SetRayTracingIntParams(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayTracingLayerMask, data.parameters.layerMask);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
					ctx.cmd.SetRayTracingIntParams(data.parameters.gBufferRaytracingRT, HDShaderIDs._RaytracingHalfResolution, data.parameters.halfResolution ? 1 : 0);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._GBufferTextureRW[0], data.gbuffer0);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._GBufferTextureRW[1], data.gbuffer1);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._GBufferTextureRW[2], data.gbuffer2);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._GBufferTextureRW[3], data.gbuffer3);
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._RaytracingDistanceBuffer, data.distanceBuffer);
					uint width = (uint)data.parameters.width;
					uint height = (uint)data.parameters.height;
					ctx.cmd.SetRayTracingTextureParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._SkyTexture, data.skyTexture);
					CoreUtils.SetKeyword(ctx.cmd, "MINIMAL_GBUFFER", data.parameters.diffuseLightingOnly);
					if (data.parameters.rayBinning)
					{
						int num3 = (num + 15) / 16;
						int num4 = (num2 + 15) / 16;
						int num5 = num3 * 16;
						int num6 = num4 * 16;
						ctx.cmd.SetRayTracingIntParam(data.parameters.gBufferRaytracingRT, HDShaderIDs._BufferSizeX, num5);
						ctx.cmd.SetRayTracingIntParams(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayBinViewOffset, num5 * num6);
						ctx.cmd.SetRayTracingIntParams(data.parameters.gBufferRaytracingRT, HDShaderIDs._RayBinTileViewOffset, num3 * num4);
						uint width2 = (uint)(num5 * num6);
						ctx.cmd.DispatchRays(data.parameters.gBufferRaytracingRT, "RayGenGBufferBinned", width2, 1u, (uint)data.parameters.viewCount);
					}
					else
					{
						ctx.cmd.DispatchRays(data.parameters.gBufferRaytracingRT, "RayGenGBuffer", width, height, (uint)data.parameters.viewCount);
					}
					CoreUtils.SetKeyword(ctx.cmd, "MINIMAL_GBUFFER", state: false);
					int kernelIndex = data.parameters.deferredRaytracingCS.FindKernel(data.parameters.halfResolution ? "RaytracingDeferredHalf" : "RaytracingDeferred");
					data.parameters.lightCluster.BindLightClusterData(ctx.cmd);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._RaytracingDistanceBuffer, data.distanceBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._GBufferTexture[0], data.gbuffer0);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._GBufferTexture[1], data.gbuffer1);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._GBufferTexture[2], data.gbuffer2);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._GBufferTexture[3], data.gbuffer3);
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._LightLayersTexture, TextureXR.GetWhiteTexture());
					ctx.cmd.SetComputeTextureParam(data.parameters.deferredRaytracingCS, kernelIndex, HDShaderIDs._RaytracingLitBufferRW, data.litBuffer);
					int num7 = 8;
					int threadGroupsX = (num + (num7 - 1)) / num7;
					int threadGroupsY = (num2 + (num7 - 1)) / num7;
					ctx.cmd.DispatchCompute(data.parameters.deferredRaytracingCS, kernelIndex, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
				return passData.litBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void InitRayTracedIndirectDiffuse()
		{
			ComputeShader indirectDiffuseRaytracingCS = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingCS;
			m_RaytracingIndirectDiffuseFullResKernel = indirectDiffuseRaytracingCS.FindKernel("RaytracingIndirectDiffuseFullRes");
			m_RaytracingIndirectDiffuseHalfResKernel = indirectDiffuseRaytracingCS.FindKernel("RaytracingIndirectDiffuseHalfRes");
			m_IndirectDiffuseUpscaleFullResKernel = indirectDiffuseRaytracingCS.FindKernel("IndirectDiffuseIntegrationUpscaleFullRes");
			m_IndirectDiffuseUpscaleHalfResKernel = indirectDiffuseRaytracingCS.FindKernel("IndirectDiffuseIntegrationUpscaleHalfRes");
		}

		private void ReleaseRayTracedIndirectDiffuse()
		{
		}

		private static RTHandle IndirectDiffuseHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_IndirectDiffuseHistoryBuffer{frameIndex}");
		}

		private DeferredLightingRTParameters PrepareIndirectDiffuseDeferredLightingRTParameters(HDCamera hdCamera, bool fullResolution)
		{
			DeferredLightingRTParameters result = default(DeferredLightingRTParameters);
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			hdCamera.volumeStack.GetComponent<RayTracingSettings>();
			CheckBinningBuffersSize(hdCamera);
			result.rayBinning = true;
			result.layerMask.value = 32;
			result.diffuseLightingOnly = true;
			result.halfResolution = !fullResolution;
			result.rayCountType = 5;
			result.lodBias = component.textureLodBias.value;
			result.rayMiss = (int)component.rayMiss.value;
			result.lastBounceFallbackHierarchy = (int)component.lastBounceFallbackHierarchy.value;
			result.mixedTracing = component.tracing.value == RayCastingMode.Mixed && hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred;
			result.raySteps = component.maxMixedRaySteps;
			result.nearClipPlane = hdCamera.camera.nearClipPlane;
			result.farClipPlane = hdCamera.camera.farClipPlane;
			result.width = hdCamera.actualWidth;
			result.height = hdCamera.actualHeight;
			result.viewCount = hdCamera.viewCount;
			result.rayBinResult = m_RayBinResult;
			result.rayBinSizeResult = m_RayBinSizeResult;
			result.accelerationStructure = RequestAccelerationStructure(hdCamera);
			result.lightCluster = RequestLightCluster();
			result.mipChainBuffer = hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer);
			result.rayMarchingCS = m_GlobalSettings.renderPipelineRayTracingResources.rayMarchingCS;
			result.gBufferRaytracingRT = m_GlobalSettings.renderPipelineRayTracingResources.gBufferRaytracingRT;
			result.deferredRaytracingCS = m_GlobalSettings.renderPipelineRayTracingResources.deferredRaytracingCS;
			result.rayBinningCS = m_GlobalSettings.renderPipelineRayTracingResources.rayBinningCS;
			result.raytracingCB = m_ShaderVariablesRayTracingCB;
			result.raytracingCB._RaytracingRayMaxLength = component.rayLength;
			result.raytracingCB._RayTracingClampingFlag = 1;
			result.raytracingCB._RaytracingIntensityClamp = component.clampValue;
			result.raytracingCB._RaytracingPreExposition = 1;
			result.raytracingCB._RayTracingDiffuseLightingOnly = 1;
			result.raytracingCB._RayTracingAPVRayMiss = 1;
			result.raytracingCB._RayTracingRayMissFallbackHierarchy = result.rayMiss;
			result.raytracingCB._RayTracingLastBounceFallbackHierarchy = result.lastBounceFallbackHierarchy;
			result.raytracingCB._RayTracingAmbientProbeDimmer = component.ambientProbeDimmer.value;
			return result;
		}

		private TextureHandle DirGenRTGI(RenderGraph renderGraph, HDCamera hdCamera, GlobalIllumination settings, TextureHandle depthStencilbuffer, TextureHandle normalBuffer, bool fullResolution)
		{
			DirGenRTGIPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DirGenRTGIPassData>("Generating the rays for RTGI", out passData, ProfilingSampler.Get(HDProfileId.RaytracingIndirectDiffuseDirectionGeneration));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.fullResolution = fullResolution;
				passData.directionGenCS = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingCS;
				passData.dirGenKernel = (fullResolution ? m_RaytracingIndirectDiffuseFullResKernel : m_RaytracingIndirectDiffuseHalfResKernel);
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in depthStencilbuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				DirGenRTGIPassData dirGenRTGIPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "GI Ray Directions"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				dirGenRTGIPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(DirGenRTGIPassData data, RenderGraphContext ctx)
				{
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._StencilTexture, data.depthStencilBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._RaytracingDirectionBuffer, data.outputBuffer);
					int threadGroupsX;
					int threadGroupsY;
					if (data.fullResolution)
					{
						threadGroupsX = (data.texWidth + 7) / 8;
						threadGroupsY = (data.texHeight + 7) / 8;
					}
					else
					{
						threadGroupsX = (data.texWidth / 2 + 7) / 8;
						threadGroupsY = (data.texHeight / 2 + 7) / 8;
					}
					ctx.cmd.DispatchCompute(data.directionGenCS, data.dirGenKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle UpscaleRTGI(RenderGraph renderGraph, HDCamera hdCamera, GlobalIllumination settings, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle indirectDiffuseBuffer, TextureHandle directionBuffer, bool fullResolution)
		{
			UpscaleRTGIPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpscaleRTGIPassData>("Upscale the RTGI result", out passData, ProfilingSampler.Get(HDProfileId.RaytracingIndirectDiffuseUpscale));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.upscaleCS = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingCS;
				passData.upscaleKernel = (fullResolution ? m_IndirectDiffuseUpscaleFullResKernel : m_IndirectDiffuseUpscaleHalfResKernel);
				passData.blueNoiseTexture = GetBlueNoiseManager().textureArray16RGB;
				passData.scramblingTexture = m_Asset.renderPipelineResources.textures.scramblingTex;
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.indirectDiffuseBuffer = renderGraphBuilder.ReadTexture(in indirectDiffuseBuffer);
				passData.directionBuffer = renderGraphBuilder.ReadTexture(in directionBuffer);
				UpscaleRTGIPassData upscaleRTGIPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Reflection Ray Indirect Diffuse"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				upscaleRTGIPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(UpscaleRTGIPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._IndirectDiffuseTexture, data.indirectDiffuseBuffer);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._RaytracingDirectionBuffer, data.directionBuffer);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._BlueNoiseTexture, data.blueNoiseTexture);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._ScramblingTexture, data.scramblingTexture);
					ctx.cmd.SetComputeTextureParam(data.upscaleCS, data.upscaleKernel, HDShaderIDs._UpscaledIndirectDiffuseTextureRW, data.outputBuffer);
					int texWidth = data.texWidth;
					int texHeight = data.texHeight;
					int num = 8;
					int threadGroupsX = (texWidth + (num - 1)) / num;
					int threadGroupsY = (texHeight + (num - 1)) / num;
					ctx.cmd.DispatchCompute(data.upscaleCS, data.upscaleKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private static RTHandle RequestRayTracedIndirectDiffuseHistoryTexture(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(14) ?? hdCamera.AllocHistoryFrameRT(14, ReflectionHistoryBufferAllocatorFunction, 1);
		}

		private TextureHandle RenderIndirectDiffusePerformance(RenderGraph renderGraph, HDCamera hdCamera, in PrepassOutput prepassOutput, TextureHandle historyValidationTexture, TextureHandle rayCountTexture, Texture skyTexture, ShaderVariablesRaytracing shaderVariablesRaytracing)
		{
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			bool fullResolution = component.fullResolution || !RayTracingHalfResAllowed();
			TextureHandle directionBuffer = DirGenRTGI(renderGraph, hdCamera, component, prepassOutput.depthBuffer, prepassOutput.normalBuffer, fullResolution);
			DeferredLightingRTParameters parameters = PrepareIndirectDiffuseDeferredLightingRTParameters(hdCamera, fullResolution);
			TextureHandle indirectDiffuseBuffer = DeferredLightingRT(renderGraph, in parameters, directionBuffer, in prepassOutput, skyTexture, rayCountTexture);
			TextureHandle rtGIBuffer = UpscaleRTGI(renderGraph, hdCamera, component, prepassOutput.depthBuffer, prepassOutput.normalBuffer, indirectDiffuseBuffer, directionBuffer, fullResolution);
			return DenoiseRTGI(renderGraph, hdCamera, rtGIBuffer, prepassOutput.depthBuffer, prepassOutput.normalBuffer, prepassOutput.resolvedMotionVectorsBuffer, historyValidationTexture, fullResolution);
		}

		private TextureHandle QualityRTGI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle rayCountTexture)
		{
			TraceQualityRTGIPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TraceQualityRTGIPassData>("Quality RT Indirect Diffuse", out passData, ProfilingSampler.Get(HDProfileId.RaytracingIndirectDiffuseEvaluation));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.rayLength = component.rayLength;
				passData.sampleCount = component.sampleCount.value;
				passData.clampValue = component.clampValue;
				passData.bounceCount = component.bounceCount.value;
				passData.lodBias = component.textureLodBias.value;
				passData.rayMiss = (int)component.rayMiss.value;
				passData.lastBounceFallbackHierarchy = (int)component.lastBounceFallbackHierarchy.value;
				passData.ambientProbeDimmer = component.ambientProbeDimmer.value;
				if (IsAPVEnabled())
				{
					if (m_Asset.currentPlatformRenderPipelineSettings.probeVolumeSHBands == ProbeVolumeSHBands.SphericalHarmonicsL1)
					{
						passData.indirectDiffuseRT = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingL1RT;
					}
					else
					{
						passData.indirectDiffuseRT = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingL2RT;
					}
				}
				else
				{
					passData.indirectDiffuseRT = m_GlobalSettings.renderPipelineRayTracingResources.indirectDiffuseRaytracingOffRT;
				}
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.lightCluster = RequestLightCluster();
				passData.skyTexture = m_SkyManager.GetSkyReflection(hdCamera);
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in depthStencilBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				TraceQualityRTGIPassData traceQualityRTGIPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Ray Traced Indirect Diffuse"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				traceQualityRTGIPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TraceQualityRTGIPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetRayTracingShaderPass(data.indirectDiffuseRT, "IndirectDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.indirectDiffuseRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					ctx.cmd.SetRayTracingTextureParam(data.indirectDiffuseRT, HDShaderIDs._IndirectDiffuseTextureRW, data.outputBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.indirectDiffuseRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._StencilTexture, data.depthStencilBuffer, RenderTextureSubElement.Stencil);
					ctx.cmd.SetRayTracingTextureParam(data.indirectDiffuseRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.indirectDiffuseRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
					data.lightCluster.BindLightClusterData(ctx.cmd);
					ctx.cmd.SetRayTracingTextureParam(data.indirectDiffuseRT, HDShaderIDs._SkyTexture, data.skyTexture);
					data.shaderVariablesRayTracingCB._RayTracingClampingFlag = 1;
					data.shaderVariablesRayTracingCB._RaytracingIntensityClamp = data.clampValue;
					data.shaderVariablesRayTracingCB._RaytracingRayMaxLength = data.rayLength;
					data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.sampleCount;
					data.shaderVariablesRayTracingCB._RaytracingMaxRecursion = data.bounceCount;
					data.shaderVariablesRayTracingCB._RayTracingDiffuseLightingOnly = 1;
					data.shaderVariablesRayTracingCB._RayTracingLodBias = data.lodBias;
					data.shaderVariablesRayTracingCB._RayTracingRayMissFallbackHierarchy = data.rayMiss;
					data.shaderVariablesRayTracingCB._RayTracingLastBounceFallbackHierarchy = data.lastBounceFallbackHierarchy;
					data.shaderVariablesRayTracingCB._RayTracingAmbientProbeDimmer = data.ambientProbeDimmer;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					CoreUtils.SetKeyword(ctx.cmd, "MULTI_BOUNCE_INDIRECT", data.bounceCount > 1);
					ctx.cmd.DispatchRays(data.indirectDiffuseRT, "RayGenIntegration", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
					CoreUtils.SetKeyword(ctx.cmd, "MULTI_BOUNCE_INDIRECT", state: false);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderIndirectDiffuseQuality(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle motionVectors, TextureHandle historyValidationTexture, TextureHandle rayCountTexture, Texture skyTexture, ShaderVariablesRaytracing shaderVariablesRaytracing)
		{
			TextureHandle rtGIBuffer = QualityRTGI(renderGraph, hdCamera, depthStencilBuffer, normalBuffer, rayCountTexture);
			return DenoiseRTGI(renderGraph, hdCamera, rtGIBuffer, depthStencilBuffer, normalBuffer, motionVectors, historyValidationTexture, fullResolution: true);
		}

		private static RTHandle RequestIndirectDiffuseHistoryTextureHF(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(14) ?? hdCamera.AllocHistoryFrameRT(14, IndirectDiffuseHistoryBufferAllocatorFunction, 1);
		}

		private static RTHandle RequestIndirectDiffuseHistoryTextureLF(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(15) ?? hdCamera.AllocHistoryFrameRT(15, IndirectDiffuseHistoryBufferAllocatorFunction, 1);
		}

		private TextureHandle DenoiseRTGI(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle rtGIBuffer, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle motionVectorBuffer, TextureHandle historyValidationTexture, bool fullResolution)
		{
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			if (component.denoise)
			{
				float historyValidity = EvaluateIndirectDiffuseHistoryValidity0(hdCamera, fullResolution, rayTraced: true);
				HDTemporalFilter temporalFilter = GetTemporalFilter();
				HDDiffuseDenoiser diffuseDenoiser = GetDiffuseDenoiser();
				TextureHandle historyBuffer = renderGraph.ImportTexture(RequestIndirectDiffuseHistoryTextureHF(hdCamera));
				HDTemporalFilter.TemporalFilterParameters filterParams = default(HDTemporalFilter.TemporalFilterParameters);
				filterParams.singleChannel = false;
				filterParams.historyValidity = historyValidity;
				filterParams.occluderMotionRejection = false;
				filterParams.receiverMotionRejection = component.receiverMotionRejection.value;
				filterParams.exposureControl = true;
				filterParams.fullResolution = true;
				TextureHandle noisyBuffer = temporalFilter.Denoise(renderGraph, hdCamera, filterParams, rtGIBuffer, renderGraph.defaultResources.blackTextureXR, historyBuffer, depthStencilBuffer, normalBuffer, motionVectorBuffer, historyValidationTexture);
				HDDiffuseDenoiser.DiffuseDenoiserParameters denoiserParams = default(HDDiffuseDenoiser.DiffuseDenoiserParameters);
				denoiserParams.singleChannel = false;
				denoiserParams.kernelSize = component.denoiserRadius;
				denoiserParams.halfResolutionFilter = component.halfResolutionDenoiser;
				denoiserParams.jitterFilter = component.secondDenoiserPass;
				denoiserParams.fullResolutionInput = true;
				rtGIBuffer = diffuseDenoiser.Denoise(renderGraph, hdCamera, denoiserParams, noisyBuffer, depthStencilBuffer, normalBuffer, rtGIBuffer);
				if (component.secondDenoiserPass)
				{
					float historyValidity2 = EvaluateIndirectDiffuseHistoryValidity1(hdCamera, fullResolution, rayTraced: true);
					TextureHandle historyBuffer2 = renderGraph.ImportTexture(RequestIndirectDiffuseHistoryTextureLF(hdCamera));
					filterParams.singleChannel = false;
					filterParams.historyValidity = historyValidity2;
					filterParams.occluderMotionRejection = false;
					filterParams.receiverMotionRejection = component.receiverMotionRejection.value;
					filterParams.exposureControl = true;
					noisyBuffer = temporalFilter.Denoise(renderGraph, hdCamera, filterParams, rtGIBuffer, renderGraph.defaultResources.blackTextureXR, historyBuffer2, depthStencilBuffer, normalBuffer, motionVectorBuffer, historyValidationTexture);
					denoiserParams.singleChannel = false;
					denoiserParams.kernelSize = component.denoiserRadius * 0.5f;
					denoiserParams.halfResolutionFilter = component.halfResolutionDenoiser;
					denoiserParams.jitterFilter = false;
					denoiserParams.fullResolutionInput = true;
					rtGIBuffer = diffuseDenoiser.Denoise(renderGraph, hdCamera, denoiserParams, noisyBuffer, depthStencilBuffer, normalBuffer, rtGIBuffer);
					PropagateIndirectDiffuseHistoryValidity1(hdCamera, fullResolution, rayTraced: true);
				}
				PropagateIndirectDiffuseHistoryValidity0(hdCamera, fullResolution, rayTraced: true);
				return rtGIBuffer;
			}
			return rtGIBuffer;
		}

		private TextureHandle RenderRayTracedIndirectDiffuse(RenderGraph renderGraph, HDCamera hdCamera, in PrepassOutput prepassOutput, TextureHandle historyValidationTexture, Texture skyTexture, TextureHandle rayCountTexture, ShaderVariablesRaytracing shaderVariablesRaytracing)
		{
			GlobalIllumination component = hdCamera.volumeStack.GetComponent<GlobalIllumination>();
			bool flag = false;
			if ((m_Asset.currentPlatformRenderPipelineSettings.supportedRayTracingMode != RenderPipelineSettings.SupportedRayTracingMode.Both) ? (m_Asset.currentPlatformRenderPipelineSettings.supportedRayTracingMode == RenderPipelineSettings.SupportedRayTracingMode.Quality) : (component.tracing.value == RayCastingMode.RayTracing && component.mode.value == RayTracingMode.Quality))
			{
				return RenderIndirectDiffuseQuality(renderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.normalBuffer, prepassOutput.motionVectorsBuffer, historyValidationTexture, rayCountTexture, skyTexture, shaderVariablesRaytracing);
			}
			return RenderIndirectDiffusePerformance(renderGraph, hdCamera, in prepassOutput, historyValidationTexture, rayCountTexture, skyTexture, shaderVariablesRaytracing);
		}

		private void InitRecursiveRenderer()
		{
			m_RaytracingFlagStateBlock = new RenderStateBlock
			{
				depthState = new DepthState(writeEnabled: false, CompareFunction.LessEqual),
				mask = RenderStateMask.Depth
			};
		}

		internal TextureHandle CreateFlagMaskTexture(RenderGraph renderGraph)
		{
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8_SNorm,
				dimension = TextureXR.dimension,
				enableRandomWrite = true,
				useMipMap = true,
				clearBuffer = true,
				clearColor = Color.black,
				name = "FlagMaskTexture"
			};
			return renderGraph.CreateTexture(in desc);
		}

		private TextureHandle RaytracingRecursiveRender(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthPyramid, TextureHandle flagMask, TextureHandle rayCountTexture)
		{
			RecursiveRendering component = hdCamera.volumeStack.GetComponent<RecursiveRendering>();
			if (!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) || !component.enable.value || !GetRayTracingState() || !GetRayTracingClusterState())
			{
				return colorBuffer;
			}
			RecursiveRenderingPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<RecursiveRenderingPassData>("Recursive Rendering Evaluation", out passData, ProfilingSampler.Get(HDProfileId.RayTracingRecursiveRendering));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.rayLength = component.rayLength.value;
				passData.maxDepth = component.maxDepth.value;
				passData.minSmoothness = component.minSmoothness.value;
				passData.rayMissFallbackHiearchy = (int)component.rayMiss.value;
				passData.lastBounceFallbackHiearchy = (int)component.lastBounce.value;
				passData.ambientProbeDimmer = component.ambientProbeDimmer.value;
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.lightCluster = RequestLightCluster();
				passData.recursiveRenderingRT = m_GlobalSettings.renderPipelineRayTracingResources.forwardRaytracing;
				passData.skyTexture = m_SkyManager.GetSkyReflection(hdCamera);
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.flagMask = renderGraphBuilder.ReadTexture(in flagMask);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				passData.outputBuffer = renderGraphBuilder.ReadWriteTexture(in colorBuffer);
				RecursiveRenderingPassData recursiveRenderingPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Recursive Rendering Debug Texture"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				recursiveRenderingPassData.debugBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(RecursiveRenderingPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetRayTracingShaderPass(data.recursiveRenderingRT, "ForwardDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.recursiveRenderingRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					data.shaderVariablesRayTracingCB._RaytracingRayMaxLength = data.rayLength;
					data.shaderVariablesRayTracingCB._RaytracingMaxRecursion = data.maxDepth;
					data.shaderVariablesRayTracingCB._RaytracingReflectionMinSmoothness = data.minSmoothness;
					data.shaderVariablesRayTracingCB._RayTracingRayMissFallbackHierarchy = data.rayMissFallbackHiearchy;
					data.shaderVariablesRayTracingCB._RayTracingLastBounceFallbackHierarchy = data.lastBounceFallbackHiearchy;
					data.shaderVariablesRayTracingCB._RayTracingAmbientProbeDimmer = data.ambientProbeDimmer;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._RaytracingFlagMask, data.flagMask);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._CameraColorTextureRW, data.outputBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._RayCountTexture, data.rayCountTexture);
					data.lightCluster.BindLightClusterData(ctx.cmd);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._SkyTexture, data.skyTexture);
					ctx.cmd.SetRayTracingTextureParam(data.recursiveRenderingRT, HDShaderIDs._RaytracingPrimaryDebug, data.debugBuffer);
					ctx.cmd.DispatchRays(data.recursiveRenderingRT, "RayGenRenderer", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
				});
				PushFullScreenDebugTexture(m_RenderGraph, passData.debugBuffer, FullScreenDebugMode.RecursiveRayTracing);
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void InitRayTracedReflections()
		{
			ComputeShader reflectionRaytracingCS = m_GlobalSettings.renderPipelineRayTracingResources.reflectionRaytracingCS;
			ComputeShader reflectionBilateralFilterCS = m_GlobalSettings.renderPipelineRayTracingResources.reflectionBilateralFilterCS;
			m_RaytracingReflectionsFullResKernel = reflectionRaytracingCS.FindKernel("RaytracingReflectionsFullRes");
			m_RaytracingReflectionsHalfResKernel = reflectionRaytracingCS.FindKernel("RaytracingReflectionsHalfRes");
			m_RaytracingReflectionsTransparentFullResKernel = reflectionRaytracingCS.FindKernel("RaytracingReflectionsTransparentFullRes");
			m_RaytracingReflectionsTransparentHalfResKernel = reflectionRaytracingCS.FindKernel("RaytracingReflectionsTransparentHalfRes");
			m_ReflectionAdjustWeightKernel = reflectionBilateralFilterCS.FindKernel("ReflectionAdjustWeight");
			m_ReflectionUpscaleKernel = reflectionBilateralFilterCS.FindKernel("ReflectionUpscale");
		}

		private static RTHandle ReflectionHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_ReflectionHistoryBuffer{frameIndex}");
		}

		private int CombineRayTracedReflectionsHistoryStateToMask(bool fullResolution, bool rayTraced)
		{
			return 0 | (fullResolution ? 1 : 0) | (rayTraced ? 2 : 0);
		}

		private float EvaluateRayTracedReflectionHistoryValidity(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineRayTracedReflectionsHistoryStateToMask(fullResolution, rayTraced);
			float num = (hdCamera.EffectHistoryValidity(HDCamera.HistoryEffectSlot.RayTracedReflections, flagMask) ? 1f : 0f);
			return EvaluateHistoryValidity(hdCamera) * num;
		}

		private void PropagateRayTracedReflectionsHistoryValidity(HDCamera hdCamera, bool fullResolution, bool rayTraced)
		{
			int flagMask = CombineRayTracedReflectionsHistoryStateToMask(fullResolution, rayTraced);
			hdCamera.PropagateEffectHistoryValidity(HDCamera.HistoryEffectSlot.RayTracedReflections, flagMask);
		}

		private ReflectionsMode GetReflectionsMode(HDCamera hdCamera)
		{
			ReflectionsMode result = ReflectionsMode.Off;
			if (hdCamera.frameSettings.IsEnabled(FrameSettingsField.SSR))
			{
				ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
				if (component.enabled.value)
				{
					bool flag = hdCamera.colorPyramidHistoryIsValid && !hdCamera.isFirstFrame;
					result = ((!hdCamera.frameSettings.IsEnabled(FrameSettingsField.RayTracing) || component.tracing.value == RayCastingMode.RayMarching || !GetRayTracingState()) ? (flag ? ReflectionsMode.ScreenSpace : ReflectionsMode.Off) : ((component.tracing.value == RayCastingMode.RayTracing) ? ReflectionsMode.RayTraced : ReflectionsMode.Mixed));
				}
			}
			return result;
		}

		private TextureHandle DirGenRTR(RenderGraph renderGraph, HDCamera hdCamera, ScreenSpaceReflection settings, TextureHandle depthBuffer, TextureHandle stencilBuffer, TextureHandle normalBuffer, TextureHandle clearCoatTexture, bool fullResolution, bool transparent)
		{
			DirGenRTRPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DirGenRTRPassData>("Generating the rays for RTR", out passData, ProfilingSampler.Get(HDProfileId.RaytracingReflectionDirectionGeneration));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = (fullResolution ? hdCamera.actualWidth : (hdCamera.actualWidth / 2));
				passData.texHeight = (fullResolution ? hdCamera.actualHeight : (hdCamera.actualHeight / 2));
				passData.viewCount = hdCamera.viewCount;
				passData.minSmoothness = settings.minSmoothness;
				passData.directionGenCS = m_GlobalSettings.renderPipelineRayTracingResources.reflectionRaytracingCS;
				if (fullResolution)
				{
					passData.dirGenKernel = (transparent ? m_RaytracingReflectionsTransparentFullResKernel : m_RaytracingReflectionsFullResKernel);
				}
				else
				{
					passData.dirGenKernel = (transparent ? m_RaytracingReflectionsTransparentHalfResKernel : m_RaytracingReflectionsHalfResKernel);
				}
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				passData.stencilBuffer = renderGraphBuilder.ReadTexture(in stencilBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.clearCoatMaskTexture = renderGraphBuilder.ReadTexture(in clearCoatTexture);
				DirGenRTRPassData dirGenRTRPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Reflection Ray Directions"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				dirGenRTRPassData.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(DirGenRTRPassData data, RenderGraphContext ctx)
				{
					CoreUtils.SetRenderTarget(ctx.cmd, data.outputBuffer, ClearFlag.Color, Color.black);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					data.shaderVariablesRayTracingCB._RaytracingReflectionMinSmoothness = data.minSmoothness;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMaskTexture);
					ctx.cmd.SetComputeIntParam(data.directionGenCS, HDShaderIDs._SsrStencilBit, 8);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._StencilTexture, data.stencilBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeTextureParam(data.directionGenCS, data.dirGenKernel, HDShaderIDs._RaytracingDirectionBuffer, data.outputBuffer);
					int threadGroupsX = (data.texWidth + 7) / 8;
					int threadGroupsY = (data.texHeight + 7) / 8;
					ctx.cmd.DispatchCompute(data.directionGenCS, data.dirGenKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle AdjustWeightRTR(RenderGraph renderGraph, HDCamera hdCamera, ScreenSpaceReflection settings, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle clearCoatTexture, TextureHandle lightingTexture, TextureHandle directionTexture, bool fullResolution)
		{
			AdjustWeightRTRPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<AdjustWeightRTRPassData>("Adjust Weight RTR", out passData, ProfilingSampler.Get(HDProfileId.RaytracingReflectionAdjustWeight));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = (fullResolution ? hdCamera.actualWidth : (hdCamera.actualWidth / 2));
				passData.texHeight = (fullResolution ? hdCamera.actualHeight : (hdCamera.actualHeight / 2));
				passData.viewCount = hdCamera.viewCount;
				passData.minSmoothness = settings.minSmoothness;
				passData.smoothnessFadeStart = settings.smoothnessFadeStart;
				passData.reflectionFilterCS = m_GlobalSettings.renderPipelineRayTracingResources.reflectionBilateralFilterCS;
				passData.adjustWeightKernel = (fullResolution ? m_ReflectionAdjustWeightKernel : m_ReflectionRescaleAndAdjustWeightKernel);
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.clearCoatMaskTexture = renderGraphBuilder.ReadTexture(in clearCoatTexture);
				passData.lightingTexture = renderGraphBuilder.ReadTexture(in lightingTexture);
				passData.directionTexture = renderGraphBuilder.ReadTexture(in directionTexture);
				AdjustWeightRTRPassData adjustWeightRTRPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Reflection Ray Reflections"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				adjustWeightRTRPassData.outputTexture = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(AdjustWeightRTRPassData data, RenderGraphContext ctx)
				{
					data.shaderVariablesRayTracingCB._RaytracingReflectionMinSmoothness = data.minSmoothness;
					data.shaderVariablesRayTracingCB._RaytracingReflectionSmoothnessFadeStart = data.smoothnessFadeStart;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMaskTexture);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._DirectionPDFTexture, data.directionTexture);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._SsrLightingTextureRW, data.lightingTexture);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.adjustWeightKernel, HDShaderIDs._RaytracingReflectionTexture, data.outputTexture);
					int threadGroupsX = (data.texWidth + 7) / 8;
					int threadGroupsY = (data.texHeight + 7) / 8;
					ctx.cmd.DispatchCompute(data.reflectionFilterCS, data.adjustWeightKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputTexture;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle UpscaleRTR(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle lightingTexture)
		{
			UpscaleRTRPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UpscaleRTRPassData>("Upscale RTR", out passData, ProfilingSampler.Get(HDProfileId.RaytracingReflectionUpscale));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.reflectionFilterCS = m_GlobalSettings.renderPipelineRayTracingResources.reflectionBilateralFilterCS;
				passData.upscaleKernel = m_ReflectionUpscaleKernel;
				passData.depthStencilBuffer = renderGraphBuilder.ReadTexture(in depthBuffer);
				passData.lightingTexture = renderGraphBuilder.ReadTexture(in lightingTexture);
				UpscaleRTRPassData upscaleRTRPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Reflection Ray Reflections"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				upscaleRTRPassData.outputTexture = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(UpscaleRTRPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.upscaleKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.upscaleKernel, HDShaderIDs._SsrLightingTextureRW, data.lightingTexture);
					ctx.cmd.SetComputeTextureParam(data.reflectionFilterCS, data.upscaleKernel, HDShaderIDs._RaytracingReflectionTexture, data.outputTexture);
					int threadGroupsX = (data.texWidth + 7) / 8;
					int threadGroupsY = (data.texHeight + 7) / 8;
					ctx.cmd.DispatchCompute(data.reflectionFilterCS, data.upscaleKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputTexture;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private static RTHandle RequestRayTracedReflectionsHistoryTexture(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(13) ?? hdCamera.AllocHistoryFrameRT(13, ReflectionHistoryBufferAllocatorFunction, 1);
		}

		private DeferredLightingRTParameters PrepareReflectionDeferredLightingRTParameters(HDCamera hdCamera, bool fullResolution, bool transparent)
		{
			DeferredLightingRTParameters result = default(DeferredLightingRTParameters);
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			hdCamera.volumeStack.GetComponent<RayTracingSettings>();
			CheckBinningBuffersSize(hdCamera);
			result.rayBinning = true;
			result.layerMask.value = 16;
			result.diffuseLightingOnly = false;
			result.halfResolution = !fullResolution;
			result.rayCountType = 7;
			result.lodBias = component.textureLodBias.value;
			result.rayMiss = (int)component.rayMiss.value;
			result.lastBounceFallbackHierarchy = (int)component.lastBounceFallbackHierarchy.value;
			result.mixedTracing = component.tracing.value == RayCastingMode.Mixed && hdCamera.frameSettings.litShaderMode == LitShaderMode.Deferred && !transparent;
			result.raySteps = component.rayMaxIterationsRT;
			result.nearClipPlane = hdCamera.camera.nearClipPlane;
			result.farClipPlane = hdCamera.camera.farClipPlane;
			result.width = hdCamera.actualWidth;
			result.height = hdCamera.actualHeight;
			result.viewCount = hdCamera.viewCount;
			result.rayBinResult = m_RayBinResult;
			result.rayBinSizeResult = m_RayBinSizeResult;
			result.accelerationStructure = RequestAccelerationStructure(hdCamera);
			result.lightCluster = RequestLightCluster();
			result.mipChainBuffer = hdCamera.depthBufferMipChainInfo.GetOffsetBufferData(m_DepthPyramidMipLevelOffsetsBuffer);
			result.rayMarchingCS = m_GlobalSettings.renderPipelineRayTracingResources.rayMarchingCS;
			result.gBufferRaytracingRT = m_GlobalSettings.renderPipelineRayTracingResources.gBufferRaytracingRT;
			result.deferredRaytracingCS = m_GlobalSettings.renderPipelineRayTracingResources.deferredRaytracingCS;
			result.rayBinningCS = m_GlobalSettings.renderPipelineRayTracingResources.rayBinningCS;
			result.raytracingCB = m_ShaderVariablesRayTracingCB;
			result.raytracingCB._RaytracingRayMaxLength = component.rayLength;
			result.raytracingCB._RayTracingClampingFlag = ((!transparent) ? 1 : 0);
			result.raytracingCB._RaytracingIntensityClamp = component.clampValue;
			result.raytracingCB._RaytracingPreExposition = 0;
			result.raytracingCB._RayTracingDiffuseLightingOnly = 0;
			result.raytracingCB._RayTracingAPVRayMiss = 0;
			result.raytracingCB._RayTracingRayMissFallbackHierarchy = result.rayMiss;
			result.raytracingCB._RayTracingLastBounceFallbackHierarchy = result.lastBounceFallbackHierarchy;
			result.raytracingCB._RayTracingAmbientProbeDimmer = component.ambientProbeDimmer.value;
			return result;
		}

		private TextureHandle RenderReflectionsPerformance(RenderGraph renderGraph, HDCamera hdCamera, in PrepassOutput prepassOutput, TextureHandle rayCountTexture, TextureHandle clearCoatTexture, Texture skyTexture, ShaderVariablesRaytracing shaderVariablesRaytracing, bool transparent)
		{
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			bool flag = component.fullResolution || !RayTracingHalfResAllowed();
			TextureHandle textureHandle = DirGenRTR(renderGraph, hdCamera, component, prepassOutput.depthBuffer, prepassOutput.stencilBuffer, prepassOutput.normalBuffer, clearCoatTexture, flag, transparent);
			DeferredLightingRTParameters parameters = PrepareReflectionDeferredLightingRTParameters(hdCamera, flag, transparent);
			TextureHandle lightingTexture = DeferredLightingRT(renderGraph, in parameters, textureHandle, in prepassOutput, skyTexture, rayCountTexture);
			TextureHandle textureHandle2 = AdjustWeightRTR(renderGraph, hdCamera, component, prepassOutput.depthBuffer, prepassOutput.normalBuffer, clearCoatTexture, lightingTexture, textureHandle, flag);
			if (component.denoise && !transparent)
			{
				textureHandle2 = DenoiseReflection(renderGraph, hdCamera, flag, component.denoiserRadius, singleReflectionBounce: true, component.affectSmoothSurfaces, textureHandle2, prepassOutput.depthBuffer, prepassOutput.normalBuffer, prepassOutput.motionVectorsBuffer, clearCoatTexture);
			}
			if (!flag)
			{
				textureHandle2 = UpscaleRTR(renderGraph, hdCamera, prepassOutput.depthBuffer, textureHandle2);
			}
			return textureHandle2;
		}

		private TextureHandle QualityRTR(RenderGraph renderGraph, HDCamera hdCamera, ScreenSpaceReflection settings, TextureHandle depthPyramid, TextureHandle stencilBuffer, TextureHandle normalBuffer, TextureHandle clearCoatTexture, TextureHandle rayCountTexture, bool transparent)
		{
			TraceQualityRTRPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TraceQualityRTRPassData>("Quality RT Reflections", out passData, ProfilingSampler.Get(HDProfileId.RaytracingReflectionEvaluation));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.clampValue = settings.clampValue;
				passData.reflectSky = (settings.reflectSky.value ? 1 : 0);
				passData.rayLength = settings.rayLength;
				passData.sampleCount = settings.sampleCount.value;
				passData.bounceCount = settings.bounceCount.value;
				passData.transparent = transparent;
				passData.minSmoothness = settings.minSmoothness;
				passData.smoothnessFadeStart = settings.smoothnessFadeStart;
				passData.lodBias = settings.textureLodBias.value;
				passData.rayMissfallbackHierarchy = (int)settings.rayMiss.value;
				passData.lastBouncefallbackHierarchy = (int)settings.lastBounceFallbackHierarchy.value;
				passData.ambientProbeDimmer = settings.ambientProbeDimmer.value;
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.lightCluster = RequestLightCluster();
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.skyTexture = m_SkyManager.GetSkyReflection(hdCamera);
				passData.reflectionShader = m_GlobalSettings.renderPipelineRayTracingResources.reflectionRaytracingRT;
				passData.depthBuffer = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.stencilBuffer = renderGraphBuilder.ReadTexture(in stencilBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.clearCoatMaskTexture = renderGraphBuilder.ReadTexture(in clearCoatTexture);
				passData.rayCountTexture = renderGraphBuilder.ReadWriteTexture(in rayCountTexture);
				TraceQualityRTRPassData traceQualityRTRPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Ray Traced Reflections"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				traceQualityRTRPassData.outputTexture = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TraceQualityRTRPassData data, RenderGraphContext ctx)
				{
					ctx.cmd.SetRayTracingShaderPass(data.reflectionShader, "IndirectDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.reflectionShader, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					data.shaderVariablesRayTracingCB._RayTracingClampingFlag = ((!data.transparent) ? 1 : 0);
					data.shaderVariablesRayTracingCB._RaytracingIntensityClamp = data.clampValue;
					data.shaderVariablesRayTracingCB._RaytracingRayMaxLength = data.rayLength;
					data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.sampleCount;
					data.shaderVariablesRayTracingCB._RaytracingMaxRecursion = data.bounceCount;
					data.shaderVariablesRayTracingCB._RayTracingDiffuseLightingOnly = 0;
					data.shaderVariablesRayTracingCB._RaytracingReflectionMinSmoothness = data.minSmoothness;
					data.shaderVariablesRayTracingCB._RaytracingReflectionSmoothnessFadeStart = data.smoothnessFadeStart;
					data.shaderVariablesRayTracingCB._RayTracingLodBias = data.lodBias;
					data.shaderVariablesRayTracingCB._RayTracingRayMissFallbackHierarchy = data.rayMissfallbackHierarchy;
					data.shaderVariablesRayTracingCB._RayTracingLastBounceFallbackHierarchy = data.lastBouncefallbackHierarchy;
					data.shaderVariablesRayTracingCB._RayTracingAmbientProbeDimmer = data.ambientProbeDimmer;
					ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._SsrLightingTextureRW, data.outputTexture);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetGlobalTexture(HDShaderIDs._StencilTexture, data.stencilBuffer, RenderTextureSubElement.Stencil);
					ctx.cmd.SetRayTracingIntParams(data.reflectionShader, HDShaderIDs._SsrStencilBit, 8);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._RayCountTexture, data.rayCountTexture);
					data.lightCluster.BindLightClusterData(ctx.cmd);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._SsrClearCoatMaskTexture, data.clearCoatMaskTexture);
					ctx.cmd.SetRayTracingTextureParam(data.reflectionShader, HDShaderIDs._SkyTexture, data.skyTexture);
					CoreUtils.SetKeyword(ctx.cmd, "MULTI_BOUNCE_INDIRECT", data.bounceCount > 1);
					ctx.cmd.DispatchRays(data.reflectionShader, data.transparent ? "RayGenIntegrationTransparent" : "RayGenIntegration", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
					CoreUtils.SetKeyword(ctx.cmd, "MULTI_BOUNCE_INDIRECT", state: false);
				});
				return passData.outputTexture;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle RenderReflectionsQuality(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthPyramid, TextureHandle stencilBuffer, TextureHandle normalBuffer, TextureHandle motionVectors, TextureHandle rayCountTexture, TextureHandle clearCoatTexture, Texture skyTexture, ShaderVariablesRaytracing shaderVariablesRaytracing, bool transparent)
		{
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			TextureHandle textureHandle = QualityRTR(renderGraph, hdCamera, component, depthPyramid, stencilBuffer, normalBuffer, clearCoatTexture, rayCountTexture, transparent);
			if (component.denoise && !transparent)
			{
				textureHandle = DenoiseReflection(renderGraph, hdCamera, fullResolution: true, component.denoiserRadius, component.bounceCount == 1, component.affectSmoothSurfaces, textureHandle, depthPyramid, normalBuffer, motionVectors, clearCoatTexture);
			}
			return textureHandle;
		}

		private TextureHandle DenoiseReflection(RenderGraph renderGraph, HDCamera hdCamera, bool fullResolution, int denoiserRadius, bool singleReflectionBounce, bool affectSmoothSurfaces, TextureHandle input, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle motionVectors, TextureHandle clearCoatTexture)
		{
			HDReflectionDenoiser reflectionDenoiser = GetReflectionDenoiser();
			float historyValidity = EvaluateRayTracedReflectionHistoryValidity(hdCamera, fullResolution, rayTraced: true);
			RTHandle historyBuffer = RequestRayTracedReflectionsHistoryTexture(hdCamera);
			TextureHandle result = reflectionDenoiser.DenoiseRTR(renderGraph, hdCamera, historyValidity, denoiserRadius, fullResolution, singleReflectionBounce, affectSmoothSurfaces, depthPyramid, normalBuffer, motionVectors, clearCoatTexture, input, historyBuffer);
			PropagateRayTracedReflectionsHistoryValidity(hdCamera, fullResolution, rayTraced: true);
			return result;
		}

		private TextureHandle RenderRayTracedReflections(RenderGraph renderGraph, HDCamera hdCamera, in PrepassOutput prepassOutput, TextureHandle clearCoatTexture, Texture skyTexture, TextureHandle rayCountTexture, ShaderVariablesRaytracing shaderVariablesRaytracing, bool transparent)
		{
			ScreenSpaceReflection component = hdCamera.volumeStack.GetComponent<ScreenSpaceReflection>();
			bool flag = false;
			if ((m_Asset.currentPlatformRenderPipelineSettings.supportedRayTracingMode != RenderPipelineSettings.SupportedRayTracingMode.Both) ? (m_Asset.currentPlatformRenderPipelineSettings.supportedRayTracingMode == RenderPipelineSettings.SupportedRayTracingMode.Quality) : (component.tracing.value == RayCastingMode.RayTracing && component.mode.value == RayTracingMode.Quality))
			{
				return RenderReflectionsQuality(renderGraph, hdCamera, prepassOutput.depthBuffer, prepassOutput.stencilBuffer, prepassOutput.normalBuffer, prepassOutput.resolvedMotionVectorsBuffer, rayCountTexture, clearCoatTexture, skyTexture, shaderVariablesRaytracing, transparent);
			}
			return RenderReflectionsPerformance(renderGraph, hdCamera, in prepassOutput, rayCountTexture, clearCoatTexture, skyTexture, shaderVariablesRaytracing, transparent);
		}

		private static RTHandle SubSurfaceHistoryBufferAllocatorFunction(string viewName, int frameIndex, RTHandleSystem rtHandleSystem)
		{
			return rtHandleSystem.Alloc(Vector2.one, TextureXR.slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureXR.dimension, enableRandomWrite: true, useMipMap: false, autoGenerateMips: false, isShadowMap: false, 1, 0f, MSAASamples.None, bindTextureMS: false, useDynamicScale: false, RenderTextureMemoryless.None, VRTextureUsage.None, $"{viewName}_SubSurfaceHistoryBuffer{frameIndex}");
		}

		private void InitializeSubsurfaceScatteringRT()
		{
			ComputeShader subSurfaceRayTracingCS = m_GlobalSettings.renderPipelineRayTracingResources.subSurfaceRayTracingCS;
			ComputeShader deferredRaytracingCS = m_GlobalSettings.renderPipelineRayTracingResources.deferredRaytracingCS;
			m_SSSClearTextureKernel = subSurfaceRayTracingCS.FindKernel("ClearTexture");
			m_RaytracingDiffuseDeferredKernel = deferredRaytracingCS.FindKernel("RaytracingDiffuseDeferred");
			m_CombineSubSurfaceKernel = subSurfaceRayTracingCS.FindKernel("BlendSubSurfaceData");
			m_CombineSubSurfaceWithGIKernel = subSurfaceRayTracingCS.FindKernel("BlendSubSurfaceDataWithGI");
		}

		private void CleanupSubsurfaceScatteringRT()
		{
		}

		private RTHandle RequestRayTracedSSSHistoryTexture(HDCamera hdCamera)
		{
			return hdCamera.GetCurrentFrameRT(16) ?? hdCamera.AllocHistoryFrameRT(16, SubSurfaceHistoryBufferAllocatorFunction, 1);
		}

		private TextureHandle TraceRTSSS(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle sssColor, TextureHandle ssgiBuffer, TextureHandle colorBuffer)
		{
			TraceRTSSSPassData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<TraceRTSSSPassData>("Composing the result of RTSSS", out passData, ProfilingSampler.Get(HDProfileId.RaytracingSSSTrace));
			try
			{
				renderGraphBuilder.EnableAsyncCompute(value: false);
				SubSurfaceScattering component = hdCamera.volumeStack.GetComponent<SubSurfaceScattering>();
				passData.texWidth = hdCamera.actualWidth;
				passData.texHeight = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.sampleCount = component.sampleCount.value;
				passData.clearTextureKernel = m_SSSClearTextureKernel;
				passData.rtDeferredLightingKernel = m_RaytracingDiffuseDeferredKernel;
				passData.rayTracingSubSurfaceRT = m_GlobalSettings.renderPipelineRayTracingResources.subSurfaceRayTracingRT;
				passData.rayTracingSubSurfaceCS = m_GlobalSettings.renderPipelineRayTracingResources.subSurfaceRayTracingCS;
				passData.deferredRayTracingCS = m_GlobalSettings.renderPipelineRayTracingResources.deferredRaytracingCS;
				passData.accelerationStructure = RequestAccelerationStructure(hdCamera);
				passData.lightCluster = RequestLightCluster();
				passData.shaderVariablesRayTracingCB = m_ShaderVariablesRayTracingCB;
				passData.ditheredTextureSet = GetBlueNoiseManager().DitheredTextureSet8SPP();
				passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.Read);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.sssColor = renderGraphBuilder.ReadTexture(in sssColor);
				TraceRTSSSPassData traceRTSSSPassData = passData;
				TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Texture 0"
				};
				traceRTSSSPassData.intermediateBuffer0 = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceRTSSSPassData traceRTSSSPassData2 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Texture 1"
				};
				traceRTSSSPassData2.intermediateBuffer1 = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceRTSSSPassData traceRTSSSPassData3 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Texture 2"
				};
				traceRTSSSPassData3.intermediateBuffer2 = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceRTSSSPassData traceRTSSSPassData4 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Intermediate Texture 3"
				};
				traceRTSSSPassData4.intermediateBuffer3 = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceRTSSSPassData traceRTSSSPassData5 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Distance buffer"
				};
				traceRTSSSPassData5.directionBuffer = renderGraphBuilder.CreateTransientTexture(in desc);
				TraceRTSSSPassData traceRTSSSPassData6 = passData;
				desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
				{
					colorFormat = GraphicsFormat.R16G16B16A16_SFloat,
					enableRandomWrite = true,
					name = "Ray Traced SSS"
				};
				TextureHandle input = renderGraph.CreateTexture(in desc);
				traceRTSSSPassData6.outputBuffer = renderGraphBuilder.WriteTexture(in input);
				renderGraphBuilder.SetRenderFunc(delegate(TraceRTSSSPassData data, RenderGraphContext ctx)
				{
					int threadGroupsX = (data.texWidth + 7) / 8;
					int threadGroupsY = (data.texHeight + 7) / 8;
					ctx.cmd.SetComputeTextureParam(data.rayTracingSubSurfaceCS, data.clearTextureKernel, HDShaderIDs._DiffuseLightingTextureRW, data.outputBuffer);
					ctx.cmd.DispatchCompute(data.rayTracingSubSurfaceCS, data.clearTextureKernel, threadGroupsX, threadGroupsY, data.viewCount);
					ctx.cmd.SetRayTracingShaderPass(data.rayTracingSubSurfaceRT, "SubSurfaceDXR");
					ctx.cmd.SetRayTracingAccelerationStructure(data.rayTracingSubSurfaceRT, HDShaderIDs._RaytracingAccelerationStructureName, data.accelerationStructure);
					BlueNoise.BindDitheredTextureSet(ctx.cmd, data.ditheredTextureSet);
					for (int i = 0; i < data.sampleCount; i++)
					{
						data.shaderVariablesRayTracingCB._RaytracingNumSamples = data.sampleCount;
						data.shaderVariablesRayTracingCB._RaytracingSampleIndex = i;
						data.shaderVariablesRayTracingCB._RayTracingAmbientProbeDimmer = 1f;
						ConstantBuffer.PushGlobal(ctx.cmd, in data.shaderVariablesRayTracingCB, HDShaderIDs._ShaderVariablesRaytracing);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._SSSBufferTexture, data.sssColor);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._StencilTexture, data.depthStencilBuffer, RenderTextureSubElement.Stencil);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._ThroughputTextureRW, data.intermediateBuffer0);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._NormalTextureRW, data.intermediateBuffer1);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._PositionTextureRW, data.intermediateBuffer2);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._DiffuseLightingTextureRW, data.intermediateBuffer3);
						ctx.cmd.SetRayTracingTextureParam(data.rayTracingSubSurfaceRT, HDShaderIDs._DirectionTextureRW, data.directionBuffer);
						ctx.cmd.DispatchRays(data.rayTracingSubSurfaceRT, "RayGenSubSurface", (uint)data.texWidth, (uint)data.texHeight, (uint)data.viewCount);
						data.lightCluster.BindLightClusterData(ctx.cmd);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._DepthTexture, data.depthStencilBuffer);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._ThroughputTextureRW, data.intermediateBuffer0);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._NormalTextureRW, data.intermediateBuffer1);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._PositionTextureRW, data.intermediateBuffer2);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._DirectionTextureRW, data.directionBuffer);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._DiffuseLightingTextureRW, data.intermediateBuffer3);
						ctx.cmd.SetComputeTextureParam(data.deferredRayTracingCS, data.rtDeferredLightingKernel, HDShaderIDs._RaytracingLitBufferRW, data.outputBuffer);
						ctx.cmd.DispatchCompute(data.deferredRayTracingCS, data.rtDeferredLightingKernel, threadGroupsX, threadGroupsY, data.viewCount);
					}
				});
				return passData.outputBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private TextureHandle DenoiseRTSSS(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle rayTracedSSS, TextureHandle depthPyramid, TextureHandle normalBuffer, TextureHandle motionVectorBuffer, TextureHandle historyValidationTexture)
		{
			float historyValidity = EvaluateHistoryValidity(hdCamera);
			TextureHandle historyBuffer = renderGraph.ImportTexture(RequestRayTracedSSSHistoryTexture(hdCamera));
			HDTemporalFilter.TemporalFilterParameters filterParams = default(HDTemporalFilter.TemporalFilterParameters);
			filterParams.singleChannel = false;
			filterParams.historyValidity = historyValidity;
			filterParams.occluderMotionRejection = false;
			filterParams.receiverMotionRejection = true;
			filterParams.exposureControl = false;
			filterParams.fullResolution = true;
			return GetTemporalFilter().Denoise(renderGraph, hdCamera, filterParams, rayTracedSSS, renderGraph.defaultResources.blackTextureXR, historyBuffer, depthPyramid, normalBuffer, motionVectorBuffer, historyValidationTexture);
		}

		private TextureHandle CombineRTSSS(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle rayTracedSSS, TextureHandle depthStencilBuffer, TextureHandle sssColor, TextureHandle ssgiBuffer, TextureHandle diffuseLightingBuffer, TextureHandle colorBuffer)
		{
			ComposeRTSSSPassData passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ComposeRTSSSPassData>("Composing the result of RTSSS", out passData, ProfilingSampler.Get(HDProfileId.RaytracingSSSCompose));
			renderGraphBuilder.EnableAsyncCompute(value: false);
			passData.texWidth = hdCamera.actualWidth;
			passData.texHeight = hdCamera.actualHeight;
			passData.viewCount = hdCamera.viewCount;
			passData.validSSGI = GetIndirectDiffuseMode(hdCamera) != IndirectDiffuseMode.Off;
			passData.combineSSSKernel = (passData.validSSGI ? m_CombineSubSurfaceWithGIKernel : m_CombineSubSurfaceKernel);
			passData.rayTracingSubSurfaceCS = m_GlobalSettings.renderPipelineRayTracingResources.subSurfaceRayTracingCS;
			passData.combineLightingMat = m_CombineLightingPass;
			passData.depthStencilBuffer = renderGraphBuilder.UseDepthBuffer(in depthStencilBuffer, DepthAccess.Read);
			passData.sssColor = renderGraphBuilder.ReadTexture(in sssColor);
			passData.ssgiBuffer = (passData.validSSGI ? renderGraphBuilder.ReadTexture(in ssgiBuffer) : renderGraph.defaultResources.blackTextureXR);
			passData.diffuseLightingBuffer = renderGraphBuilder.ReadTexture(in diffuseLightingBuffer);
			passData.subsurfaceBuffer = renderGraphBuilder.ReadTexture(in rayTracedSSS);
			passData.colorBuffer = renderGraphBuilder.ReadWriteTexture(in colorBuffer);
			renderGraphBuilder.SetRenderFunc(delegate(ComposeRTSSSPassData data, RenderGraphContext ctx)
			{
				int threadGroupsX = (data.texWidth + 7) / 8;
				int threadGroupsY = (data.texHeight + 7) / 8;
				ctx.cmd.SetComputeTextureParam(data.rayTracingSubSurfaceCS, data.combineSSSKernel, HDShaderIDs._SubSurfaceLightingBuffer, data.subsurfaceBuffer);
				ctx.cmd.SetComputeTextureParam(data.rayTracingSubSurfaceCS, data.combineSSSKernel, HDShaderIDs._DiffuseLightingTextureRW, data.diffuseLightingBuffer);
				ctx.cmd.SetComputeTextureParam(data.rayTracingSubSurfaceCS, data.combineSSSKernel, HDShaderIDs._SSSBufferTexture, data.sssColor);
				if (data.validSSGI)
				{
					ctx.cmd.SetComputeTextureParam(data.rayTracingSubSurfaceCS, data.combineSSSKernel, HDShaderIDs._IndirectDiffuseLightingBuffer, data.ssgiBuffer);
				}
				ctx.cmd.DispatchCompute(data.rayTracingSubSurfaceCS, data.combineSSSKernel, threadGroupsX, threadGroupsY, data.viewCount);
				data.combineLightingMat.SetTexture(HDShaderIDs._IrradianceSource, data.diffuseLightingBuffer);
				HDUtils.DrawFullScreen(ctx.cmd, data.combineLightingMat, data.colorBuffer, data.depthStencilBuffer, null, 1);
			});
			return passData.colorBuffer;
		}

		private TextureHandle RenderSubsurfaceScatteringRT(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthStencilBuffer, TextureHandle normalBuffer, TextureHandle colorBuffer, TextureHandle sssColor, TextureHandle diffuseBuffer, TextureHandle motionVectorsBuffer, TextureHandle historyValidationTexture, TextureHandle ssgiBuffer)
		{
			using (new RenderGraphProfilingScope(renderGraph, ProfilingSampler.Get(HDProfileId.RaytracingSSS)))
			{
				TextureHandle rayTracedSSS = TraceRTSSS(renderGraph, hdCamera, depthStencilBuffer, normalBuffer, sssColor, ssgiBuffer, colorBuffer);
				rayTracedSSS = DenoiseRTSSS(renderGraph, hdCamera, rayTracedSSS, depthStencilBuffer, normalBuffer, motionVectorsBuffer, historyValidationTexture);
				PushFullScreenDebugTexture(renderGraph, rayTracedSSS, FullScreenDebugMode.RayTracedSubSurface);
				return CombineRTSSS(renderGraph, hdCamera, rayTracedSSS, depthStencilBuffer, sssColor, ssgiBuffer, diffuseBuffer, colorBuffer);
			}
		}

		private void InitializeWaterSystem()
		{
			m_ActiveWaterSimulation = m_Asset.currentPlatformRenderPipelineSettings.supportWater;
			if (m_ActiveWaterSimulation)
			{
				m_WaterBandResolution = m_Asset.currentPlatformRenderPipelineSettings.waterSimulationResolution;
				m_WaterSimulationCS = m_Asset.renderPipelineResources.shaders.waterSimulationCS;
				m_InitializePhillipsSpectrumKernel = m_WaterSimulationCS.FindKernel("InitializePhillipsSpectrum");
				m_EvaluateDispersionKernel = m_WaterSimulationCS.FindKernel("EvaluateDispersion");
				m_EvaluateNormalsFoamKernel = m_WaterSimulationCS.FindKernel("EvaluateNormalsFoam");
				m_CopyAdditionalDataKernel = m_WaterSimulationCS.FindKernel("CopyAdditionalData");
				m_FindVerticalDisplacementsKernel = m_WaterSimulationCS.FindKernel("FindVerticalDisplacements");
				m_PrepareCausticsGeometryKernel = m_WaterSimulationCS.FindKernel("PrepareCausticsGeometry");
				m_EvaluateInstanceDataKernel = m_WaterSimulationCS.FindKernel("EvaluateInstanceData");
				m_WaterLightingCS = m_Asset.renderPipelineResources.shaders.waterLightingCS;
				m_WaterPrepareSSRKernel = m_WaterLightingCS.FindKernel("WaterPrepareSSR");
				m_WaterDeferredLightingKernel = m_WaterLightingCS.FindKernel("WaterDeferredLighting");
				m_UnderWaterKernel = m_WaterLightingCS.FindKernel("UnderWater");
				m_FourierTransformCS = m_Asset.renderPipelineResources.shaders.fourierTransformCS;
				GetFFTKernels(m_FourierTransformCS, m_WaterBandResolution, out m_RowPassTi_Kernel, out m_ColPassTi_Kernel);
				int waterBandResolution = (int)m_WaterBandResolution;
				int slices = 3;
				m_HtRs = RTHandles.Alloc(waterBandResolution, waterBandResolution, slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
				m_HtIs = RTHandles.Alloc(waterBandResolution, waterBandResolution, slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
				m_FFTRowPassRs = RTHandles.Alloc(waterBandResolution, waterBandResolution, slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
				m_FFTRowPassIs = RTHandles.Alloc(waterBandResolution, waterBandResolution, slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
				m_AdditionalData = RTHandles.Alloc(waterBandResolution, waterBandResolution, slices, DepthBits.None, GraphicsFormat.R16G16B16A16_SFloat, FilterMode.Point, TextureWrapMode.Repeat, TextureDimension.Tex2DArray, enableRandomWrite: true);
				m_WaterMaterialPropertyBlock = new MaterialPropertyBlock();
				m_InternalWaterMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.waterPS);
				InitializeInstancingData();
				m_WaterProfileArrayGPU = new ComputeBuffer(16, Marshal.SizeOf<WaterSurfaceProfile>());
				m_CausticsGeometry = new GraphicsBuffer(GraphicsBuffer.Target.Raw, 393216, 4);
				m_CausticsBufferGeometryInitialized = false;
				m_CausticsMaterial = CoreUtils.CreateEngineMaterial(defaultResources.shaders.waterCausticsPS);
				m_WaterCameraHeightBuffer = new ComputeBuffer(4, 4);
				InitializeCPUWaterSimulation();
				m_UnderWaterSurfaceIndex = -1;
				BuildGridMesh(ref m_TessellableMesh);
			}
		}

		private void ReleaseWaterSystem()
		{
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			int instanceCount = WaterSurface.instanceCount;
			for (int i = 0; i < instanceCount; i++)
			{
				WaterSurface waterSurface = instancesAsArray[i];
				if (waterSurface.simulation != null)
				{
					waterSurface.simulation.ReleaseSimulationResources();
					waterSurface.simulation = null;
				}
			}
			if (m_ActiveWaterSimulation)
			{
				ReleaseCPUWaterSimulation();
				CoreUtils.SafeRelease(m_WaterCameraHeightBuffer);
				CoreUtils.Destroy(m_CausticsMaterial);
				CoreUtils.SafeRelease(m_CausticsGeometry);
				CoreUtils.SafeRelease(m_WaterCameraFrustrumBuffer);
				CoreUtils.SafeRelease(m_WaterPatchDataBuffer);
				CoreUtils.SafeRelease(m_WaterIndirectDispatchBuffer);
				CoreUtils.Destroy(m_InternalWaterMaterial);
				CoreUtils.SafeRelease(m_WaterProfileArrayGPU);
				RTHandles.Release(m_AdditionalData);
				RTHandles.Release(m_FFTRowPassIs);
				RTHandles.Release(m_FFTRowPassRs);
				RTHandles.Release(m_HtIs);
				RTHandles.Release(m_HtRs);
				m_TessellableMesh = null;
			}
		}

		private void InitializeInstancingData()
		{
			m_WaterIndirectDispatchBuffer = new ComputeBuffer(5, 4, ComputeBufferType.DrawIndirect);
			uint[] data = new uint[5] { 98304u, 1u, 0u, 0u, 0u };
			m_WaterIndirectDispatchBuffer.SetData(data);
			m_WaterPatchDataBuffer = new ComputeBuffer(49, 16, ComputeBufferType.Structured);
			m_WaterCameraFrustrumBuffer = new ComputeBuffer(1, Marshal.SizeOf(typeof(FrustumGPU)));
		}

		private void UpdateShaderVariablesWater(WaterSurface currentWater, int surfaceIndex, ref ShaderVariablesWater cb)
		{
			cb._BandResolution = (uint)m_WaterBandResolution;
			cb._PatchSize = currentWater.simulation.spectrum.patchSizes;
			cb._PatchWindSpeed = currentWater.simulation.spectrum.patchWindSpeed;
			cb._PatchWindOrientation = currentWater.simulation.spectrum.patchWindOrientation * (MathF.PI / 180f);
			cb._PatchDirectionDampener = currentWater.simulation.spectrum.patchWindDirDampener;
			cb._PatchAmplitudeMultiplier = currentWater.simulation.rendering.patchAmplitudeMultiplier;
			cb._SimulationTime = currentWater.simulation.simulationTime;
			cb._PatchCurrentSpeed = currentWater.simulation.rendering.patchCurrentSpeed;
			cb._PatchCurrentOrientation = currentWater.simulation.rendering.patchCurrentOrientation * (MathF.PI / 180f);
			cb._PatchFadeStart = currentWater.simulation.rendering.patchFadeStart;
			cb._PatchFadeDistance = currentWater.simulation.rendering.patchFadeDistance;
			cb._PatchFadeValue = currentWater.simulation.rendering.patchFadeValue;
			cb._Choppiness = 2.25f;
			float maxWaveHeight = EvaluateMaxAmplitude(cb._PatchSize.x, cb._PatchWindSpeed.x * 3.6f);
			cb._MaxWaveHeight = maxWaveHeight;
			cb._ScatteringWaveHeight = Mathf.Max(cb._MaxWaveHeight * 0.75f, 1f);
			cb._MaxWaveDisplacement = cb._MaxWaveHeight * cb._Choppiness;
			cb._WaterSmoothness = currentWater.startSmoothness;
			if (currentWater.simulation.spectrum.numActiveBands == 3)
			{
				cb._SimulationFoamAmount = 12f * Mathf.Pow(0.8f + currentWater.simulationFoamAmount * 0.28f, 0.25f);
			}
			else if (currentWater.simulation.spectrum.numActiveBands == 2)
			{
				cb._SimulationFoamAmount = 8f * Mathf.Pow(0.72f + currentWater.simulationFoamAmount * 0.28f, 0.25f);
			}
			else
			{
				cb._SimulationFoamAmount = 4f * Mathf.Pow(0.72f + currentWater.simulationFoamAmount * 0.28f, 0.25f);
			}
			cb._JacobianDrag = 0f;
			cb._SimulationFoamSmoothness = currentWater.simulationFoamSmoothness;
			cb._FoamTilling = currentWater.foamTextureTiling;
			cb._FoamOffsets = Vector2.zero;
			cb._WindFoamAttenuation = Mathf.Clamp(currentWater.windFoamCurve.Evaluate(currentWater.simulation.spectrum.patchWindSpeed.x / 69.44445f), 0f, 1f);
			cb._SurfaceIndex = surfaceIndex & 0xF;
			cb._SSSMaskCoefficient = 1000f;
			Color color = RemapScatteringColor(currentWater.scatteringColor);
			cb._ScatteringColorTips = new Vector4(color.r, color.g, color.b, 0f);
			cb._DeltaTime = currentWater.simulation.deltaTime;
			cb._MaxRefractionDistance = Mathf.Min(currentWater.absorptionDistance, currentWater.maxRefractionDistance);
			cb._OutScatteringCoefficient = (0f - Mathf.Log(0.02f)) / currentWater.absorptionDistance;
			cb._TransparencyColor = new Vector3(Mathf.Min(currentWater.refractionColor.r, 0.99f), Mathf.Min(currentWater.refractionColor.g, 0.99f), Mathf.Min(currentWater.refractionColor.b, 0.99f));
			cb._AmbientScattering = currentWater.ambientScattering;
			cb._HeightBasedScattering = currentWater.heightScattering;
			cb._DisplacementScattering = currentWater.displacementScattering;
			float num = 0.6f;
			float num2 = 0.06f;
			cb._ScatteringLambertLighting = new Vector4(num, num2, Mathf.Lerp(0.5f, 1f, num), Mathf.Lerp(0.5f, 1f, num2));
			cb._FoamJacobianLambda = new Vector4(cb._PatchSize.x, cb._PatchSize.y, cb._PatchSize.z, cb._PatchSize.w);
			cb._CausticsRegionSize = cb._PatchSize[currentWater.causticsBand];
			cb._CausticsBandIndex = currentWater.causticsBand;
			cb._WaterRefSimRes = 256;
			cb._WaterSampleOffset = EvaluateWaterNoiseSampleOffset(m_WaterBandResolution);
			cb._WaterSpectrumOffset = EvaluateFrequencyOffset(m_WaterBandResolution);
			cb._WaterBandCount = currentWater.simulation.spectrum.numActiveBands;
		}

		private void UpdateShaderVariablesWaterRendering(WaterSurface currentWater, HDCamera hdCamera, WaterRendering settings, bool insideUnderWaterVolume, bool infiniteSurface, Vector2 extent, float rotation, ref ShaderVariablesWaterRendering cb)
		{
			cb._CausticsIntensity = currentWater.causticsIntensity;
			cb._CausticsPlaneBlendDistance = currentWater.causticsPlaneBlendDistance;
			cb._InfiniteSurface = (currentWater.IsInfinite() ? 1 : 0);
			cb._WaterCausticsEnabled = (currentWater.caustics ? 1 : 0);
			cb._CameraInUnderwaterRegion = (insideUnderWaterVolume ? 1 : 0);
			cb._FoamIntensity = ((currentWater.surfaceType == WaterSurfaceType.Pool) ? 0f : (currentWater.foam ? 1f : 0f));
			if (infiniteSurface)
			{
				float num = Mathf.Abs(hdCamera.camera.transform.position.y - currentWater.transform.position.y);
				float num2 = Mathf.Lerp(settings.minGridSize.value, settings.maxGridSize.value, Mathf.Clamp((num - 1f) / settings.elevationTransition.value, 0f, 1f));
				cb._GridSize.Set(num2, num2);
				cb._WaterRotation.Set(1f, 0f);
				cb._PatchOffset.Set(hdCamera.camera.transform.position.x, currentWater.transform.position.y, hdCamera.camera.transform.position.z, 0f);
			}
			else
			{
				cb._GridSize.Set(extent.x, extent.y);
				cb._WaterRotation.Set(Mathf.Cos(rotation), Mathf.Sin(rotation));
				cb._PatchOffset = currentWater.transform.position;
			}
			cb._WaterMaskOffset.Set(currentWater.waterMaskOffset.x, 0f - currentWater.waterMaskOffset.y);
			cb._WaterMaskScale.Set(1f / currentWater.waterMaskExtent.x, 1f / currentWater.waterMaskExtent.y);
			cb._FoamMaskOffset.Set(currentWater.foamMaskOffset.x, 0f - currentWater.foamMaskOffset.y);
			cb._FoamMaskScale.Set(1f / currentWater.foamMaskExtent.x, 1f / currentWater.foamMaskExtent.y);
			cb._WaterMaxTessellationFactor = settings.maxTessellationFactor.value;
			cb._WaterTessellationFadeStart = settings.tessellationFactorFadeStart.value;
			cb._WaterTessellationFadeRange = settings.tessellationFactorFadeRange.value;
			if (infiniteSurface)
			{
				cb._NumWaterPatches = EvaluateNumberWaterPatches(cb._WaterLODCount = (uint)settings.numLevelOfDetails.value);
			}
			cb._WaterMaxTessellationFactor = settings.maxTessellationFactor.value;
			cb._WaterTessellationFadeStart = settings.tessellationFactorFadeStart.value;
			cb._WaterTessellationFadeRange = settings.tessellationFactorFadeRange.value;
			cb._WaterDecalLayer = (uint)(hdCamera.frameSettings.IsEnabled(FrameSettingsField.DecalLayers) ? currentWater.decalLayerMask : DecalLayerEnum.Everything);
		}

		private void UpdateGPUWaterSimulation(CommandBuffer cmd, WaterSurface currentWater, bool gpuResourcesInvalid, bool validHistory, ShaderVariablesWater shaderVariablesWater)
		{
			ConstantBuffer.Push(cmd, in shaderVariablesWater, m_WaterSimulationCS, HDShaderIDs._ShaderVariablesWater);
			int numActiveBands = currentWater.simulation.spectrum.numActiveBands;
			SetupWaterShaderKeyword(cmd, numActiveBands);
			int num = (int)m_WaterBandResolution / 8;
			if (gpuResourcesInvalid)
			{
				cmd.SetComputeTextureParam(m_WaterSimulationCS, m_InitializePhillipsSpectrumKernel, HDShaderIDs._H0BufferRW, currentWater.simulation.gpuBuffers.phillipsSpectrumBuffer);
				cmd.DispatchCompute(m_WaterSimulationCS, m_InitializePhillipsSpectrumKernel, num, num, numActiveBands);
			}
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateDispersionKernel, HDShaderIDs._H0Buffer, currentWater.simulation.gpuBuffers.phillipsSpectrumBuffer);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateDispersionKernel, HDShaderIDs._HtRealBufferRW, m_HtRs);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateDispersionKernel, HDShaderIDs._HtImaginaryBufferRW, m_HtIs);
			cmd.DispatchCompute(m_WaterSimulationCS, m_EvaluateDispersionKernel, num, num, numActiveBands);
			shaderVariablesWater._WaterInitialFrame = ((!validHistory) ? 1 : 0);
			ConstantBuffer.Push(cmd, in shaderVariablesWater, m_FourierTransformCS, HDShaderIDs._ShaderVariablesWater);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_RowPassTi_Kernel, HDShaderIDs._FFTRealBuffer, m_HtRs);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_RowPassTi_Kernel, HDShaderIDs._FFTImaginaryBuffer, m_HtIs);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_RowPassTi_Kernel, HDShaderIDs._FFTRealBufferRW, m_FFTRowPassRs);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_RowPassTi_Kernel, HDShaderIDs._FFTImaginaryBufferRW, m_FFTRowPassIs);
			cmd.DispatchCompute(m_FourierTransformCS, m_RowPassTi_Kernel, 1, (int)m_WaterBandResolution, numActiveBands);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_ColPassTi_Kernel, HDShaderIDs._FFTRealBuffer, m_FFTRowPassRs);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_ColPassTi_Kernel, HDShaderIDs._FFTImaginaryBuffer, m_FFTRowPassIs);
			cmd.SetComputeTextureParam(m_FourierTransformCS, m_ColPassTi_Kernel, HDShaderIDs._FFTRealBufferRW, currentWater.simulation.gpuBuffers.displacementBuffer);
			cmd.DispatchCompute(m_FourierTransformCS, m_ColPassTi_Kernel, 1, (int)m_WaterBandResolution, numActiveBands);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateNormalsFoamKernel, HDShaderIDs._WaterDisplacementBuffer, currentWater.simulation.gpuBuffers.displacementBuffer);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateNormalsFoamKernel, HDShaderIDs._PreviousWaterAdditionalDataBuffer, currentWater.simulation.gpuBuffers.additionalDataBuffer);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_EvaluateNormalsFoamKernel, HDShaderIDs._WaterAdditionalDataBufferRW, m_AdditionalData);
			cmd.DispatchCompute(m_WaterSimulationCS, m_EvaluateNormalsFoamKernel, num, num, numActiveBands);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_CopyAdditionalDataKernel, HDShaderIDs._WaterAdditionalDataBuffer, m_AdditionalData);
			cmd.SetComputeTextureParam(m_WaterSimulationCS, m_CopyAdditionalDataKernel, HDShaderIDs._WaterAdditionalDataBufferRW, currentWater.simulation.gpuBuffers.additionalDataBuffer);
			cmd.DispatchCompute(m_WaterSimulationCS, m_CopyAdditionalDataKernel, num, num, numActiveBands);
			currentWater.simulation.gpuBuffers.additionalDataBuffer.rt.GenerateMips();
		}

		private void UpdateWaterSurface(CommandBuffer cmd, WaterSurface currentWater, int surfaceIndex)
		{
			currentWater.CheckResources((int)m_WaterBandResolution, 3, m_ActiveWaterSimulationCPU, out var gpuSpectrumValid, out var cpuSpectrumValid, out var historyValid);
			currentWater.simulation.Update(currentWater.timeMultiplier);
			UpdateShaderVariablesWater(currentWater, surfaceIndex, ref m_ShaderVariablesWater);
			UpdateGPUWaterSimulation(cmd, currentWater, !gpuSpectrumValid, historyValid, m_ShaderVariablesWater);
			UpdateCPUWaterSimulation(currentWater, !cpuSpectrumValid, m_ShaderVariablesWater);
		}

		private void EvaluateWaterCaustics(CommandBuffer cmd, WaterSurface currentWater)
		{
			int num = 256;
			if (!m_CausticsBufferGeometryInitialized)
			{
				int num2 = (num + 7) / 8;
				cmd.SetComputeIntParam(m_WaterSimulationCS, HDShaderIDs._CausticGeometryResolution, num);
				cmd.SetComputeBufferParam(m_WaterSimulationCS, m_PrepareCausticsGeometryKernel, "_CauticsGeometryRW", m_CausticsGeometry);
				cmd.DispatchCompute(m_WaterSimulationCS, m_PrepareCausticsGeometryKernel, num2, num2, 1);
				m_CausticsBufferGeometryInitialized = true;
			}
			int causticsResolution = (int)currentWater.causticsResolution;
			currentWater.simulation.CheckCausticsResources(used: true, causticsResolution);
			ConstantBuffer.Push(cmd, in m_ShaderVariablesWater, m_CausticsMaterial, HDShaderIDs._ShaderVariablesWater);
			CoreUtils.SetRenderTarget(cmd, currentWater.simulation.gpuBuffers.causticsBuffer, ClearFlag.Color, Color.black);
			m_WaterMaterialPropertyBlock.SetTexture(HDShaderIDs._WaterAdditionalDataBuffer, currentWater.simulation.gpuBuffers.additionalDataBuffer);
			m_WaterMaterialPropertyBlock.SetFloat(HDShaderIDs._CausticsVirtualPlane, currentWater.virtualPlaneDistance);
			m_WaterMaterialPropertyBlock.SetInt(HDShaderIDs._CausticsNormalsMipOffset, EvaluateNormalMipOffset(m_WaterBandResolution));
			m_WaterMaterialPropertyBlock.SetInt(HDShaderIDs._CausticGeometryResolution, num);
			cmd.DrawProcedural(m_CausticsGeometry, Matrix4x4.identity, m_CausticsMaterial, 0, MeshTopology.Triangles, 393216, 1, m_WaterMaterialPropertyBlock);
			currentWater.simulation.gpuBuffers.causticsBuffer.rt.GenerateMips();
		}

		private void UpdateWaterSurfaces(CommandBuffer cmd)
		{
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			int instanceCount = WaterSurface.instanceCount;
			if (!m_ActiveWaterSimulation || instanceCount == 0)
			{
				return;
			}
			if (m_TessellableMesh == null)
			{
				BuildGridMesh(ref m_TessellableMesh);
			}
			using (new ProfilingScope(cmd, ProfilingSampler.Get(HDProfileId.WaterSurfaceSimulation)))
			{
				GetBlueNoiseManager().BindDitheredRNGData1SPP(cmd);
				for (int i = 0; i < instanceCount; i++)
				{
					WaterSurface waterSurface = instancesAsArray[i];
					UpdateWaterSurface(cmd, waterSurface, i);
					if (waterSurface.caustics)
					{
						EvaluateWaterCaustics(cmd, waterSurface);
					}
					else
					{
						waterSurface.simulation.CheckCausticsResources(used: false, 0);
					}
				}
			}
		}

		private void EvaluateWaterRenderingData(WaterSurface currentWater, out bool customMesh, out bool infinite, out Mesh targetMesh)
		{
			if (currentWater.IsInfinite())
			{
				infinite = true;
				customMesh = false;
				targetMesh = m_TessellableMesh;
				return;
			}
			infinite = false;
			if (currentWater.geometryType == WaterGeometryType.Quad || currentWater.mesh == null)
			{
				customMesh = false;
				targetMesh = m_TessellableMesh;
			}
			else
			{
				customMesh = true;
				targetMesh = currentWater.mesh;
			}
		}

		private WaterRenderingParameters PrepareWaterRenderingParameters(HDCamera hdCamera, WaterRendering settings, WaterSurface currentWater, int surfaceIndex, bool insideUnderWaterVolume)
		{
			WaterRenderingParameters result = default(WaterRenderingParameters);
			result.cameraPosition = hdCamera.camera.transform.position;
			result.cameraFrustum = hdCamera.frustum;
			result.cameraFarPlane = hdCamera.camera.farClipPlane;
			result.numLODs = (uint)settings.numLevelOfDetails.value;
			result.numActiveBands = currentWater.simulation.spectrum.numActiveBands;
			result.center = currentWater.transform.position;
			result.extent = new Vector2(currentWater.transform.lossyScale.x, currentWater.transform.lossyScale.z);
			result.rotation = (0f - currentWater.transform.eulerAngles.y) * (MathF.PI / 180f);
			result.foamMaskOffset = currentWater.foamMaskOffset;
			result.waterMaskOffset = currentWater.waterMaskOffset;
			EvaluateWaterRenderingData(currentWater, out result.customMesh, out result.infinite, out result.targetMesh);
			result.evaluateCameraPosition = insideUnderWaterVolume;
			result.waterSimulation = m_WaterSimulationCS;
			result.patchEvaluation = m_EvaluateInstanceDataKernel;
			result.simulationCaustics = currentWater.caustics;
			result.waterMask = ((currentWater.waterMask != null) ? currentWater.waterMask : Texture2D.whiteTexture);
			result.surfaceFoam = ((currentWater.foamTexture != null) ? currentWater.foamTexture : m_Asset.renderPipelineResources.textures.foamSurface);
			result.foamMask = ((currentWater.foamMask != null) ? currentWater.foamMask : Texture2D.whiteTexture);
			result.waterMaterial = ((currentWater.customMaterial != null) ? currentWater.customMaterial : m_InternalWaterMaterial);
			result.mbp = m_WaterMaterialPropertyBlock;
			UpdateShaderVariablesWater(currentWater, surfaceIndex, ref result.waterCB);
			UpdateShaderVariablesWaterRendering(currentWater, hdCamera, settings, insideUnderWaterVolume, result.infinite, result.extent, result.rotation, ref result.waterRenderingCB);
			result.simulationCS = m_WaterSimulationCS;
			result.findVerticalDisplKernel = m_FindVerticalDisplacementsKernel;
			return result;
		}

		private WaterRenderingDeferredParameters PrepareWaterRenderingDeferredParameters(HDCamera hdCamera)
		{
			WaterRenderingDeferredParameters result = default(WaterRenderingDeferredParameters);
			result.width = hdCamera.actualWidth;
			result.height = hdCamera.actualHeight;
			result.viewCount = hdCamera.viewCount;
			VisualEnvironment component = hdCamera.volumeStack.GetComponent<VisualEnvironment>();
			result.pbsActive = component.skyType.value == 4;
			result.waterLighting = m_WaterLightingCS;
			result.waterLightingKernel = m_WaterDeferredLightingKernel;
			return result;
		}

		private Vector3 EvaluateWaterAmbientProbe(HDCamera hdCamera, float ambientProbeDimmer)
		{
			SphericalHarmonicsL2 sh = SphericalHarmonicMath.UndoCosineRescaling(m_SkyManager.GetAmbientProbe(hdCamera));
			sh = SphericalHarmonicMath.RescaleCoefficients(sh, ambientProbeDimmer);
			SphericalHarmonicMath.PackCoefficients(m_PackedCoeffsProbe, sh);
			return EvaluateAmbientProbe(in m_PackedCoeffsProbe, Vector3.down);
		}

		private void FillWaterSurfaceProfile(HDCamera hdCamera, WaterRendering settings, WaterSurface waterSurface, int waterSurfaceIndex)
		{
			WaterSurfaceProfile waterSurfaceProfile = default(WaterSurfaceProfile);
			waterSurfaceProfile.bodyScatteringHeight = waterSurface.directLightBodyScattering;
			waterSurfaceProfile.tipScatteringHeight = waterSurface.directLightTipScattering;
			waterSurfaceProfile.waterAmbientProbe = EvaluateWaterAmbientProbe(hdCamera, settings.ambientProbeDimmer.value);
			waterSurfaceProfile.maxRefractionDistance = Mathf.Min(waterSurface.absorptionDistance, waterSurface.maxRefractionDistance);
			waterSurfaceProfile.lightLayers = (uint)waterSurface.lightLayerMask;
			waterSurfaceProfile.cameraUnderWater = ((waterSurfaceIndex == m_UnderWaterSurfaceIndex) ? 1 : 0);
			waterSurfaceProfile.transparencyColor = new Vector3(Mathf.Min(waterSurface.refractionColor.r, 0.99f), Mathf.Min(waterSurface.refractionColor.g, 0.99f), Mathf.Min(waterSurface.refractionColor.b, 0.99f));
			waterSurfaceProfile.outScatteringCoefficient = (0f - Mathf.Log(0.02f)) / waterSurface.absorptionDistance;
			waterSurfaceProfile.scatteringColor = new Vector3(waterSurface.scatteringColor.r, waterSurface.scatteringColor.g, waterSurface.scatteringColor.b);
			waterSurfaceProfile.envPerceptualRoughness = ((waterSurface.surfaceType == WaterSurfaceType.Pool) ? 0f : Mathf.Lerp(0f, 0.15f, Mathf.Clamp(waterSurface.largeWindSpeed / 30f, 0f, 1f)));
			waterSurfaceProfile.smoothnessFadeStart = waterSurface.smoothnessFadeStart;
			waterSurfaceProfile.smoothnessFadeDistance = waterSurface.smoothnessFadeDistance;
			waterSurfaceProfile.roughnessEndValue = 1f - waterSurface.endSmoothness;
			m_WaterSurfaceProfileArray[waterSurfaceIndex] = waterSurfaceProfile;
		}

		private static void RenderWaterSurface(CommandBuffer cmd, RTHandle displacementBuffer, RTHandle additionalDataBuffer, RTHandle causticsBuffer, RTHandle normalBuffer, RTHandle depthPyramid, ComputeBuffer layeredOffsetsBuffer, ComputeBuffer logBaseBuffer, ComputeBuffer cameraHeightBuffer, ComputeBuffer patchDataBuffer, ComputeBuffer indirectBuffer, ComputeBuffer cameraFrustumBuffer, WaterRenderingParameters parameters)
		{
			SetupWaterShaderKeyword(cmd, parameters.numActiveBands);
			if (parameters.evaluateCameraPosition)
			{
				ConstantBuffer.Push(cmd, in parameters.waterCB, parameters.simulationCS, HDShaderIDs._ShaderVariablesWater);
				ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.simulationCS, HDShaderIDs._ShaderVariablesWaterRendering);
				cmd.SetComputeBufferParam(parameters.simulationCS, parameters.findVerticalDisplKernel, HDShaderIDs._WaterCameraHeightBufferRW, cameraHeightBuffer);
				cmd.SetComputeTextureParam(parameters.simulationCS, parameters.findVerticalDisplKernel, HDShaderIDs._WaterDisplacementBuffer, displacementBuffer);
				cmd.SetComputeTextureParam(parameters.simulationCS, parameters.findVerticalDisplKernel, HDShaderIDs._WaterMask, parameters.waterMask);
				cmd.DispatchCompute(parameters.simulationCS, parameters.findVerticalDisplKernel, 1, 1, 1);
			}
			parameters.mbp.SetTexture(HDShaderIDs._WaterDisplacementBuffer, displacementBuffer);
			parameters.mbp.SetTexture(HDShaderIDs._WaterAdditionalDataBuffer, additionalDataBuffer);
			parameters.mbp.SetTexture(HDShaderIDs._WaterCausticsDataBuffer, causticsBuffer);
			parameters.mbp.SetTexture(HDShaderIDs._WaterMask, parameters.waterMask);
			parameters.mbp.SetTexture(HDShaderIDs._FoamTexture, parameters.surfaceFoam);
			parameters.mbp.SetTexture(HDShaderIDs._FoamMask, parameters.foamMask);
			if (layeredOffsetsBuffer != null)
			{
				parameters.mbp.SetBuffer(HDShaderIDs.g_vLayeredOffsetsBuffer, layeredOffsetsBuffer);
			}
			if (logBaseBuffer != null)
			{
				parameters.mbp.SetBuffer(HDShaderIDs.g_logBaseBuffer, logBaseBuffer);
			}
			parameters.mbp.SetBuffer(HDShaderIDs._WaterPatchData, patchDataBuffer);
			parameters.mbp.SetBuffer(HDShaderIDs._WaterCameraHeightBuffer, cameraHeightBuffer);
			parameters.mbp.SetTexture(HDShaderIDs._CameraDepthTexture, depthPyramid);
			parameters.mbp.SetTexture(HDShaderIDs._NormalBufferTexture, normalBuffer);
			cmd.SetGlobalFloat("_StencilWaterRefGBuffer", 24f);
			cmd.SetGlobalFloat("_StencilWaterWriteMaskGBuffer", 24f);
			cmd.SetGlobalFloat("_CullWaterMask", (!parameters.evaluateCameraPosition) ? 2 : 0);
			ConstantBuffer.Push(cmd, in parameters.waterCB, parameters.waterMaterial, HDShaderIDs._ShaderVariablesWater);
			ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.waterMaterial, HDShaderIDs._ShaderVariablesWaterRendering);
			if (parameters.infinite)
			{
				if (SystemInfo.graphicsDeviceType != GraphicsDeviceType.Metal)
				{
					ConstantBuffer.Push(cmd, in parameters.waterCB, parameters.waterSimulation, HDShaderIDs._ShaderVariablesWater);
					ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.waterSimulation, HDShaderIDs._ShaderVariablesWaterRendering);
					cmd.SetComputeBufferParam(parameters.waterSimulation, parameters.patchEvaluation, HDShaderIDs._FrustumGPUBuffer, cameraFrustumBuffer);
					cmd.SetComputeBufferParam(parameters.waterSimulation, parameters.patchEvaluation, HDShaderIDs._WaterPatchDataRW, patchDataBuffer);
					cmd.SetComputeBufferParam(parameters.waterSimulation, parameters.patchEvaluation, HDShaderIDs._WaterInstanceDataRW, indirectBuffer);
					cmd.DispatchCompute(parameters.waterSimulation, parameters.patchEvaluation, 1, 1, 1);
					ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.waterMaterial, HDShaderIDs._ShaderVariablesWaterRendering);
					cmd.DrawMeshInstancedIndirect(parameters.targetMesh, 0, parameters.waterMaterial, 0, indirectBuffer, 0, parameters.mbp);
				}
				else
				{
					int num = (int)(parameters.waterRenderingCB._WaterLODCount - 1);
					float x = parameters.waterRenderingCB._GridSize.x;
					float maxWaveHeight = parameters.waterCB._MaxWaveHeight;
					uint numWaterPatches = parameters.waterRenderingCB._NumWaterPatches;
					float maxWaveDisplacement = parameters.waterCB._MaxWaveDisplacement;
					Vector4 patchOffset = parameters.waterRenderingCB._PatchOffset;
					OrientedBBox obb = default(OrientedBBox);
					for (int i = -num; i <= num; i++)
					{
						for (int j = -num; j <= num; j++)
						{
							ComputeGridBounds(j, i, x, out var center, out var size);
							obb.right = new float3(1f, 0f, 0f);
							obb.up = new float3(0f, 1f, 0f);
							obb.extentX = size.x * 0.5f + maxWaveDisplacement;
							obb.extentY = maxWaveHeight;
							obb.extentZ = size.y * 0.5f + maxWaveDisplacement;
							obb.center = new float3(patchOffset.x + center.x, patchOffset.y, patchOffset.z + center.y);
							if (ShaderConfig.s_CameraRelativeRendering != 0)
							{
								obb.center -= parameters.cameraPosition;
							}
							if (j + num + (i + num) * (1 + num * 2) < numWaterPatches && GeometryUtils.Overlap(obb, parameters.cameraFrustum, 6, 8))
							{
								parameters.waterRenderingCB._GridSize.Set(size.x, size.y);
								parameters.waterRenderingCB._PatchOffset.Set(patchOffset.x + center.x, patchOffset.y, patchOffset.z + center.y, 0f);
								ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.waterMaterial, HDShaderIDs._ShaderVariablesWaterRendering);
								cmd.DrawMesh(parameters.targetMesh, Matrix4x4.identity, parameters.waterMaterial, 0, 0, parameters.mbp);
							}
						}
					}
				}
			}
			else
			{
				ConstantBuffer.Push(cmd, in parameters.waterRenderingCB, parameters.waterMaterial, HDShaderIDs._ShaderVariablesWaterRendering);
				if (!parameters.customMesh)
				{
					cmd.DrawMesh(parameters.targetMesh, Matrix4x4.identity, parameters.waterMaterial, 0, 0, parameters.mbp);
				}
				else
				{
					int subMeshCount = parameters.targetMesh.subMeshCount;
					for (int k = 0; k < subMeshCount; k++)
					{
						cmd.DrawMesh(parameters.targetMesh, Matrix4x4.identity, parameters.waterMaterial, k, 0, parameters.mbp);
					}
				}
			}
			CoreUtils.SetKeyword(cmd, "WATER_ONE_BAND", state: false);
			CoreUtils.SetKeyword(cmd, "WATER_TWO_BANDS", state: false);
			CoreUtils.SetKeyword(cmd, "WATER_THREE_BANDS", state: false);
		}

		private void RenderWaterSurfaceGBuffer(RenderGraph renderGraph, HDCamera hdCamera, WaterSurface currentWater, WaterRendering settings, int surfaceIdx, bool evaluateCameraPos, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle depthPyramid, ComputeBufferHandle layeredOffsetsBuffer, ComputeBufferHandle logBaseBuffer, TextureHandle WaterGbuffer0, TextureHandle WaterGbuffer1, TextureHandle WaterGbuffer2, TextureHandle WaterGbuffer3)
		{
			WaterRenderingGBufferData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<WaterRenderingGBufferData>("Render Water Surface GBuffer", out passData, ProfilingSampler.Get(HDProfileId.WaterSurfaceRenderingGBuffer));
			try
			{
				passData.parameters = PrepareWaterRenderingParameters(hdCamera, settings, currentWater, surfaceIdx, evaluateCameraPos);
				passData.decalsEnabled = hdCamera.frameSettings.IsEnabled(FrameSettingsField.Decals) && DecalSystem.m_DecalDatasCount > 0;
				renderGraphBuilder.UseColorBuffer(in WaterGbuffer0, 0);
				renderGraphBuilder.UseColorBuffer(in WaterGbuffer1, 1);
				renderGraphBuilder.UseColorBuffer(in WaterGbuffer2, 2);
				renderGraphBuilder.UseColorBuffer(in WaterGbuffer3, 3);
				renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.ReadWrite);
				WaterRenderingGBufferData waterRenderingGBufferData = passData;
				ComputeBufferHandle input = renderGraph.ImportComputeBuffer(m_WaterCameraHeightBuffer);
				waterRenderingGBufferData.heightBuffer = renderGraphBuilder.WriteComputeBuffer(in input);
				passData.displacementTexture = renderGraph.ImportTexture(currentWater.simulation.gpuBuffers.displacementBuffer);
				passData.additionalData = renderGraph.ImportTexture(currentWater.simulation.gpuBuffers.additionalDataBuffer);
				passData.causticsData = (passData.parameters.simulationCaustics ? renderGraph.ImportTexture(currentWater.simulation.gpuBuffers.causticsBuffer) : renderGraph.defaultResources.blackTexture);
				passData.indirectBuffer = renderGraph.ImportComputeBuffer(m_WaterIndirectDispatchBuffer);
				passData.patchDataBuffer = renderGraph.ImportComputeBuffer(m_WaterPatchDataBuffer);
				passData.frustumBuffer = renderGraph.ImportComputeBuffer(m_WaterCameraFrustrumBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				passData.layeredOffsetsBuffer = renderGraphBuilder.ReadComputeBuffer(in layeredOffsetsBuffer);
				passData.logBaseBuffer = renderGraphBuilder.ReadComputeBuffer(in logBaseBuffer);
				renderGraphBuilder.SetRenderFunc(delegate(WaterRenderingGBufferData data, RenderGraphContext ctx)
				{
					if (data.decalsEnabled)
					{
						DecalSystem.instance.SetAtlas(ctx.cmd);
					}
					RenderWaterSurface(ctx.cmd, data.displacementTexture, data.additionalData, data.causticsData, data.normalBuffer, data.depthPyramid, data.layeredOffsetsBuffer, data.logBaseBuffer, data.heightBuffer, data.patchDataBuffer, data.indirectBuffer, data.frustumBuffer, data.parameters);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void PropagateFrustumDataToGPU(HDCamera hdCamera)
		{
			FrustumGPU frustumGPU = default(FrustumGPU);
			frustumGPU.normal0 = hdCamera.frustum.planes[0].normal;
			frustumGPU.dist0 = hdCamera.frustum.planes[0].distance;
			frustumGPU.normal1 = hdCamera.frustum.planes[1].normal;
			frustumGPU.dist1 = hdCamera.frustum.planes[1].distance;
			frustumGPU.normal2 = hdCamera.frustum.planes[2].normal;
			frustumGPU.dist2 = hdCamera.frustum.planes[2].distance;
			frustumGPU.normal3 = hdCamera.frustum.planes[3].normal;
			frustumGPU.dist3 = hdCamera.frustum.planes[3].distance;
			frustumGPU.normal4 = hdCamera.frustum.planes[4].normal;
			frustumGPU.dist4 = hdCamera.frustum.planes[4].distance;
			frustumGPU.normal5 = hdCamera.frustum.planes[5].normal;
			frustumGPU.dist5 = hdCamera.frustum.planes[5].distance;
			frustumGPU.corner0 = hdCamera.frustum.corners[0];
			frustumGPU.corner1 = hdCamera.frustum.corners[1];
			frustumGPU.corner2 = hdCamera.frustum.corners[2];
			frustumGPU.corner3 = hdCamera.frustum.corners[3];
			frustumGPU.corner4 = hdCamera.frustum.corners[4];
			frustumGPU.corner5 = hdCamera.frustum.corners[5];
			frustumGPU.corner6 = hdCamera.frustum.corners[6];
			frustumGPU.corner7 = hdCamera.frustum.corners[7];
			m_WaterCameraFrustumCPU[0] = frustumGPU;
			m_WaterCameraFrustrumBuffer.SetData(m_WaterCameraFrustumCPU);
		}

		private WaterGBuffer RenderWaterGBuffer(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle depthBuffer, TextureHandle normalBuffer, TextureHandle colorPyramid, TextureHandle depthPyramid, in BuildGPULightListOutput lightLists)
		{
			WaterGBuffer result = default(WaterGBuffer);
			result.valid = false;
			result.waterGBuffer0 = renderGraph.defaultResources.blackTextureXR;
			result.waterGBuffer1 = renderGraph.defaultResources.blackTextureXR;
			result.waterGBuffer2 = renderGraph.defaultResources.blackTextureXR;
			result.waterGBuffer3 = renderGraph.defaultResources.blackTextureXR;
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			int num = Mathf.Min(WaterSurface.instanceCount, 16);
			WaterRendering component = hdCamera.volumeStack.GetComponent<WaterRendering>();
			if (!component.enable.value || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water) || num == 0 || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentObjects))
			{
				return result;
			}
			EvaluateUnderWaterSurface(hdCamera);
			PropagateFrustumDataToGPU(hdCamera);
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				enableRandomWrite = true,
				name = "Water GBuffer 0"
			};
			TextureHandle textureHandle = renderGraph.CreateTexture(in desc);
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
				enableRandomWrite = true,
				name = "Water GBuffer 1"
			};
			TextureHandle input = renderGraph.CreateTexture(in desc);
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
				enableRandomWrite = true,
				name = "Water GBuffer 2"
			};
			TextureHandle textureHandle2 = renderGraph.CreateTexture(in desc);
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
				enableRandomWrite = true,
				name = "Water GBuffer 3"
			};
			TextureHandle input2 = renderGraph.CreateTexture(in desc);
			for (int i = 0; i < num; i++)
			{
				WaterSurface waterSurface = instancesAsArray[i];
				if (waterSurface.simulation.ValidResources((int)m_WaterBandResolution, 3))
				{
					int num2 = 1 << waterSurface.gameObject.layer;
					if (hdCamera.camera.cullingMask == 0 || (num2 & hdCamera.camera.cullingMask) != 0)
					{
						result.valid = true;
						FillWaterSurfaceProfile(hdCamera, component, waterSurface, i);
						RenderWaterSurfaceGBuffer(renderGraph, hdCamera, waterSurface, component, i, i == m_UnderWaterSurfaceIndex, depthBuffer, normalBuffer, depthPyramid, lightLists.perVoxelOffset, lightLists.perTileLogBaseTweak, textureHandle, input, textureHandle2, input2);
					}
				}
			}
			if (!result.valid)
			{
				return result;
			}
			result.waterGBuffer0 = textureHandle;
			result.waterGBuffer1 = input;
			result.waterGBuffer2 = textureHandle2;
			result.waterGBuffer3 = input2;
			WaterRenderingSSRData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<WaterRenderingSSRData>("Prepare water for SSR", out passData, ProfilingSampler.Get(HDProfileId.WaterSurfaceRenderingSSR));
			try
			{
				passData.width = hdCamera.actualWidth;
				passData.height = hdCamera.actualWidth;
				passData.viewCount = hdCamera.viewCount;
				passData.waterLighting = m_WaterLightingCS;
				passData.prepareSSRKernel = m_WaterPrepareSSRKernel;
				passData.gbuffer1 = renderGraphBuilder.ReadTexture(in input);
				passData.gbuffer3 = renderGraphBuilder.ReadTexture(in input2);
				passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				passData.normalBuffer = renderGraphBuilder.WriteTexture(in normalBuffer);
				WaterRenderingSSRData waterRenderingSSRData = passData;
				ComputeBufferHandle input3 = renderGraph.ImportComputeBuffer(m_WaterCameraHeightBuffer);
				waterRenderingSSRData.heightBuffer = renderGraphBuilder.WriteComputeBuffer(in input3);
				WaterRenderingSSRData waterRenderingSSRData2 = passData;
				input3 = renderGraph.ImportComputeBuffer(m_WaterProfileArrayGPU);
				waterRenderingSSRData2.waterSurfaceProfiles = renderGraphBuilder.ReadComputeBuffer(in input3);
				renderGraphBuilder.SetRenderFunc(delegate(WaterRenderingSSRData data, RenderGraphContext ctx)
				{
					int threadGroupsX = (data.width + 7) / 8;
					int threadGroupsY = (data.height + 7) / 8;
					ctx.cmd.SetComputeTextureParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._WaterGBufferTexture1, data.gbuffer1);
					ctx.cmd.SetComputeTextureParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._WaterGBufferTexture3, data.gbuffer3);
					ctx.cmd.SetComputeBufferParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._WaterCameraHeightBuffer, data.heightBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._StencilTexture, data.depthBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeBufferParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._WaterSurfaceProfiles, data.waterSurfaceProfiles);
					ctx.cmd.SetComputeTextureParam(data.waterLighting, data.prepareSSRKernel, HDShaderIDs._NormalBufferRW, data.normalBuffer);
					ctx.cmd.DispatchCompute(data.waterLighting, data.prepareSSRKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return result;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		private void RenderWaterDebug(RenderGraph renderGraph, HDCamera hdCamera, bool msaa, TextureHandle colorBuffer, TextureHandle depthBuffer, in BuildGPULightListOutput lightLists)
		{
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			int num = Mathf.Min(WaterSurface.instanceCount, 16);
			WaterRendering component = hdCamera.volumeStack.GetComponent<WaterRendering>();
			if (!component.enable.value || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water) || num == 0 || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentObjects))
			{
				return;
			}
			TextureDesc desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.B10G11R11_UFloatPack32,
				bindTextureMS = msaa,
				msaaSamples = hdCamera.msaaSamples,
				clearColor = Color.clear,
				name = (msaa ? "WaterGBuffer0MSAA" : "WaterGBuffer0")
			};
			TextureHandle waterGbuffer = renderGraph.CreateTexture(in desc);
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R8G8B8A8_UNorm,
				bindTextureMS = msaa,
				msaaSamples = hdCamera.msaaSamples,
				clearColor = Color.clear,
				name = (msaa ? "WaterGBuffer2MSAA" : "WaterGBuffer2")
			};
			TextureHandle waterGbuffer2 = renderGraph.CreateTexture(in desc);
			desc = new TextureDesc(Vector2.one, dynamicResolution: true, xrReady: true)
			{
				colorFormat = GraphicsFormat.R16G16_UInt,
				bindTextureMS = msaa,
				msaaSamples = hdCamera.msaaSamples,
				clearColor = Color.clear,
				name = (msaa ? "WaterGBuffer3MSAA" : "WaterGBuffer3")
			};
			TextureHandle waterGbuffer3 = renderGraph.CreateTexture(in desc);
			for (int i = 0; i < num; i++)
			{
				WaterSurface waterSurface = instancesAsArray[i];
				if (waterSurface.simulation.ValidResources((int)m_WaterBandResolution, 3))
				{
					FillWaterSurfaceProfile(hdCamera, component, waterSurface, i);
					RenderWaterSurfaceGBuffer(renderGraph, hdCamera, waterSurface, component, i, evaluateCameraPos: false, depthBuffer, renderGraph.defaultResources.blackTextureXR, renderGraph.defaultResources.blackTextureXR, lightLists.perVoxelOffset, lightLists.perTileLogBaseTweak, waterGbuffer, colorBuffer, waterGbuffer2, waterGbuffer3);
				}
			}
		}

		private void RenderWaterLighting(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle depthBuffer, TextureHandle depthPyramid, TextureHandle volumetricLightingTexture, TextureHandle ssrLighting, in WaterGBuffer waterGBuffer, in BuildGPULightListOutput lightLists)
		{
			if (!hdCamera.volumeStack.GetComponent<WaterRendering>().enable.value || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water) || WaterSurface.instanceCount == 0 || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.TransparentObjects) || !waterGBuffer.valid)
			{
				return;
			}
			m_WaterProfileArrayGPU.SetData(m_WaterSurfaceProfileArray);
			WaterRenderingDeferredData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<WaterRenderingDeferredData>("Render Water Surfaces Deferred", out passData, ProfilingSampler.Get(HDProfileId.WaterSurfaceRenderingDeferred));
			try
			{
				passData.parameters = PrepareWaterRenderingDeferredParameters(hdCamera);
				passData.gbuffer0 = renderGraphBuilder.ReadTexture(in waterGBuffer.waterGBuffer0);
				passData.gbuffer1 = renderGraphBuilder.ReadTexture(in waterGBuffer.waterGBuffer1);
				passData.gbuffer2 = renderGraphBuilder.ReadTexture(in waterGBuffer.waterGBuffer2);
				passData.gbuffer3 = renderGraphBuilder.ReadTexture(in waterGBuffer.waterGBuffer3);
				passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				passData.depthPyramid = renderGraphBuilder.ReadTexture(in depthPyramid);
				WaterRenderingDeferredData waterRenderingDeferredData = passData;
				ComputeBufferHandle input = renderGraph.ImportComputeBuffer(m_WaterProfileArrayGPU);
				waterRenderingDeferredData.waterSurfaceProfiles = renderGraphBuilder.ReadComputeBuffer(in input);
				passData.scatteringFallbackTexture = renderGraph.defaultResources.blackTexture3DXR;
				passData.volumetricLightingTexture = renderGraphBuilder.ReadTexture(in volumetricLightingTexture);
				WaterRenderingDeferredData waterRenderingDeferredData2 = passData;
				input = renderGraph.ImportComputeBuffer(m_WaterCameraHeightBuffer);
				waterRenderingDeferredData2.heightBuffer = renderGraphBuilder.WriteComputeBuffer(in input);
				passData.transparentSSRLighting = renderGraphBuilder.ReadTexture(in ssrLighting);
				passData.perVoxelOffset = renderGraphBuilder.ReadComputeBuffer(in lightLists.perVoxelOffset);
				passData.perTileLogBaseTweak = renderGraphBuilder.ReadComputeBuffer(in lightLists.perTileLogBaseTweak);
				passData.colorBuffer = renderGraphBuilder.WriteTexture(in colorBuffer);
				renderGraphBuilder.SetRenderFunc(delegate(WaterRenderingDeferredData data, RenderGraphContext ctx)
				{
					int threadGroupsX = (data.parameters.width + 7) / 8;
					int threadGroupsY = (data.parameters.height + 7) / 8;
					if (!data.parameters.pbsActive)
					{
						ctx.cmd.SetGlobalTexture(HDShaderIDs._AirSingleScatteringTexture, data.scatteringFallbackTexture);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._AerosolSingleScatteringTexture, data.scatteringFallbackTexture);
						ctx.cmd.SetGlobalTexture(HDShaderIDs._MultipleScatteringTexture, data.scatteringFallbackTexture);
					}
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterGBufferTexture0, data.gbuffer0);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterGBufferTexture1, data.gbuffer1);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterGBufferTexture2, data.gbuffer2);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterGBufferTexture3, data.gbuffer3);
					ctx.cmd.SetComputeBufferParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterSurfaceProfiles, data.waterSurfaceProfiles);
					ctx.cmd.SetComputeBufferParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._WaterCameraHeightBuffer, data.heightBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._StencilTexture, data.depthBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._SsrLightingTexture, data.transparentSSRLighting);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._VBufferLighting, data.volumetricLightingTexture);
					ctx.cmd.SetComputeBufferParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs.g_vLayeredOffsetsBuffer, data.perVoxelOffset);
					ctx.cmd.SetComputeBufferParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs.g_logBaseBuffer, data.perTileLogBaseTweak);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._CameraDepthTexture, data.depthPyramid);
					ctx.cmd.SetComputeTextureParam(data.parameters.waterLighting, data.parameters.waterLightingKernel, HDShaderIDs._CameraColorTextureRW, data.colorBuffer);
					ctx.cmd.DispatchCompute(data.parameters.waterLighting, data.parameters.waterLightingKernel, threadGroupsX, threadGroupsY, data.parameters.viewCount);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		internal static int ButterFlyCount(WaterSimulationResolution simRes)
		{
			return simRes switch
			{
				WaterSimulationResolution.High256 => 8, 
				WaterSimulationResolution.Medium128 => 7, 
				WaterSimulationResolution.Low64 => 6, 
				_ => 0, 
			};
		}

		private void InitializeCPUWaterSimulation()
		{
			if (m_Asset.currentPlatformRenderPipelineSettings.waterCPUSimulation)
			{
				m_ActiveWaterSimulationCPU = true;
				int waterBandResolution = (int)m_WaterBandResolution;
				htR0 = new NativeArray<float4>(waterBandResolution * waterBandResolution, Allocator.Persistent);
				htI0 = new NativeArray<float4>(waterBandResolution * waterBandResolution, Allocator.Persistent);
				htR1 = new NativeArray<float4>(waterBandResolution * waterBandResolution, Allocator.Persistent);
				htI1 = new NativeArray<float4>(waterBandResolution * waterBandResolution, Allocator.Persistent);
				pingPong = new NativeArray<float3>(waterBandResolution * waterBandResolution * 4, Allocator.Persistent);
				indices = new NativeArray<uint4>(waterBandResolution * waterBandResolution, Allocator.Persistent);
			}
		}

		private void ReleaseCPUWaterSimulation()
		{
			if (m_ActiveWaterSimulationCPU)
			{
				htR0.Dispose();
				htI0.Dispose();
				htR1.Dispose();
				htI1.Dispose();
				pingPong.Dispose();
				indices.Dispose();
			}
		}

		private void UpdateCPUWaterSimulation(WaterSurface waterSurface, bool evaluateSpetrum, ShaderVariablesWater shaderVariablesWater)
		{
			if (!m_ActiveWaterSimulationCPU || !waterSurface.cpuSimulation)
			{
				return;
			}
			WaterSimulationResolution simulationResolutionCPU = waterSurface.GetSimulationResolutionCPU();
			uint num = (uint)simulationResolutionCPU * (uint)simulationResolutionCPU;
			int waterSampleOffset = EvaluateWaterNoiseSampleOffset(simulationResolutionCPU);
			if (evaluateSpetrum)
			{
				for (int i = 0; i < shaderVariablesWater._WaterBandCount; i++)
				{
					WaterCPUSimulation.PhillipsSpectrumInitialization jobData = default(WaterCPUSimulation.PhillipsSpectrumInitialization);
					jobData.simulationResolution = (int)simulationResolutionCPU;
					jobData.waterSampleOffset = waterSampleOffset;
					jobData.sliceIndex = i;
					jobData.windOrientation = shaderVariablesWater._PatchWindOrientation[i];
					jobData.windSpeed = shaderVariablesWater._PatchWindSpeed[i];
					jobData.patchSize = shaderVariablesWater._PatchSize[i];
					jobData.directionDampner = shaderVariablesWater._PatchDirectionDampener[i];
					jobData.bufferOffset = (int)(i * num);
					jobData.H0Buffer = waterSurface.simulation.cpuBuffers.h0BufferCPU;
					IJobParallelForExtensions.Schedule(jobData, (int)num, 1).Complete();
				}
			}
			int num2 = EvaluateCPUBandCount(waterSurface.surfaceType, waterSurface.ripples, waterSurface.cpuEvaluateRipples);
			for (int j = 0; j < num2; j++)
			{
				WaterCPUSimulation.EvaluateDispersion jobData2 = default(WaterCPUSimulation.EvaluateDispersion);
				jobData2.simulationResolution = (int)simulationResolutionCPU;
				jobData2.patchSize = shaderVariablesWater._PatchSize[j];
				jobData2.bufferOffset = (int)(j * num);
				jobData2.simulationTime = shaderVariablesWater._SimulationTime;
				jobData2.H0Buffer = waterSurface.simulation.cpuBuffers.h0BufferCPU;
				jobData2.HtRealBuffer = htR0;
				jobData2.HtImaginaryBuffer = htI0;
				JobHandle dependsOn = IJobParallelForExtensions.Schedule(jobData2, (int)num, 1);
				dependsOn.Complete();
				WaterCPUSimulation.InverseFFT jobData3 = default(WaterCPUSimulation.InverseFFT);
				jobData3.simulationResolution = (int)simulationResolutionCPU;
				jobData3.butterflyCount = ButterFlyCount(simulationResolutionCPU);
				jobData3.bufferOffset = 0;
				jobData3.columnPass = false;
				jobData3.HtRealBufferInput = htR0;
				jobData3.HtImaginaryBufferInput = htI0;
				jobData3.pingPongArray = pingPong;
				jobData3.textureIndicesArray = indices;
				jobData3.HtRealBufferOutput = htR1;
				jobData3.HtImaginaryBufferOutput = htI1;
				JobHandle dependsOn2 = IJobParallelForExtensions.Schedule(jobData3, (int)simulationResolutionCPU, 1, dependsOn);
				dependsOn2.Complete();
				WaterCPUSimulation.InverseFFT jobData4 = default(WaterCPUSimulation.InverseFFT);
				jobData4.simulationResolution = (int)simulationResolutionCPU;
				jobData4.butterflyCount = ButterFlyCount(simulationResolutionCPU);
				jobData4.bufferOffset = (int)(j * num);
				jobData4.columnPass = true;
				jobData4.HtRealBufferInput = htR1;
				jobData4.HtImaginaryBufferInput = htI1;
				jobData4.pingPongArray = pingPong;
				jobData4.textureIndicesArray = indices;
				jobData4.HtRealBufferOutput = waterSurface.simulation.cpuBuffers.displacementBufferCPU;
				jobData4.HtImaginaryBufferOutput = htR0;
				IJobParallelForExtensions.Schedule(jobData4, (int)simulationResolutionCPU, 1, dependsOn2).Complete();
			}
		}

		private static int SignedMod(int x, int m)
		{
			int num = x % m;
			if (num >= 0)
			{
				return num;
			}
			return num + m;
		}

		private static float4 LoadDisplacementData(NativeArray<float4> displacementBuffer, int2 coord, int bandIndex, int simResolution)
		{
			int2 @int = coord;
			@int.x = SignedMod(@int.x, simResolution);
			@int.y = SignedMod(@int.y, simResolution);
			int num = simResolution * simResolution * bandIndex;
			return displacementBuffer[@int.x + @int.y * simResolution + num];
		}

		private static void PrepareCoordinates(float2 uv, int resolution, out int2 tapCoord, out float2 fract)
		{
			float2 x = uv * resolution - 0.5f;
			tapCoord = (int2)math.floor(math.floor(x) + 0.5f);
			fract = math.frac(x);
		}

		private static float4 SampleDisplacementBilinear(NativeArray<float4> displacementBuffer, float2 uvCoord, int bandIndex, int simResolution)
		{
			PrepareCoordinates(uvCoord, simResolution, out var tapCoord, out var fract);
			float4 x = LoadDisplacementData(displacementBuffer, tapCoord, bandIndex, simResolution);
			float4 y = LoadDisplacementData(displacementBuffer, tapCoord + new int2(1, 0), bandIndex, simResolution);
			float4 x2 = LoadDisplacementData(displacementBuffer, tapCoord + new int2(0, 1), bandIndex, simResolution);
			float4 y2 = LoadDisplacementData(displacementBuffer, tapCoord + new int2(1, 1), bandIndex, simResolution);
			float4 x3 = math.lerp(x, y, fract.x);
			float4 y3 = math.lerp(x2, y2, fract.x);
			return math.lerp(x3, y3, fract.y);
		}

		internal static float3 EvaluateWaterDisplacement(WaterSimSearchData wsd, Vector3 positionAWS, Vector3 currentOrientation, Vector3 currentSpeed, float simulationTime, float4 bandsMultiplier)
		{
			Vector2 vector = new Vector2(positionAWS.x, positionAWS.z);
			Vector2 vector2 = (vector - OrientationToDirection(currentOrientation.x) * currentSpeed.x * simulationTime) / wsd.spectrum.patchSizes.x;
			Vector2 vector3 = (vector - OrientationToDirection(currentOrientation.y) * currentSpeed.y * simulationTime) / wsd.spectrum.patchSizes.y;
			Vector2 vector4 = (vector - OrientationToDirection(currentOrientation.z) * currentSpeed.z * simulationTime) / wsd.spectrum.patchSizes.z;
			float3 @float = 0f;
			float3 float2 = SampleDisplacementBilinear(wsd.displacementData, vector2, 0, wsd.simulationRes).xyz * wsd.rendering.patchAmplitudeMultiplier.x * bandsMultiplier.x;
			@float += float2;
			if (wsd.activeBandCount >= 2)
			{
				float2 = SampleDisplacementBilinear(wsd.displacementData, vector3, 1, wsd.simulationRes).xyz * wsd.rendering.patchAmplitudeMultiplier.y * bandsMultiplier.y;
				@float += float2;
			}
			if (wsd.activeBandCount == 3)
			{
				float2 = SampleDisplacementBilinear(wsd.displacementData, vector4, 2, wsd.simulationRes).xyz * wsd.rendering.patchAmplitudeMultiplier.z * bandsMultiplier.z;
				@float += float2;
			}
			@float.yz *= 2.25f;
			return new float3(0f - @float.y, @float.x, 0f - @float.z);
		}

		private static WaterSimulationTapData EvaluateDisplacementData(WaterSimSearchData wsd, float3 currentLocation, float3 referencePosition)
		{
			WaterSimulationTapData result = default(WaterSimulationTapData);
			result.currentDisplacement = EvaluateWaterDisplacement(wsd, currentLocation, wsd.rendering.patchCurrentOrientation, wsd.rendering.patchCurrentSpeed, wsd.rendering.simulationTime, new float4(1f, 1f, 1f, 1f));
			result.displacedPoint = currentLocation + result.currentDisplacement;
			result.offset = referencePosition.xz - result.displacedPoint.xz;
			result.distance = Mathf.Sqrt(result.offset.x * result.offset.x + result.offset.y * result.offset.y);
			result.height = result.currentDisplacement.y + wsd.waterSurfaceElevation;
			return result;
		}

		internal static void FindWaterSurfaceHeight(WaterSimSearchData wsd, WaterSearchParameters wsp, out WaterSearchResult sr)
		{
			WaterSimulationTapData waterSimulationTapData = EvaluateDisplacementData(wsd, wsp.startPosition, wsp.targetPosition);
			float2 offset = waterSimulationTapData.offset;
			sr.error = waterSimulationTapData.distance;
			sr.height = waterSimulationTapData.height;
			sr.candidateLocation = wsp.startPosition;
			sr.numIterations = 0;
			while (sr.numIterations < wsp.maxIterations && !(sr.error < wsp.error))
			{
				bool flag = false;
				float3 @float = sr.candidateLocation + new float3(offset.x, 0f, offset.y);
				waterSimulationTapData = EvaluateDisplacementData(wsd, @float, wsp.targetPosition);
				if (waterSimulationTapData.distance < sr.error)
				{
					sr.candidateLocation = @float;
					offset = waterSimulationTapData.offset;
					sr.error = waterSimulationTapData.distance;
					sr.height = waterSimulationTapData.height;
					flag = true;
				}
				if (!flag)
				{
					offset *= 0.5f;
				}
				sr.numIterations++;
			}
		}

		private void EvaluateUnderWaterSurface(HDCamera hdCamera)
		{
			m_UnderWaterSurfaceIndex = -1;
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			int instanceCount = WaterSurface.instanceCount;
			if (!hdCamera.volumeStack.GetComponent<WaterRendering>().enable.value || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water) || instanceCount == 0)
			{
				return;
			}
			Vector3 position = hdCamera.camera.transform.position;
			int num = -1;
			for (int i = 0; i < instanceCount; i++)
			{
				WaterSurface waterSurface = instancesAsArray[i];
				if (!waterSurface.underWater)
				{
					continue;
				}
				if (waterSurface.IsInfinite())
				{
					if (waterSurface.simulation.ValidResources((int)m_WaterBandResolution, 3))
					{
						float num2 = EvaluateMaxAmplitude(waterSurface.simulation.spectrum.patchSizes.x, waterSurface.simulation.spectrum.patchWindSpeed.x * 3.6f);
						float num3 = waterSurface.transform.position.y + num2 * 1.5f;
						float num4 = waterSurface.transform.position.y - waterSurface.volumeDepth;
						if (position.y > num4 && position.y < num3 && num < waterSurface.volumePrority)
						{
							m_UnderWaterSurfaceIndex = i;
							num = waterSurface.volumePrority;
						}
					}
				}
				else if (waterSurface.volumeBounds != null && waterSurface.volumeBounds.bounds.Contains(position) && num < waterSurface.volumePrority)
				{
					m_UnderWaterSurfaceIndex = i;
					num = waterSurface.volumePrority;
				}
			}
		}

		private TextureHandle RenderUnderWaterVolume(RenderGraph renderGraph, HDCamera hdCamera, TextureHandle colorBuffer, TextureHandle normalBuffer, TextureHandle depthBuffer)
		{
			if (m_UnderWaterSurfaceIndex == -1 || WaterSurface.instancesAsArray == null || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water))
			{
				return colorBuffer;
			}
			UnderWaterRenderingData passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<UnderWaterRenderingData>("Render Under Water", out passData, ProfilingSampler.Get(HDProfileId.WaterSurfaceRenderingUnderWater));
			try
			{
				WaterSurface waterSurface = WaterSurface.instancesAsArray[m_UnderWaterSurfaceIndex];
				passData.width = hdCamera.actualWidth;
				passData.height = hdCamera.actualHeight;
				passData.viewCount = hdCamera.viewCount;
				passData.waterLightingCS = m_WaterLightingCS;
				passData.underWaterKernel = m_UnderWaterKernel;
				passData.underWaterCB._MaxViewDistanceMultiplier = waterSurface.absorbtionDistanceMultiplier;
				passData.underWaterCB._WaterScatteringColor = waterSurface.scatteringColor;
				passData.underWaterCB._WaterRefractionColor = waterSurface.refractionColor;
				passData.underWaterCB._OutScatteringCoeff = (0f - Mathf.Log(0.02f)) / waterSurface.absorptionDistance;
				passData.underWaterCB._WaterTransitionSize = waterSurface.transitionSize;
				passData.colorBuffer = renderGraphBuilder.ReadTexture(in colorBuffer);
				passData.normalBuffer = renderGraphBuilder.ReadTexture(in normalBuffer);
				passData.depthBuffer = renderGraphBuilder.UseDepthBuffer(in depthBuffer, DepthAccess.Read);
				UnderWaterRenderingData underWaterRenderingData = passData;
				ComputeBufferHandle input = renderGraph.ImportComputeBuffer(m_WaterCameraHeightBuffer);
				underWaterRenderingData.cameraHeightBuffer = renderGraphBuilder.ReadComputeBuffer(in input);
				passData.causticsData = (waterSurface.caustics ? renderGraph.ImportTexture(waterSurface.simulation.gpuBuffers.causticsBuffer) : renderGraph.defaultResources.blackTexture);
				passData.waterRenderingCB._CausticsIntensity = waterSurface.causticsIntensity;
				passData.waterRenderingCB._CausticsPlaneBlendDistance = waterSurface.causticsPlaneBlendDistance;
				passData.waterRenderingCB._PatchOffset = waterSurface.transform.position;
				passData.waterRenderingCB._WaterCausticsEnabled = (waterSurface.caustics ? 1 : 0);
				passData.waterCB._CausticsRegionSize = waterSurface.simulation.spectrum.patchSizes[waterSurface.causticsBand];
				UnderWaterRenderingData underWaterRenderingData2 = passData;
				TextureHandle input2 = CreateColorBuffer(m_RenderGraph, hdCamera, msaa: false);
				underWaterRenderingData2.outputColorBuffer = renderGraphBuilder.WriteTexture(in input2);
				renderGraphBuilder.SetRenderFunc(delegate(UnderWaterRenderingData data, RenderGraphContext ctx)
				{
					int threadGroupsX = (data.width + 7) / 8;
					int threadGroupsY = (data.height + 7) / 8;
					ConstantBuffer.Push(ctx.cmd, in data.underWaterCB, data.waterLightingCS, HDShaderIDs._ShaderVariablesUnderWater);
					ConstantBuffer.Push(ctx.cmd, in data.waterRenderingCB, data.waterLightingCS, HDShaderIDs._ShaderVariablesWaterRendering);
					ConstantBuffer.Push(ctx.cmd, in data.waterCB, data.waterLightingCS, HDShaderIDs._ShaderVariablesWater);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._WaterCausticsDataBuffer, data.causticsData);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._NormalBufferTexture, data.normalBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._CameraColorTexture, data.colorBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._DepthTexture, data.depthBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._StencilTexture, data.depthBuffer, 0, RenderTextureSubElement.Stencil);
					ctx.cmd.SetComputeBufferParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._WaterCameraHeightBuffer, data.cameraHeightBuffer);
					ctx.cmd.SetComputeTextureParam(data.waterLightingCS, data.underWaterKernel, HDShaderIDs._CameraColorTextureRW, data.outputColorBuffer);
					ctx.cmd.DispatchCompute(data.waterLightingCS, data.underWaterKernel, threadGroupsX, threadGroupsY, data.viewCount);
				});
				return passData.outputColorBuffer;
			}
			finally
			{
				((IDisposable)renderGraphBuilder).Dispose();
			}
		}

		internal static void GetFFTKernels(ComputeShader fourierTransformCS, WaterSimulationResolution resolution, out int rowKernel, out int columnKernel)
		{
			switch (resolution)
			{
			case WaterSimulationResolution.High256:
				rowKernel = fourierTransformCS.FindKernel("RowPassTi_256");
				columnKernel = fourierTransformCS.FindKernel("ColPassTi_256");
				break;
			case WaterSimulationResolution.Medium128:
				rowKernel = fourierTransformCS.FindKernel("RowPassTi_128");
				columnKernel = fourierTransformCS.FindKernel("ColPassTi_128");
				break;
			case WaterSimulationResolution.Low64:
				rowKernel = fourierTransformCS.FindKernel("RowPassTi_64");
				columnKernel = fourierTransformCS.FindKernel("ColPassTi_64");
				break;
			default:
				rowKernel = fourierTransformCS.FindKernel("RowPassTi_64");
				columnKernel = fourierTransformCS.FindKernel("ColPassTi_64");
				break;
			}
		}

		internal static float EvaluateFrequencyOffset(WaterSimulationResolution resolution)
		{
			switch (resolution)
			{
			default:
				_ = 256;
				return 0.5f;
			case WaterSimulationResolution.Medium128:
				return 0.25f;
			case WaterSimulationResolution.Low64:
				return 0.125f;
			}
		}

		internal static int EvaluateWaterNoiseSampleOffset(WaterSimulationResolution resolution)
		{
			switch (resolution)
			{
			default:
				_ = 256;
				return 0;
			case WaterSimulationResolution.Medium128:
				return 64;
			case WaterSimulationResolution.Low64:
				return 96;
			}
		}

		internal static void BuildGridMesh(ref Mesh mesh)
		{
			int num = 128;
			mesh = new Mesh();
			Vector3[] array = new Vector3[(num + 1) * (num + 1)];
			int num2 = 0;
			for (int i = 0; i <= num; i++)
			{
				int num3 = 0;
				while (num3 <= num)
				{
					array[num2] = new Vector3((float)num3 / (float)num - 0.5f, 0f, (float)i / (float)num - 0.5f);
					num3++;
					num2++;
				}
			}
			mesh.vertices = array;
			Vector3[] array2 = new Vector3[(num + 1) * (num + 1)];
			int num4 = 0;
			for (int j = 0; j <= num; j++)
			{
				int num5 = 0;
				while (num5 <= num)
				{
					array2[num4] = new Vector3(0f, 1f, 0f);
					num5++;
					num4++;
				}
			}
			mesh.normals = array2;
			int[] array3 = new int[num * num * 6];
			int num6 = 0;
			int num7 = 0;
			int num8 = 0;
			while (num8 < num)
			{
				int num9 = 0;
				while (num9 < num)
				{
					array3[num6] = num7;
					array3[num6 + 3] = (array3[num6 + 2] = num7 + 1);
					array3[num6 + 4] = (array3[num6 + 1] = num7 + num + 1);
					array3[num6 + 5] = num7 + num + 2;
					num9++;
					num6 += 6;
					num7++;
				}
				num8++;
				num7++;
			}
			mesh.triangles = array3;
		}

		internal static Vector2 OrientationToDirection(float orientation)
		{
			float f = orientation * (MathF.PI / 180f);
			float x = Mathf.Cos(f);
			float y = Mathf.Sin(f);
			return new Vector2(x, y);
		}

		internal static float EvaluateSwellSecondPatchSize(float maxPatchSize)
		{
			float t = (maxPatchSize - 250f) / 4750f;
			return Mathf.Lerp(5f, 50f, t);
		}

		internal static float SampleMaxAmplitudeTable(int2 pixelCoord)
		{
			int num = Mathf.Clamp(pixelCoord.x, 0, 31);
			int num2 = Mathf.Clamp(pixelCoord.y, 0, 31);
			int num3 = num + num2 * 32;
			return WaterConsts.k_MaximumAmplitudeTable[num3];
		}

		internal static float EvaluateMaxAmplitude(float patchSize, float windSpeed)
		{
			PrepareCoordinates(new Vector2(windSpeed / 250f, Mathf.Clamp((patchSize - 25f) / 4975f, 0f, 1f)), 31, out var tapCoord, out var fract);
			float x = SampleMaxAmplitudeTable(tapCoord);
			float y = SampleMaxAmplitudeTable(tapCoord + new int2(1, 0));
			float x2 = SampleMaxAmplitudeTable(tapCoord + new int2(0, 1));
			float y2 = SampleMaxAmplitudeTable(tapCoord + new int2(1, 1));
			float x3 = math.lerp(x, y, fract.x);
			float y3 = math.lerp(x2, y2, fract.x);
			return math.lerp(x3, y3, fract.y);
		}

		internal static Color RemapScatteringColor(Color scatteringColor)
		{
			Color.RGBToHSV(scatteringColor, out var H, out var S, out var V);
			V *= V;
			return Color.HSVToRGB(H, S, V);
		}

		internal static int EvaluateNormalMipOffset(WaterSimulationResolution resolution)
		{
			return resolution switch
			{
				WaterSimulationResolution.High256 => 2, 
				WaterSimulationResolution.Medium128 => 1, 
				WaterSimulationResolution.Low64 => 0, 
				_ => 0, 
			};
		}

		internal static uint EvaluateNumberWaterPatches(uint numLOD)
		{
			return numLOD switch
			{
				1u => 1u, 
				2u => 9u, 
				3u => 25u, 
				4u => 49u, 
				_ => 1u, 
			};
		}

		private uint4 ShiftUInt(uint4 val, int numBits)
		{
			return new uint4(val.x >> 16, val.y >> 16, val.z >> 16, val.w >> 16);
		}

		private uint4 WaterHashFunctionUInt4(uint3 coord)
		{
			uint4 xyzz = coord.xyzz;
			xyzz = (ShiftUInt(xyzz, 16) ^ xyzz.yzxy) * 73244475u;
			xyzz = (ShiftUInt(xyzz, 16) ^ xyzz.yzxz) * 73244475u;
			return (ShiftUInt(xyzz, 16) ^ xyzz.yzxx) * 73244475u;
		}

		private float4 WaterHashFunctionFloat4(uint3 p)
		{
			uint4 @uint = WaterHashFunctionUInt4(p);
			return new float4(@uint.x, @uint.y, @uint.z, @uint.w) / 4.2949673E+09f;
		}

		private static void SetupWaterShaderKeyword(CommandBuffer cmd, int bandCount)
		{
			switch (bandCount)
			{
			case 1:
				CoreUtils.SetKeyword(cmd, "WATER_ONE_BAND", state: true);
				CoreUtils.SetKeyword(cmd, "WATER_TWO_BANDS", state: false);
				CoreUtils.SetKeyword(cmd, "WATER_THREE_BANDS", state: false);
				break;
			case 2:
				CoreUtils.SetKeyword(cmd, "WATER_ONE_BAND", state: false);
				CoreUtils.SetKeyword(cmd, "WATER_TWO_BANDS", state: true);
				CoreUtils.SetKeyword(cmd, "WATER_THREE_BANDS", state: false);
				break;
			default:
				CoreUtils.SetKeyword(cmd, "WATER_ONE_BAND", state: false);
				CoreUtils.SetKeyword(cmd, "WATER_TWO_BANDS", state: false);
				CoreUtils.SetKeyword(cmd, "WATER_THREE_BANDS", state: true);
				break;
			}
		}

		internal static int EvaluateBandCount(WaterSurfaceType surfaceType, bool ripplesOn)
		{
			switch (surfaceType)
			{
			case WaterSurfaceType.OceanSeaLake:
				if (!ripplesOn)
				{
					return 2;
				}
				return 3;
			case WaterSurfaceType.River:
				if (!ripplesOn)
				{
					return 1;
				}
				return 2;
			case WaterSurfaceType.Pool:
				return 1;
			default:
				return 1;
			}
		}

		internal static int EvaluateCPUBandCount(WaterSurfaceType surfaceType, bool ripplesOn, bool evaluateRipplesCPU)
		{
			switch (surfaceType)
			{
			case WaterSurfaceType.OceanSeaLake:
				if (!evaluateRipplesCPU)
				{
					return 2;
				}
				if (!ripplesOn)
				{
					return 2;
				}
				return 3;
			case WaterSurfaceType.River:
				if (!evaluateRipplesCPU)
				{
					return 1;
				}
				if (!ripplesOn)
				{
					return 1;
				}
				return 1;
			case WaterSurfaceType.Pool:
				return 1;
			default:
				return 1;
			}
		}

		private static void ComputeGridBounds(int x, int y, float centerGridSize, out float2 center, out float2 size)
		{
			int num = math.abs(x);
			int num2 = math.abs(y);
			float num3 = math.sign(x);
			float num4 = math.sign(y);
			size = math.float2(centerGridSize * sizeMultiplier[num], centerGridSize * sizeMultiplier[num2]);
			center = math.float2(num3 * (offsets[num] * centerGridSize + size.x * 0.5f), num4 * (offsets[num2] * centerGridSize + size.y * 0.5f));
		}

		private void RenderWaterAsWireFrame(CommandBuffer cmd, HDCamera hdCamera)
		{
			WaterRendering component = hdCamera.volumeStack.GetComponent<WaterRendering>();
			if (!component.enable.value || !hdCamera.frameSettings.IsEnabled(FrameSettingsField.Water) || WaterSurface.instanceCount == 0)
			{
				return;
			}
			PropagateFrustumDataToGPU(hdCamera);
			int instanceCount = WaterSurface.instanceCount;
			WaterSurface[] instancesAsArray = WaterSurface.instancesAsArray;
			for (int i = 0; i < instanceCount; i++)
			{
				WaterSurface waterSurface = instancesAsArray[i];
				if (waterSurface.simulation.ValidResources((int)m_WaterBandResolution, 3))
				{
					WaterRenderingParameters parameters = PrepareWaterRenderingParameters(hdCamera, component, waterSurface, i, i == m_UnderWaterSurfaceIndex);
					RTHandle causticsBuffer = ((waterSurface.simulation.gpuBuffers.causticsBuffer != null) ? waterSurface.simulation.gpuBuffers.causticsBuffer : TextureXR.GetBlackTexture());
					RenderWaterSurface(cmd, waterSurface.simulation.gpuBuffers.displacementBuffer, waterSurface.simulation.gpuBuffers.additionalDataBuffer, causticsBuffer, TextureXR.GetBlackTexture(), TextureXR.GetBlackTexture(), null, null, m_WaterCameraHeightBuffer, m_WaterPatchDataBuffer, m_WaterIndirectDispatchBuffer, m_WaterCameraFrustrumBuffer, parameters);
				}
			}
		}
	}
}
